// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   riscv/isa/main.isa

#if !defined(__SPLIT) || (__SPLIT == 1)

// CIAddi4spnOp::c_addi4spn((['\n            imm = CIMM8<1:1> << 2 |\n                  CIMM8<0:0> << 3 |\n                  CIMM8<7:6> << 4 |\n                  CIMM8<5:2> << 6;\n        ', '\n            if (imm == 0)\n                return std::make_shared<IllegalInstFault>("immediate = 0",\n                                                           machInst);\n            Rp2 = rvSext(sp + imm);\n        ', 'uint64_t'], {}))

    C_addi4spn::C_addi4spn(ExtMachInst machInst)
        : ImmOp<uint64_t>("c_addi4spn", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	setDestRegIdx(_numDestRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
            imm = bits(CIMM8, 1, 1) << 2 |
                  bits(CIMM8, 0, 0) << 3 |
                  bits(CIMM8, 7, 6) << 4 |
                  bits(CIMM8, 5, 2) << 6;
        ;
    }

// CompressedLoad::c_fld(['\n                offset = CIMM3 << 3 | CIMM2 << 6;\n            ', '\n                STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                if (status.fs == FPUStatus::OFF)\n                    return std::make_shared<IllegalInstFault>("FPU is off",\n                                                               machInst);\n\n                // Mutating any floating point register changes the FS bit\n                // of the STATUS CSR.\n                status.fs = FPUStatus::DIRTY;\n                xc->setMiscReg(MISCREG_STATUS, status);\n\n                Fp2_bits = Mem;\n            ', '\n                EA = rvZext(Rp1 + offset);\n            '],{})

    C_fld::C_fld(ExtMachInst machInst):
        Load("c_fld", machInst, FloatMemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, floatRegClass[FP2 + 8]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        
                offset = CIMM3 << 3 | CIMM2 << 6;
            ;
    }

// CompressedLoad::c_lw(['\n                offset = CIMM2<1:1> << 2 |\n                         CIMM3 << 3 |\n                         CIMM2<0:0> << 6;\n            ', '\n                Rp2_sd = Mem_sw;\n            ', '\n                EA = rvZext(Rp1 + offset);\n            '],{})

    C_lw::C_lw(ExtMachInst machInst):
        Load("c_lw", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::WordAlign;;
        
                offset = bits(CIMM2, 1, 1) << 2 |
                         CIMM3 << 3 |
                         bits(CIMM2, 0, 0) << 6;
            ;
    }

// CompressedLoad::c_flw(['\n                    offset = CIMM2<1:1> << 2 |\n                             CIMM3 << 3 |\n                             CIMM2<0:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd = freg(f32(Mem_uw));\n                    Fp2_bits = fd.v;\n                ', '\n                    EA = (uint32_t)(Rp1_uw + offset);\n                '],{})

    C_flw::C_flw(ExtMachInst machInst):
        Load("c_flw", machInst, FloatMemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, floatRegClass[FP2 + 8]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::WordAlign;;
        
                    offset = bits(CIMM2, 1, 1) << 2 |
                             CIMM3 << 3 |
                             bits(CIMM2, 0, 0) << 6;
                ;
    }

// CompressedLoad::c_ld(['\n                    offset = CIMM3 << 3 | CIMM2 << 6;\n                ', '\n                    Rp2_sd = Mem_sd;\n                ', '\n                    EA = Rp1 + offset;\n                '],{})

    C_ld::C_ld(ExtMachInst machInst):
        Load("c_ld", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        
                    offset = CIMM3 << 3 | CIMM2 << 6;
                ;
    }

// Unknown::unknown(([], {}))

// CompressedLoad::c_lbu(['\n                    offset = (CIMM2<0:0> << 1) | CIMM2<1:1>;\n                ', '\n                    Rp2 = Mem_ub;\n                ', '\n                    EA = rvZext(Rp1 + offset);\n                '],{})

    C_lbu::C_lbu(ExtMachInst machInst):
        Load("c_lbu", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::ByteAlign;;
        
                    offset = (bits(CIMM2, 0, 0) << 1) | bits(CIMM2, 1, 1);
                ;
    }

// CompressedLoad::c_lhu(['\n                        offset = CIMM2<0:0> << 1;\n                    ', '\n                        Rp2 = Mem_uh;\n                    ', '\n                        EA = rvZext(Rp1 + offset);\n                    '],{})

    C_lhu::C_lhu(ExtMachInst machInst):
        Load("c_lhu", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::HalfWordAlign;;
        
                        offset = bits(CIMM2, 0, 0) << 1;
                    ;
    }

// CompressedLoad::c_lh(['\n                        offset = CIMM2<0:0> << 1;\n                    ', '\n                        Rp2_sd = Mem_sh;\n                    ', '\n                        EA = rvZext(Rp1 + offset);\n                    '],{})

    C_lh::C_lh(ExtMachInst machInst):
        Load("c_lh", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::HalfWordAlign;;
        
                        offset = bits(CIMM2, 0, 0) << 1;
                    ;
    }

// Unknown::unknown(([], {}))

// CompressedStore::c_sb(['\n                    offset = (CIMM2<0:0> << 1) | CIMM2<1:1>;\n                ', '\n                    Mem_ub = Rp2_ub;\n                '],{'ea_code': '\n                    EA = rvZext(Rp1 + offset);\n                '})

    C_sb::C_sb(ExtMachInst machInst):
        Store("c_sb", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::ByteAlign;;
        
                    offset = (bits(CIMM2, 0, 0) << 1) | bits(CIMM2, 1, 1);
                ;
    }

// CompressedStore::c_sh(['\n                    offset = (CIMM2<0:0> << 1);\n                ', '\n                    Mem_uh = Rp2_uh;\n                '],{'ea_code': '\n                    EA = rvZext(Rp1 + offset);\n                '})

    C_sh::C_sh(ExtMachInst machInst):
        Store("c_sh", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::HalfWordAlign;;
        
                    offset = (bits(CIMM2, 0, 0) << 1);
                ;
    }

// Unknown::unknown(([], {}))

// CompressedStore::c_fsd(['\n                offset = CIMM3 << 3 | CIMM2 << 6;\n            ', '\n                STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                if (status.fs == FPUStatus::OFF)\n                    return std::make_shared<IllegalInstFault>("FPU is off",\n                                                               machInst);\n\n                Mem = Fp2_bits;\n            ', '\n                EA = rvZext(Rp1 + offset);\n            '],{})

    C_fsd::C_fsd(ExtMachInst machInst):
        Store("c_fsd", machInst, FloatMemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FP2 + 8]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        
                offset = CIMM3 << 3 | CIMM2 << 6;
            ;
    }

// CompressedStore::c_sw(['\n                offset = CIMM2<1:1> << 2 |\n                         CIMM3 << 3 |\n                         CIMM2<0:0> << 6;\n            ', '\n                Mem_uw = Rp2_uw;\n            '],{'ea_code': '\n                EA = rvZext(Rp1 + offset);\n            '})

    C_sw::C_sw(ExtMachInst machInst):
        Store("c_sw", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::WordAlign;;
        
                offset = bits(CIMM2, 1, 1) << 2 |
                         CIMM3 << 3 |
                         bits(CIMM2, 0, 0) << 6;
            ;
    }

// CompressedStore::c_fsw(['\n                    offset = CIMM2<1:1> << 2 |\n                             CIMM3 << 3 |\n                             CIMM2<0:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    Mem_uw = unboxF32(boxF32(Fp2_bits));\n                ', '\n                    EA = (uint32_t)(Rp1_uw + offset);\n                '],{})

    C_fsw::C_fsw(ExtMachInst machInst):
        Store("c_fsw", machInst, FloatMemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FP2 + 8]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::WordAlign;;
        
                    offset = bits(CIMM2, 1, 1) << 2 |
                             CIMM3 << 3 |
                             bits(CIMM2, 0, 0) << 6;
                ;
    }

// CompressedStore::c_sd(['\n                    offset = CIMM3 << 3 | CIMM2 << 6;\n                ', '\n                    Mem_ud = Rp2_ud;\n                ', '\n                    EA = Rp1 + offset;\n                '],{})

    C_sd::C_sd(ExtMachInst machInst):
        Store("c_sd", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        
                    offset = CIMM3 << 3 | CIMM2 << 6;
                ;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// CIOp::c_addi((['\n            imm = sext<6>(CIMM5 | (CIMM1 << 5));\n        ', '\n            if ((RC1 == 0) != (imm == 0)) {\n                if (RC1 == 0) {\n                    // imm != 0 is HINT\n                } else {\n                    // imm == 0 is HINT\n                }\n            }\n            Rc1_sd = rvSext(Rc1_sd + imm);\n        '], {}))

    C_addi::C_addi(ExtMachInst machInst)
        : ImmOp<int64_t>("c_addi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
            imm = sext<6>(CIMM5 | (CIMM1 << 5));
        ;
    }

// CJOp::c_jal((['\n                ra_sw = NPC_uw;\n                NPC_uw = PC_uw + imm;\n            ', 'IsDirectControl', 'IsUncondControl', 'IsCall'], {}))

    C_jal::C_jal(ExtMachInst machInst)
        : ImmOp<int64_t>("c_jal", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((ReturnAddrReg) == 0) ? RegId() : intRegClass[ReturnAddrReg]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
        
            imm = sext<12>((CJUMPIMM3TO1 << 1) |
                           (CJUMPIMM4TO4 << 4) |
                           (CJUMPIMM5TO5 << 5) |
                           (CJUMPIMM6TO6 << 6) |
                           (CJUMPIMM7TO7 << 7) |
                           (CJUMPIMM9TO8 << 8) |
                           (CJUMPIMM10TO10 << 10) |
                           (CJUMPIMMSIGN << 11));
    ;
        if (QUADRANT != 0x3) {
            if (COPCODE == 4) {
                // Handle "c_jr" instruction, set "IsReturn" flag if RC1 is 1 or 5
                if (CFUNCT1 == 0 && (RC1 == 1 || RC1 == 5))
                    flags[IsReturn] = true;
                // Handle "c_jalr" instruction, set IsReturn if RC1 != ra
                if (CFUNCT1 == 1 && RC1 == 5)
                    flags[IsReturn] = true;
            }
        } else {
            bool rd_link = (RD == 1 || RD == 5);
            bool rs1_link = (RS1 == 1 || RS1 == 5);
            // Handle "jalr" and "jal" instruction,
            // set "IsCall" if RD is link register
            if (rd_link)
                flags[IsCall] = true;

            // Handle "Jalr" instruction
            if (FUNCT3 == 0x0 && OPCODE5 == 0x19) {
                // If RD is not link and RS1 is link, then pop RAS
                if (!rd_link && rs1_link) flags[IsReturn] = true;
                else if (rd_link) {
                    // If RD is link and RS1 is not link, push RAS
                    if (!rs1_link) flags[IsCall] = true;
                    // If RD is link and RS1 is link and rd != rs1
                    else if (rs1_link) {
                        if (RS1 != RD) {
                            // Both are link and RS1 == RD, pop then push
                            flags[IsReturn] = true;
                            flags[IsCall] = true;
                        } else {
                            // Both are link and RS1 != RD, push RAS
                            flags[IsCall] = true;
                        }
                    }
                }
            }
        }
    }

// CIOp::c_addiw((['\n                imm = sext<6>(CIMM5 | (CIMM1 << 5));\n            ', '\n                if (RC1 == 0) {\n                    return std::make_shared<IllegalInstFault>(\n                            "source reg x0", machInst);\n                }\n                Rc1_sw = (int32_t)(Rc1_sw + imm);\n            '], {}))

    C_addiw::C_addiw(ExtMachInst machInst)
        : ImmOp<int64_t>("c_addiw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
                imm = sext<6>(CIMM5 | (CIMM1 << 5));
            ;
    }

// Unknown::unknown(([], {}))

// CIOp::c_li((['\n            imm = sext<6>(CIMM5 | (CIMM1 << 5));\n        ', '\n            // RC1 == 0 is HINT\n            Rc1_sd = imm;\n        '], {}))

    C_li::C_li(ExtMachInst machInst)
        : ImmOp<int64_t>("c_li", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
            imm = sext<6>(CIMM5 | (CIMM1 << 5));
        ;
    }

// CIOp::c_addi16sp((['\n                imm = sext<10>((CIMM5<4:4> << 4) |\n                               (CIMM5<0:0> << 5) |\n                               (CIMM5<3:3> << 6) |\n                               (CIMM5<2:1> << 7) |\n                               (CIMM1 << 9));\n            ', '\n                if (imm == 0) {\n                    return std::make_shared<IllegalInstFault>(\n                            "immediate = 0", machInst);\n                }\n                sp_sd = rvSext(sp_sd + imm);\n            '], {}))

    C_addi16sp::C_addi16sp(ExtMachInst machInst)
        : ImmOp<int64_t>("c_addi16sp", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	setDestRegIdx(_numDestRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
                imm = sext<10>((bits(CIMM5, 4, 4) << 4) |
                               (bits(CIMM5, 0, 0) << 5) |
                               (bits(CIMM5, 3, 3) << 6) |
                               (bits(CIMM5, 2, 1) << 7) |
                               (CIMM1 << 9));
            ;
    }

// CIOp::c_lui((['\n                imm = sext<6>(CIMM5 | (CIMM1 << 5)) << 12;\n            ', '\n                // RC1 == 0 is HINT\n                if (imm == 0) {\n                    return std::make_shared<IllegalInstFault>(\n                            "immediate = 0", machInst);\n                }\n                Rc1_sd = imm;\n            '], {}))

    C_lui::C_lui(ExtMachInst machInst)
        : ImmOp<int64_t>("c_lui", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
                imm = sext<6>(CIMM5 | (CIMM1 << 5)) << 12;
            ;
    }

// CIOp::c_srli(['\n                    imm = CIMM5 | (CIMM1 << 5);\n                ', '\n                    if (rvSelect((bool)CIMM1, false)) {\n                        return std::make_shared<IllegalInstFault>(\n                                "shmat[5] != 0", machInst);\n                    }\n                    if (imm == 0) {\n                        // C.SRLI64, HINT for RV32/RV64\n                    }\n                    // The MSB can never be 1, hence no need to sign ext.\n                    Rp1 = rvZext(Rp1) >> imm;\n                ', 'uint64_t'],{})

    C_srli::C_srli(ExtMachInst machInst)
        : ImmOp<uint64_t>("c_srli", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
                    imm = CIMM5 | (CIMM1 << 5);
                ;
    }

// CIOp::c_srai(['\n                    imm = CIMM5 | (CIMM1 << 5);\n                ', '\n                    if (rvSelect((bool)CIMM1, false)) {\n                        return std::make_shared<IllegalInstFault>(\n                                "shmat[5] != 0", machInst);\n                    }\n                    if (imm == 0) {\n                        // C.SRAI64, HINT for RV32/RV64\n                    }\n                    Rp1_sd = rvSext(Rp1_sd) >> imm;\n                ', 'uint64_t'],{})

    C_srai::C_srai(ExtMachInst machInst)
        : ImmOp<uint64_t>("c_srai", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
                    imm = CIMM5 | (CIMM1 << 5);
                ;
    }

// CIOp::c_andi(['\n                    imm = CIMM5;\n                    if (CIMM1 > 0)\n                        imm |= ~((uint64_t)0x1F);\n                ', '\n                    Rp1 = rvSext(Rp1 & imm);\n                ', 'uint64_t'],{})

    C_andi::C_andi(ExtMachInst machInst)
        : ImmOp<uint64_t>("c_andi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
                    imm = CIMM5;
                    if (CIMM1 > 0)
                        imm |= ~((uint64_t)0x1F);
                ;
    }

// CompressedROp::c_sub(['\n                            Rp1 = rvSext(Rp1 - Rp2);\n                        '],{})

    C_sub::C_sub(ExtMachInst machInst)
        : RegOp("c_sub", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;;
    }

// CompressedROp::c_xor(['\n                            Rp1 = rvSext(Rp1 ^ Rp2);\n                        '],{})

    C_xor::C_xor(ExtMachInst machInst)
        : RegOp("c_xor", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;;
    }

// CompressedROp::c_or(['\n                            Rp1 = rvSext(Rp1 | Rp2);\n                        '],{})

    C_or::C_or(ExtMachInst machInst)
        : RegOp("c_or", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;;
    }

// CompressedROp::c_and(['\n                            Rp1 = rvSext(Rp1 & Rp2);\n                        '],{})

    C_and::C_and(ExtMachInst machInst)
        : RegOp("c_and", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// CompressedROp::c_subw(['\n                                Rp1_sd = (int32_t)Rp1_sd - Rp2_sw;\n                            '],{})

    C_subw::C_subw(ExtMachInst machInst)
        : RegOp("c_subw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// CompressedROp::c_addw(['\n                                Rp1_sd = (int32_t)Rp1_sd + Rp2_sw;\n                            '],{})

    C_addw::C_addw(ExtMachInst machInst)
        : RegOp("c_addw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// CompressedROp::c_mul(['\n                            Rp1_sd = rvSext(Rp1_sd * Rp2_sd);\n                        ', 'IntMultOp'],{})

    C_mul::C_mul(ExtMachInst machInst)
        : RegOp("c_mul", machInst, IntMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RP2 + 8) == 0) ? RegId() : intRegClass[RP2 + 8]);
	flags[IsInteger] = true;;
    }

// CompressedROp::c_zext_b(['\n                                Rp1 = Rp1 & 0xFFULL;\n                            '],{})

    C_zext_b::C_zext_b(ExtMachInst machInst)
        : RegOp("c_zext_b", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

// CompressedROp::c_sext_b(['\n                                Rp1 = sext<8>(Rp1 & 0xFFULL);\n                            '],{})

    C_sext_b::C_sext_b(ExtMachInst machInst)
        : RegOp("c_sext_b", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

// CompressedROp::c_zext_h(['\n                                Rp1 = Rp1 & 0xFFFFULL;\n                            '],{})

    C_zext_h::C_zext_h(ExtMachInst machInst)
        : RegOp("c_zext_h", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

// CompressedROp::c_sext_h(['\n                                Rp1 = sext<16>(Rp1 & 0xFFFFULL);\n                            '],{})

    C_sext_h::C_sext_h(ExtMachInst machInst)
        : RegOp("c_sext_h", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

// CompressedROp::c_zext_w(['\n                                    Rp1 = bits(Rp1, 31, 0);\n                                '],{})

    C_zext_w::C_zext_w(ExtMachInst machInst)
        : RegOp("c_zext_w", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// CompressedROp::c_not(['\n                                Rp1 = ~Rp1;\n                            '],{})

    C_not::C_not(ExtMachInst machInst)
        : RegOp("c_not", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	setDestRegIdx(_numDestRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// CJOp::c_j((['\n            NPC = rvZext(PC + imm);\n        ', 'IsDirectControl', 'IsUncondControl'], {}))

    C_j::C_j(ExtMachInst machInst)
        : ImmOp<int64_t>("c_j", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsUncondControl] = true;;
        
            imm = sext<12>((CJUMPIMM3TO1 << 1) |
                           (CJUMPIMM4TO4 << 4) |
                           (CJUMPIMM5TO5 << 5) |
                           (CJUMPIMM6TO6 << 6) |
                           (CJUMPIMM7TO7 << 7) |
                           (CJUMPIMM9TO8 << 8) |
                           (CJUMPIMM10TO10 << 10) |
                           (CJUMPIMMSIGN << 11));
    ;
        if (QUADRANT != 0x3) {
            if (COPCODE == 4) {
                // Handle "c_jr" instruction, set "IsReturn" flag if RC1 is 1 or 5
                if (CFUNCT1 == 0 && (RC1 == 1 || RC1 == 5))
                    flags[IsReturn] = true;
                // Handle "c_jalr" instruction, set IsReturn if RC1 != ra
                if (CFUNCT1 == 1 && RC1 == 5)
                    flags[IsReturn] = true;
            }
        } else {
            bool rd_link = (RD == 1 || RD == 5);
            bool rs1_link = (RS1 == 1 || RS1 == 5);
            // Handle "jalr" and "jal" instruction,
            // set "IsCall" if RD is link register
            if (rd_link)
                flags[IsCall] = true;

            // Handle "Jalr" instruction
            if (FUNCT3 == 0x0 && OPCODE5 == 0x19) {
                // If RD is not link and RS1 is link, then pop RAS
                if (!rd_link && rs1_link) flags[IsReturn] = true;
                else if (rd_link) {
                    // If RD is link and RS1 is not link, push RAS
                    if (!rs1_link) flags[IsCall] = true;
                    // If RD is link and RS1 is link and rd != rs1
                    else if (rs1_link) {
                        if (RS1 != RD) {
                            // Both are link and RS1 == RD, pop then push
                            flags[IsReturn] = true;
                            flags[IsCall] = true;
                        } else {
                            // Both are link and RS1 != RD, push RAS
                            flags[IsCall] = true;
                        }
                    }
                }
            }
        }
    }

// CBOp::c_beqz(['\n                if (rvSext(Rp1) == 0)\n                    NPC = rvZext(PC + imm);\n                else\n                    NPC = NPC;\n            ', 'IsDirectControl', 'IsCondControl'],{})

    C_beqz::C_beqz(ExtMachInst machInst)
        : ImmOp<int64_t>("c_beqz", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        
                imm = sext<9>((bits(CIMM5, 2, 1) << 1) |
                              (bits(CIMM3, 1, 0) << 3) |
                              (bits(CIMM5, 0, 0) << 5) |
                              (bits(CIMM5, 4, 3) << 6) |
                              (bits(CIMM3, 2, 2) << 8));
               ;
    }

// CBOp::c_bnez(['\n                if (rvSext(Rp1) != 0)\n                    NPC = rvZext(PC + imm);\n                else\n                    NPC = NPC;\n            ', 'IsDirectControl', 'IsCondControl'],{})

    C_bnez::C_bnez(ExtMachInst machInst)
        : ImmOp<int64_t>("c_bnez", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RP1 + 8) == 0) ? RegId() : intRegClass[RP1 + 8]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        
                imm = sext<9>((bits(CIMM5, 2, 1) << 1) |
                              (bits(CIMM3, 1, 0) << 3) |
                              (bits(CIMM5, 0, 0) << 5) |
                              (bits(CIMM5, 4, 3) << 6) |
                              (bits(CIMM3, 2, 2) << 8));
               ;
    }

// Unknown::unknown(([], {}))

// CIOp::c_slli((['\n            imm = CIMM5 | (CIMM1 << 5);\n        ', '\n            if (rvSelect((bool)CIMM1, false)) {\n                return std::make_shared<IllegalInstFault>(\n                        "shmat[5] != 0", machInst);\n            }\n            if (imm == 0) {\n                // C.SLLI64, HINT for RV32/RV64\n            }\n            // RC1 == 0 is HINT\n            Rc1 = rvSext(Rc1 << imm);\n        ', 'uint64_t'], {}))

    C_slli::C_slli(ExtMachInst machInst)
        : ImmOp<uint64_t>("c_slli", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        
            imm = CIMM5 | (CIMM1 << 5);
        ;
    }

// CompressedLoad::c_fldsp(['\n                offset = CIMM5<4:3> << 3 |\n                         CIMM1 << 5 |\n                         CIMM5<2:0> << 6;\n            ', '\n                STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                if (status.fs == FPUStatus::OFF)\n                    return std::make_shared<IllegalInstFault>("FPU is off",\n                                                               machInst);\n\n                status.fs = FPUStatus::DIRTY;\n                xc->setMiscReg(MISCREG_STATUS, status);\n\n                Fc1_bits = Mem;\n            ', '\n                EA = rvZext(sp + offset);\n            '],{})

    C_fldsp::C_fldsp(ExtMachInst machInst):
        Load("c_fldsp", machInst, FloatMemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FC1]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        
                offset = bits(CIMM5, 4, 3) << 3 |
                         CIMM1 << 5 |
                         bits(CIMM5, 2, 0) << 6;
            ;
    }

// CompressedLoad::c_lwsp(['\n                offset = CIMM5<4:2> << 2 |\n                         CIMM1 << 5 |\n                         CIMM5<1:0> << 6;\n            ', '\n                if (RC1 == 0) {\n                    return std::make_shared<IllegalInstFault>(\n                            "source reg x0", machInst);\n                }\n                Rc1_sw = Mem_sw;\n            ', '\n                EA = rvZext(sp + offset);\n            '],{})

    C_lwsp::C_lwsp(ExtMachInst machInst):
        Load("c_lwsp", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::WordAlign;;
        
                offset = bits(CIMM5, 4, 2) << 2 |
                         CIMM1 << 5 |
                         bits(CIMM5, 1, 0) << 6;
            ;
    }

// CompressedLoad::c_flwsp(['\n                    offset = CIMM5<4:2> << 2 |\n                             CIMM1 << 5 |\n                             CIMM5<1:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd;\n                    fd = freg(f32(Mem_uw));\n                    Fc1_bits = fd.v;\n                ', '\n                    EA = (uint32_t)(sp_uw + offset);\n                '],{})

    C_flwsp::C_flwsp(ExtMachInst machInst):
        Load("c_flwsp", machInst, FloatMemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FC1]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::WordAlign;;
        
                    offset = bits(CIMM5, 4, 2) << 2 |
                             CIMM1 << 5 |
                             bits(CIMM5, 1, 0) << 6;
                ;
    }

// CompressedLoad::c_ldsp(['\n                    offset = CIMM5<4:3> << 3 |\n                             CIMM1 << 5 |\n                             CIMM5<2:0> << 6;\n                ', '\n                    if (RC1 == 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x0", machInst);\n                    }\n                    Rc1_sd = Mem_sd;\n                ', '\n                    EA = sp + offset;\n                '],{})

    C_ldsp::C_ldsp(ExtMachInst machInst):
        Load("c_ldsp", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        
                    offset = bits(CIMM5, 4, 3) << 3 |
                             CIMM1 << 5 |
                             bits(CIMM5, 2, 0) << 6;
                ;
    }

// Unknown::unknown(([], {}))

// CJump::c_jr((['\n                    if (RC1 == 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x0", machInst);\n                    }\n                    NPC = rvZext(Rc1 & (~0x1));\n                ', 'IsIndirectControl', 'IsUncondControl'], {}))

    C_jr::C_jr(ExtMachInst machInst)
        : ImmOp<int64_t>("c_jr", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
        imm = 0;;
        if (QUADRANT != 0x3) {
            if (COPCODE == 4) {
                // Handle "c_jr" instruction, set "IsReturn" flag if RC1 is 1 or 5
                if (CFUNCT1 == 0 && (RC1 == 1 || RC1 == 5))
                    flags[IsReturn] = true;
                // Handle "c_jalr" instruction, set IsReturn if RC1 != ra
                if (CFUNCT1 == 1 && RC1 == 5)
                    flags[IsReturn] = true;
            }
        } else {
            bool rd_link = (RD == 1 || RD == 5);
            bool rs1_link = (RS1 == 1 || RS1 == 5);
            // Handle "jalr" and "jal" instruction,
            // set "IsCall" if RD is link register
            if (rd_link)
                flags[IsCall] = true;

            // Handle "Jalr" instruction
            if (FUNCT3 == 0x0 && OPCODE5 == 0x19) {
                // If RD is not link and RS1 is link, then pop RAS
                if (!rd_link && rs1_link) flags[IsReturn] = true;
                else if (rd_link) {
                    // If RD is link and RS1 is not link, push RAS
                    if (!rs1_link) flags[IsCall] = true;
                    // If RD is link and RS1 is link and rd != rs1
                    else if (rs1_link) {
                        if (RS1 != RD) {
                            // Both are link and RS1 == RD, pop then push
                            flags[IsReturn] = true;
                            flags[IsCall] = true;
                        } else {
                            // Both are link and RS1 != RD, push RAS
                            flags[IsCall] = true;
                        }
                    }
                }
            }
        }
    }

// CROp::c_mv((['\n                    // RC1 == 0 is HINT\n                    Rc1 = rvSext(Rc2);\n                '], {}))

    C_mv::C_mv(ExtMachInst machInst)
        : CompRegOp("c_mv", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RC2) == 0) ? RegId() : intRegClass[RC2]);
	flags[IsInteger] = true;;
    }

// SystemOp::c_ebreak((['\n                        // NB: Semihosting spec requires uncompressed ebreak,\n                        // so this instruction does not check for semihosting.\n                        return std::make_shared<BreakpointFault>(\n                            xc->pcState());\n                    ', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'], {}))

    C_ebreak::C_ebreak(ExtMachInst machInst)
        : SystemOp("c_ebreak", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// CJump::c_jalr((['\n                        ra = rvSext(NPC);\n                        NPC = rvZext(Rc1 & (~0x1));\n                    ', 'IsIndirectControl', 'IsUncondControl', 'IsCall'], {}))

    C_jalr::C_jalr(ExtMachInst machInst)
        : ImmOp<int64_t>("c_jalr", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((ReturnAddrReg) == 0) ? RegId() : intRegClass[ReturnAddrReg]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
        imm = 0;;
        if (QUADRANT != 0x3) {
            if (COPCODE == 4) {
                // Handle "c_jr" instruction, set "IsReturn" flag if RC1 is 1 or 5
                if (CFUNCT1 == 0 && (RC1 == 1 || RC1 == 5))
                    flags[IsReturn] = true;
                // Handle "c_jalr" instruction, set IsReturn if RC1 != ra
                if (CFUNCT1 == 1 && RC1 == 5)
                    flags[IsReturn] = true;
            }
        } else {
            bool rd_link = (RD == 1 || RD == 5);
            bool rs1_link = (RS1 == 1 || RS1 == 5);
            // Handle "jalr" and "jal" instruction,
            // set "IsCall" if RD is link register
            if (rd_link)
                flags[IsCall] = true;

            // Handle "Jalr" instruction
            if (FUNCT3 == 0x0 && OPCODE5 == 0x19) {
                // If RD is not link and RS1 is link, then pop RAS
                if (!rd_link && rs1_link) flags[IsReturn] = true;
                else if (rd_link) {
                    // If RD is link and RS1 is not link, push RAS
                    if (!rs1_link) flags[IsCall] = true;
                    // If RD is link and RS1 is link and rd != rs1
                    else if (rs1_link) {
                        if (RS1 != RD) {
                            // Both are link and RS1 == RD, pop then push
                            flags[IsReturn] = true;
                            flags[IsCall] = true;
                        } else {
                            // Both are link and RS1 != RD, push RAS
                            flags[IsCall] = true;
                        }
                    }
                }
            }
        }
    }

// CompressedROp::c_add((['\n                    // RC1 == 0 is HINT\n                    Rc1_sd = rvSext(Rc1_sd + Rc2_sd);\n                '], {}))

    C_add::C_add(ExtMachInst machInst)
        : RegOp("c_add", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	setDestRegIdx(_numDestRegs++, ((RC1) == 0) ? RegId() : intRegClass[RC1]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RC2) == 0) ? RegId() : intRegClass[RC2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// CompressedStore::c_fsdsp(['\n                offset = CIMM6<5:3> << 3 |\n                         CIMM6<2:0> << 6;\n            ', '\n                STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                if (status.fs == FPUStatus::OFF)\n                    return std::make_shared<IllegalInstFault>("FPU is off",\n                                                               machInst);\n\n                Mem_ud = Fc2_bits;\n            ', '\n                EA = rvZext(sp + offset);\n            '],{})

    C_fsdsp::C_fsdsp(ExtMachInst machInst):
        Store("c_fsdsp", machInst, FloatMemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FC2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        
                offset = bits(CIMM6, 5, 3) << 3 |
                         bits(CIMM6, 2, 0) << 6;
            ;
    }

// CompressedStore::c_swsp(['\n                offset = CIMM6<5:2> << 2 |\n                         CIMM6<1:0> << 6;\n            ', '\n                Mem_uw = Rc2_uw;\n            ', '\n                EA = rvZext(sp + offset);\n            '],{})

    C_swsp::C_swsp(ExtMachInst machInst):
        Store("c_swsp", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	setSrcRegIdx(_numSrcRegs++, ((RC2) == 0) ? RegId() : intRegClass[RC2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::WordAlign;;
        
                offset = bits(CIMM6, 5, 2) << 2 |
                         bits(CIMM6, 1, 0) << 6;
            ;
    }

// CompressedStore::c_fswsp(['\n                    offset = CIMM6<5:2> << 2 |\n                             CIMM6<1:0> << 6;\n                ', '\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>("FPU is off",\n                                                                   machInst);\n\n                    Mem_uw = unboxF32(boxF32(Fc2_bits));\n                ', '\n                    EA = (uint32_t)(sp_uw + offset);\n                '],{})

    C_fswsp::C_fswsp(ExtMachInst machInst):
        Store("c_fswsp", machInst, FloatMemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FC2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::WordAlign;;
        
                    offset = bits(CIMM6, 5, 2) << 2 |
                             bits(CIMM6, 1, 0) << 6;
                ;
    }

// CompressedStore::c_sdsp(['\n                    offset = CIMM6<5:3> << 3 |\n                             CIMM6<2:0> << 6;\n                ', '\n                    Mem = Rc2;\n                ', '\n                    EA = sp + offset;\n                '],{})

    C_sdsp::C_sdsp(ExtMachInst machInst):
        Store("c_sdsp", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((StackPointerReg) == 0) ? RegId() : intRegClass[StackPointerReg]);
	setSrcRegIdx(_numSrcRegs++, ((RC2) == 0) ? RegId() : intRegClass[RC2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        
                    offset = bits(CIMM6, 5, 3) << 3 |
                             bits(CIMM6, 2, 0) << 6;
                ;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Load::lb(['\n                    Rd_sd = Mem_sb;\n                '],{})

    Lb::Lb(ExtMachInst machInst):
        Load("lb", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::ByteAlign;;
        offset = sext<12>(IMM12);;
    }

// Load::lh(['\n                    Rd_sd = Mem_sh;\n                '],{})

    Lh::Lh(ExtMachInst machInst):
        Load("lh", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::HalfWordAlign;;
        offset = sext<12>(IMM12);;
    }

// Load::lw(['\n                    Rd_sd = Mem_sw;\n                '],{})

    Lw::Lw(ExtMachInst machInst):
        Load("lw", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::WordAlign;;
        offset = sext<12>(IMM12);;
    }

// Load::ld(['\n                        Rd_sd = Mem_sd;\n                    '],{})

    Ld::Ld(ExtMachInst machInst):
        Load("ld", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        offset = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// Load::lbu(['\n                    Rd = Mem_ub;\n                '],{})

    Lbu::Lbu(ExtMachInst machInst):
        Load("lbu", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::ByteAlign;;
        offset = sext<12>(IMM12);;
    }

// Load::lhu(['\n                    Rd = Mem_uh;\n                '],{})

    Lhu::Lhu(ExtMachInst machInst):
        Load("lhu", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::HalfWordAlign;;
        offset = sext<12>(IMM12);;
    }

// Load::lwu(['\n                        Rd = Mem_uw;\n                    '],{})

    Lwu::Lwu(ExtMachInst machInst):
        Load("lwu", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::WordAlign;;
        offset = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Load::flh(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                    "FPU is off", machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd;\n                    fd = freg(f16(Mem_uh));\n                    Fd_bits = fd.v;\n                '],{'inst_flags': 'FloatMemReadOp'})

    Flh::Flh(ExtMachInst machInst):
        Load("flh", machInst, FloatMemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::HalfWordAlign;;
        offset = sext<12>(IMM12);;
    }

// Load::flw(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                    "FPU is off", machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd;\n                    fd = freg(f32(Mem_uw));\n                    Fd_bits = fd.v;\n                '],{'inst_flags': 'FloatMemReadOp'})

    Flw::Flw(ExtMachInst machInst):
        Load("flw", machInst, FloatMemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::WordAlign;;
        offset = sext<12>(IMM12);;
    }

// Load::fld(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                    "FPU is off", machInst);\n\n                    status.fs = FPUStatus::DIRTY;\n                    xc->setMiscReg(MISCREG_STATUS, status);\n\n                    freg_t fd;\n                    fd = freg(f64(Mem));\n                    Fd_bits = fd.v;\n                '],{'inst_flags': 'FloatMemReadOp'})

    Fld::Fld(ExtMachInst machInst):
        Load("fld", machInst, FloatMemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        offset = sext<12>(IMM12);;
    }

// VleOp::vle8_v((['\n                            if ((machInst.vm || elem_mask(v0, ei)) &&\n                                i < this->microVl) {\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            }\n                        '], {'inst_flags': 'SimdUnitStrideLoadOp'}))


Vle8_vMicro::Vle8_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _vlen)
  : VleMicroInst(
        "vle8_v_micro", _machInst, SimdUnitStrideLoadOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vle8_v::Vle8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vle8_v", _machInst, SimdUnitStrideLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vle8_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    if (_opClass == SimdUnitStrideFaultOnlyFirstLoadOp) {
        microop = new VlFFTrimVlMicroOp(_machInst, this->vl, num_microops,
                                        vlen, microops);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlSegOp::vlseg2e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg2e8_vMicro::Vlseg2e8_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg2e8_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg2e8_v::Vlseg2e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg2e8_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg2e8_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg3e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg3e8_vMicro::Vlseg3e8_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg3e8_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg3e8_v::Vlseg3e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg3e8_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg3e8_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg4e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg4e8_vMicro::Vlseg4e8_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg4e8_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg4e8_v::Vlseg4e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg4e8_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg4e8_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg5e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg5e8_vMicro::Vlseg5e8_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg5e8_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg5e8_v::Vlseg5e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg5e8_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg5e8_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg6e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg6e8_vMicro::Vlseg6e8_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg6e8_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg6e8_v::Vlseg6e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg6e8_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg6e8_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg7e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg7e8_vMicro::Vlseg7e8_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg7e8_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg7e8_v::Vlseg7e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg7e8_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg7e8_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg8e8_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&\n                                    i < this->microVl) {\n                                    Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg8e8_vMicro::Vlseg8e8_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg8e8_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg8e8_v::Vlseg8e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg8e8_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg8e8_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// Unknown::unknown(([], {}))

// VlWholeOp::vl1re8_v(['\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl1re8_vMicro::Vl1re8_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl1re8_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl1re8_v::Vl1re8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl1re8_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl1re8_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl2re8_v(['\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl2re8_vMicro::Vl2re8_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl2re8_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl2re8_v::Vl2re8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl2re8_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl2re8_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl4re8_v(['\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl4re8_vMicro::Vl4re8_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl4re8_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl4re8_v::Vl4re8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl4re8_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl4re8_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl8re8_v(['\n                                Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl8re8_vMicro::Vl8re8_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl8re8_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl8re8_v::Vl8re8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl8re8_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl8re8_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VlmOp::vlm_v((['\n                        Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                    '], {'inst_flags': 'SimdUnitStrideMaskLoadOp'}))


Vlm_v::Vlm_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vlm_v", _machInst, SimdUnitStrideMaskLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    int32_t micro_vl = (this->vl + 7) / 8;
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
    } else {
        microop = new Vle8_vMicro(_machInst, micro_vl, 0, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
    }
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VleOp::vle8ff_v((['\n                        if ((machInst.vm || elem_mask(v0, ei)) &&\n                            i < this->microVl && i < this->faultIdx) {\n                            Vd_ub[i] = Mem_vc.as<uint8_t>()[i];\n                        }\n                    '], {'inst_flags': 'SimdUnitStrideFaultOnlyFirstLoadOp'}))


Vle8ff_vMicro::Vle8ff_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _vlen)
  : VleMicroInst(
        "vle8ff_v_micro", _machInst, SimdUnitStrideFaultOnlyFirstLoadOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vle8ff_v::Vle8ff_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vle8ff_v", _machInst, SimdUnitStrideFaultOnlyFirstLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vle8ff_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    if (_opClass == SimdUnitStrideFaultOnlyFirstLoadOp) {
        microop = new VlFFTrimVlMicroOp(_machInst, this->vl, num_microops,
                                        vlen, microops);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VlIndexOp::vluxei8_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_ub[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Vluxei8_vMicro<ElemType>::Vluxei8_vMicro(
    ExtMachInst _machInst,uint32_t _vdRegIdx, uint32_t _vdElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VlIndexMicroInst("vluxei8_v_micro", _machInst, SimdIndexedLoadOp,
      _vdRegIdx, _vdElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _vdRegIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _vs2RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}


    template class Vluxei8_vMicro<uint8_t>;
    template class Vluxei8_vMicro<uint16_t>;
    template class Vluxei8_vMicro<uint32_t>;
    template class Vluxei8_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vluxei8_v<ElemType>::Vluxei8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlIndexMacroInst("vluxei8_v", _machInst, SimdIndexedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const uint32_t vd_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vd_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vd_split_num = (vs2_eewb + vd_eewb - 1) / vd_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint32_t vd_vlmax = vlenb / vd_eewb;
    const uint8_t num_pinvdcpyvs_microops = ceil((float) this->vl/vd_vlmax);
    for (uint32_t i = 0; i < num_pinvdcpyvs_microops; i++) {
        uint32_t vdNumElems = (vl >= vd_vlmax*(i+1)) ? vd_vlmax:vl-vd_vlmax*i;

        microop = new VCpyVsMicroInst(machInst, i, machInst.vs2);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vdRegIdx = i / vd_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vdElemIdx = j + micro_vlmax * (i % vd_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vluxei8_vMicro<ElemType>(machInst,
                vdRegIdx, vdElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vluxei8_v<uint8_t>;
    template class Vluxei8_v<uint16_t>;
    template class Vluxei8_v<uint32_t>;
    template class Vluxei8_v<uint64_t>;
    ;


// VlStrideOp::vlse8_v((['\n                    Vd_ub[microIdx] = Mem_vc.as<uint8_t>()[0];\n                '], {'inst_flags': 'SimdStridedLoadOp'}))


Vlse8_vMicro::Vlse8_vMicro(
    ExtMachInst _machInst, uint32_t _regIdx, uint32_t _microIdx,
    uint32_t _microVl)
  : VlStrideMicroInst("vlse8_v_micro", _machInst, SimdStridedLoadOp,
        _regIdx, _microIdx, _microVl)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _regIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs2]);
    // vtmp0 as dummy src reg to create dependency with pin vd micro
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}



Vlse8_v::Vlse8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlStrideMacroInst("vlse8_v", _machInst, SimdStridedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t num_elems_per_vreg = vlen / width_EEW(_machInst.width);
    int32_t remaining_vl = this->vl;
    // Num of elems in one vreg
    int32_t micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint8_t num_pinvd_microops = ceil((float) this->vl /
                                                    num_elems_per_vreg);
    for (uint32_t i = 0; i < num_pinvd_microops; i++) {
        uint32_t vdNumElems = (vl >= num_elems_per_vreg*(i+1))
                              ? num_elems_per_vreg : vl-num_elems_per_vreg*i;
        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (int i = 0; micro_vl > 0; ++i) {
        for (int j = 0; j < micro_vl; ++j) {
            microop = new Vlse8_vMicro(machInst, i, j, micro_vl);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= num_elems_per_vreg;
        micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


// VlIndexOp::vloxei8_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_ub[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Vloxei8_vMicro<ElemType>::Vloxei8_vMicro(
    ExtMachInst _machInst,uint32_t _vdRegIdx, uint32_t _vdElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VlIndexMicroInst("vloxei8_v_micro", _machInst, SimdIndexedLoadOp,
      _vdRegIdx, _vdElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _vdRegIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _vs2RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}


    template class Vloxei8_vMicro<uint8_t>;
    template class Vloxei8_vMicro<uint16_t>;
    template class Vloxei8_vMicro<uint32_t>;
    template class Vloxei8_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vloxei8_v<ElemType>::Vloxei8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlIndexMacroInst("vloxei8_v", _machInst, SimdIndexedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const uint32_t vd_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vd_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vd_split_num = (vs2_eewb + vd_eewb - 1) / vd_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint32_t vd_vlmax = vlenb / vd_eewb;
    const uint8_t num_pinvdcpyvs_microops = ceil((float) this->vl/vd_vlmax);
    for (uint32_t i = 0; i < num_pinvdcpyvs_microops; i++) {
        uint32_t vdNumElems = (vl >= vd_vlmax*(i+1)) ? vd_vlmax:vl-vd_vlmax*i;

        microop = new VCpyVsMicroInst(machInst, i, machInst.vs2);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vdRegIdx = i / vd_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vdElemIdx = j + micro_vlmax * (i % vd_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vloxei8_vMicro<ElemType>(machInst,
                vdRegIdx, vdElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vloxei8_v<uint8_t>;
    template class Vloxei8_v<uint16_t>;
    template class Vloxei8_v<uint32_t>;
    template class Vloxei8_v<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VleOp::vle16_v((['\n                            if ((machInst.vm || elem_mask(v0, ei)) &&\n                                i < this->microVl) {\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            }\n                        '], {'inst_flags': 'SimdUnitStrideLoadOp'}))


Vle16_vMicro::Vle16_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _vlen)
  : VleMicroInst(
        "vle16_v_micro", _machInst, SimdUnitStrideLoadOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vle16_v::Vle16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vle16_v", _machInst, SimdUnitStrideLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vle16_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    if (_opClass == SimdUnitStrideFaultOnlyFirstLoadOp) {
        microop = new VlFFTrimVlMicroOp(_machInst, this->vl, num_microops,
                                        vlen, microops);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlSegOp::vlseg2e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg2e16_vMicro::Vlseg2e16_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg2e16_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg2e16_v::Vlseg2e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg2e16_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg2e16_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg3e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg3e16_vMicro::Vlseg3e16_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg3e16_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg3e16_v::Vlseg3e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg3e16_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg3e16_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg4e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg4e16_vMicro::Vlseg4e16_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg4e16_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg4e16_v::Vlseg4e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg4e16_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg4e16_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg5e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg5e16_vMicro::Vlseg5e16_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg5e16_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg5e16_v::Vlseg5e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg5e16_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg5e16_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg6e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg6e16_vMicro::Vlseg6e16_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg6e16_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg6e16_v::Vlseg6e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg6e16_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg6e16_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg7e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg7e16_vMicro::Vlseg7e16_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg7e16_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg7e16_v::Vlseg7e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg7e16_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg7e16_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg8e16_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&\n                                    i < this->microVl) {\n                                    Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg8e16_vMicro::Vlseg8e16_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg8e16_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg8e16_v::Vlseg8e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg8e16_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg8e16_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// Unknown::unknown(([], {}))

// VlWholeOp::vl1re16_v(['\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl1re16_vMicro::Vl1re16_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl1re16_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl1re16_v::Vl1re16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl1re16_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl1re16_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl2re16_v(['\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl2re16_vMicro::Vl2re16_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl2re16_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl2re16_v::Vl2re16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl2re16_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl2re16_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl4re16_v(['\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl4re16_vMicro::Vl4re16_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl4re16_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl4re16_v::Vl4re16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl4re16_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl4re16_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl8re16_v(['\n                                Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl8re16_vMicro::Vl8re16_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl8re16_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl8re16_v::Vl8re16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl8re16_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl8re16_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VleOp::vle16ff_v((['\n                        if ((machInst.vm || elem_mask(v0, ei)) &&\n                            i < this->microVl && i < this->faultIdx) {\n                            Vd_uh[i] = Mem_vc.as<uint16_t>()[i];\n                        }\n                    '], {'inst_flags': 'SimdUnitStrideFaultOnlyFirstLoadOp'}))


Vle16ff_vMicro::Vle16ff_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _vlen)
  : VleMicroInst(
        "vle16ff_v_micro", _machInst, SimdUnitStrideFaultOnlyFirstLoadOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vle16ff_v::Vle16ff_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vle16ff_v", _machInst, SimdUnitStrideFaultOnlyFirstLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vle16ff_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    if (_opClass == SimdUnitStrideFaultOnlyFirstLoadOp) {
        microop = new VlFFTrimVlMicroOp(_machInst, this->vl, num_microops,
                                        vlen, microops);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VlIndexOp::vluxei16_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_uh[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Vluxei16_vMicro<ElemType>::Vluxei16_vMicro(
    ExtMachInst _machInst,uint32_t _vdRegIdx, uint32_t _vdElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VlIndexMicroInst("vluxei16_v_micro", _machInst, SimdIndexedLoadOp,
      _vdRegIdx, _vdElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _vdRegIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _vs2RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}


    template class Vluxei16_vMicro<uint8_t>;
    template class Vluxei16_vMicro<uint16_t>;
    template class Vluxei16_vMicro<uint32_t>;
    template class Vluxei16_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vluxei16_v<ElemType>::Vluxei16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlIndexMacroInst("vluxei16_v", _machInst, SimdIndexedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const uint32_t vd_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vd_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vd_split_num = (vs2_eewb + vd_eewb - 1) / vd_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint32_t vd_vlmax = vlenb / vd_eewb;
    const uint8_t num_pinvdcpyvs_microops = ceil((float) this->vl/vd_vlmax);
    for (uint32_t i = 0; i < num_pinvdcpyvs_microops; i++) {
        uint32_t vdNumElems = (vl >= vd_vlmax*(i+1)) ? vd_vlmax:vl-vd_vlmax*i;

        microop = new VCpyVsMicroInst(machInst, i, machInst.vs2);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vdRegIdx = i / vd_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vdElemIdx = j + micro_vlmax * (i % vd_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vluxei16_vMicro<ElemType>(machInst,
                vdRegIdx, vdElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vluxei16_v<uint8_t>;
    template class Vluxei16_v<uint16_t>;
    template class Vluxei16_v<uint32_t>;
    template class Vluxei16_v<uint64_t>;
    ;


// VlStrideOp::vlse16_v((['\n                    Vd_uh[microIdx] = Mem_vc.as<uint16_t>()[0];\n                '], {'inst_flags': 'SimdStridedLoadOp'}))


Vlse16_vMicro::Vlse16_vMicro(
    ExtMachInst _machInst, uint32_t _regIdx, uint32_t _microIdx,
    uint32_t _microVl)
  : VlStrideMicroInst("vlse16_v_micro", _machInst, SimdStridedLoadOp,
        _regIdx, _microIdx, _microVl)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _regIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs2]);
    // vtmp0 as dummy src reg to create dependency with pin vd micro
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}



Vlse16_v::Vlse16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlStrideMacroInst("vlse16_v", _machInst, SimdStridedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t num_elems_per_vreg = vlen / width_EEW(_machInst.width);
    int32_t remaining_vl = this->vl;
    // Num of elems in one vreg
    int32_t micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint8_t num_pinvd_microops = ceil((float) this->vl /
                                                    num_elems_per_vreg);
    for (uint32_t i = 0; i < num_pinvd_microops; i++) {
        uint32_t vdNumElems = (vl >= num_elems_per_vreg*(i+1))
                              ? num_elems_per_vreg : vl-num_elems_per_vreg*i;
        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (int i = 0; micro_vl > 0; ++i) {
        for (int j = 0; j < micro_vl; ++j) {
            microop = new Vlse16_vMicro(machInst, i, j, micro_vl);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= num_elems_per_vreg;
        micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


// VlIndexOp::vloxei16_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_uh[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Vloxei16_vMicro<ElemType>::Vloxei16_vMicro(
    ExtMachInst _machInst,uint32_t _vdRegIdx, uint32_t _vdElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VlIndexMicroInst("vloxei16_v_micro", _machInst, SimdIndexedLoadOp,
      _vdRegIdx, _vdElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _vdRegIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _vs2RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}


    template class Vloxei16_vMicro<uint8_t>;
    template class Vloxei16_vMicro<uint16_t>;
    template class Vloxei16_vMicro<uint32_t>;
    template class Vloxei16_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vloxei16_v<ElemType>::Vloxei16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlIndexMacroInst("vloxei16_v", _machInst, SimdIndexedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const uint32_t vd_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vd_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vd_split_num = (vs2_eewb + vd_eewb - 1) / vd_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint32_t vd_vlmax = vlenb / vd_eewb;
    const uint8_t num_pinvdcpyvs_microops = ceil((float) this->vl/vd_vlmax);
    for (uint32_t i = 0; i < num_pinvdcpyvs_microops; i++) {
        uint32_t vdNumElems = (vl >= vd_vlmax*(i+1)) ? vd_vlmax:vl-vd_vlmax*i;

        microop = new VCpyVsMicroInst(machInst, i, machInst.vs2);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vdRegIdx = i / vd_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vdElemIdx = j + micro_vlmax * (i % vd_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vloxei16_vMicro<ElemType>(machInst,
                vdRegIdx, vdElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vloxei16_v<uint8_t>;
    template class Vloxei16_v<uint16_t>;
    template class Vloxei16_v<uint32_t>;
    template class Vloxei16_v<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VleOp::vle32_v((['\n                            if ((machInst.vm || elem_mask(v0, ei)) &&\n                                i < this->microVl) {\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            }\n                        '], {'inst_flags': 'SimdUnitStrideLoadOp'}))


Vle32_vMicro::Vle32_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _vlen)
  : VleMicroInst(
        "vle32_v_micro", _machInst, SimdUnitStrideLoadOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vle32_v::Vle32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vle32_v", _machInst, SimdUnitStrideLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vle32_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    if (_opClass == SimdUnitStrideFaultOnlyFirstLoadOp) {
        microop = new VlFFTrimVlMicroOp(_machInst, this->vl, num_microops,
                                        vlen, microops);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlSegOp::vlseg2e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg2e32_vMicro::Vlseg2e32_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg2e32_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg2e32_v::Vlseg2e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg2e32_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg2e32_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg3e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg3e32_vMicro::Vlseg3e32_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg3e32_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg3e32_v::Vlseg3e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg3e32_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg3e32_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg4e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg4e32_vMicro::Vlseg4e32_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg4e32_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg4e32_v::Vlseg4e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg4e32_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg4e32_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg5e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg5e32_vMicro::Vlseg5e32_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg5e32_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg5e32_v::Vlseg5e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg5e32_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg5e32_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg6e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg6e32_vMicro::Vlseg6e32_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg6e32_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg6e32_v::Vlseg6e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg6e32_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg6e32_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg7e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg7e32_vMicro::Vlseg7e32_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg7e32_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg7e32_v::Vlseg7e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg7e32_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg7e32_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg8e32_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&\n                                    i < this->microVl) {\n                                    Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg8e32_vMicro::Vlseg8e32_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg8e32_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg8e32_v::Vlseg8e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg8e32_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg8e32_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// Unknown::unknown(([], {}))

// VlWholeOp::vl1re32_v(['\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl1re32_vMicro::Vl1re32_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl1re32_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl1re32_v::Vl1re32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl1re32_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl1re32_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl2re32_v(['\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl2re32_vMicro::Vl2re32_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl2re32_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl2re32_v::Vl2re32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl2re32_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl2re32_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl4re32_v(['\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl4re32_vMicro::Vl4re32_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl4re32_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl4re32_v::Vl4re32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl4re32_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl4re32_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl8re32_v(['\n                                Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl8re32_vMicro::Vl8re32_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl8re32_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl8re32_v::Vl8re32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl8re32_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl8re32_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VleOp::vle32ff_v((['\n                        if ((machInst.vm || elem_mask(v0, ei)) &&\n                            i < this->microVl && i < this->faultIdx) {\n                            Vd_uw[i] = Mem_vc.as<uint32_t>()[i];\n                        }\n                    '], {'inst_flags': 'SimdUnitStrideFaultOnlyFirstLoadOp'}))


Vle32ff_vMicro::Vle32ff_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _vlen)
  : VleMicroInst(
        "vle32ff_v_micro", _machInst, SimdUnitStrideFaultOnlyFirstLoadOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vle32ff_v::Vle32ff_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vle32ff_v", _machInst, SimdUnitStrideFaultOnlyFirstLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vle32ff_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    if (_opClass == SimdUnitStrideFaultOnlyFirstLoadOp) {
        microop = new VlFFTrimVlMicroOp(_machInst, this->vl, num_microops,
                                        vlen, microops);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VlIndexOp::vluxei32_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_uw[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Vluxei32_vMicro<ElemType>::Vluxei32_vMicro(
    ExtMachInst _machInst,uint32_t _vdRegIdx, uint32_t _vdElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VlIndexMicroInst("vluxei32_v_micro", _machInst, SimdIndexedLoadOp,
      _vdRegIdx, _vdElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _vdRegIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _vs2RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}


    template class Vluxei32_vMicro<uint8_t>;
    template class Vluxei32_vMicro<uint16_t>;
    template class Vluxei32_vMicro<uint32_t>;
    template class Vluxei32_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vluxei32_v<ElemType>::Vluxei32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlIndexMacroInst("vluxei32_v", _machInst, SimdIndexedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const uint32_t vd_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vd_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vd_split_num = (vs2_eewb + vd_eewb - 1) / vd_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint32_t vd_vlmax = vlenb / vd_eewb;
    const uint8_t num_pinvdcpyvs_microops = ceil((float) this->vl/vd_vlmax);
    for (uint32_t i = 0; i < num_pinvdcpyvs_microops; i++) {
        uint32_t vdNumElems = (vl >= vd_vlmax*(i+1)) ? vd_vlmax:vl-vd_vlmax*i;

        microop = new VCpyVsMicroInst(machInst, i, machInst.vs2);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vdRegIdx = i / vd_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vdElemIdx = j + micro_vlmax * (i % vd_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vluxei32_vMicro<ElemType>(machInst,
                vdRegIdx, vdElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vluxei32_v<uint8_t>;
    template class Vluxei32_v<uint16_t>;
    template class Vluxei32_v<uint32_t>;
    template class Vluxei32_v<uint64_t>;
    ;


// VlStrideOp::vlse32_v((['\n                    Vd_uw[microIdx] = Mem_vc.as<uint32_t>()[0];\n                '], {'inst_flags': 'SimdStridedLoadOp'}))


Vlse32_vMicro::Vlse32_vMicro(
    ExtMachInst _machInst, uint32_t _regIdx, uint32_t _microIdx,
    uint32_t _microVl)
  : VlStrideMicroInst("vlse32_v_micro", _machInst, SimdStridedLoadOp,
        _regIdx, _microIdx, _microVl)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _regIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs2]);
    // vtmp0 as dummy src reg to create dependency with pin vd micro
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}



Vlse32_v::Vlse32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlStrideMacroInst("vlse32_v", _machInst, SimdStridedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t num_elems_per_vreg = vlen / width_EEW(_machInst.width);
    int32_t remaining_vl = this->vl;
    // Num of elems in one vreg
    int32_t micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint8_t num_pinvd_microops = ceil((float) this->vl /
                                                    num_elems_per_vreg);
    for (uint32_t i = 0; i < num_pinvd_microops; i++) {
        uint32_t vdNumElems = (vl >= num_elems_per_vreg*(i+1))
                              ? num_elems_per_vreg : vl-num_elems_per_vreg*i;
        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (int i = 0; micro_vl > 0; ++i) {
        for (int j = 0; j < micro_vl; ++j) {
            microop = new Vlse32_vMicro(machInst, i, j, micro_vl);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= num_elems_per_vreg;
        micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


// VlIndexOp::vloxei32_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_uw[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Vloxei32_vMicro<ElemType>::Vloxei32_vMicro(
    ExtMachInst _machInst,uint32_t _vdRegIdx, uint32_t _vdElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VlIndexMicroInst("vloxei32_v_micro", _machInst, SimdIndexedLoadOp,
      _vdRegIdx, _vdElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _vdRegIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _vs2RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}


    template class Vloxei32_vMicro<uint8_t>;
    template class Vloxei32_vMicro<uint16_t>;
    template class Vloxei32_vMicro<uint32_t>;
    template class Vloxei32_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vloxei32_v<ElemType>::Vloxei32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlIndexMacroInst("vloxei32_v", _machInst, SimdIndexedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const uint32_t vd_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vd_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vd_split_num = (vs2_eewb + vd_eewb - 1) / vd_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint32_t vd_vlmax = vlenb / vd_eewb;
    const uint8_t num_pinvdcpyvs_microops = ceil((float) this->vl/vd_vlmax);
    for (uint32_t i = 0; i < num_pinvdcpyvs_microops; i++) {
        uint32_t vdNumElems = (vl >= vd_vlmax*(i+1)) ? vd_vlmax:vl-vd_vlmax*i;

        microop = new VCpyVsMicroInst(machInst, i, machInst.vs2);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vdRegIdx = i / vd_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vdElemIdx = j + micro_vlmax * (i % vd_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vloxei32_vMicro<ElemType>(machInst,
                vdRegIdx, vdElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vloxei32_v<uint8_t>;
    template class Vloxei32_v<uint16_t>;
    template class Vloxei32_v<uint32_t>;
    template class Vloxei32_v<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VleOp::vle64_v((['\n                            if ((machInst.vm || elem_mask(v0, ei)) &&\n                                i < this->microVl) {\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            }\n                        '], {'inst_flags': 'SimdUnitStrideLoadOp'}))


Vle64_vMicro::Vle64_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _vlen)
  : VleMicroInst(
        "vle64_v_micro", _machInst, SimdUnitStrideLoadOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vle64_v::Vle64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vle64_v", _machInst, SimdUnitStrideLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vle64_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    if (_opClass == SimdUnitStrideFaultOnlyFirstLoadOp) {
        microop = new VlFFTrimVlMicroOp(_machInst, this->vl, num_microops,
                                        vlen, microops);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlSegOp::vlseg2e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 2)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg2e64_vMicro::Vlseg2e64_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg2e64_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg2e64_v::Vlseg2e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg2e64_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg2e64_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg3e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 3)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg3e64_vMicro::Vlseg3e64_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg3e64_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg3e64_v::Vlseg3e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg3e64_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg3e64_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg4e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 4)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg4e64_vMicro::Vlseg4e64_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg4e64_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg4e64_v::Vlseg4e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg4e64_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg4e64_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg5e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 5)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg5e64_vMicro::Vlseg5e64_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg5e64_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg5e64_v::Vlseg5e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg5e64_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg5e64_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg6e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 6)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg6e64_vMicro::Vlseg6e64_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg6e64_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg6e64_v::Vlseg6e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg6e64_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg6e64_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg7e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 7)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg7e64_vMicro::Vlseg7e64_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg7e64_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg7e64_v::Vlseg7e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg7e64_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg7e64_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VlSegOp::vlseg8e64_v(['\n                                if ((machInst.vm || elem_mask_vseg(v0, ei + (field * micro_elems), 8)) &&\n                                    i < this->microVl) {\n                                    Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                                }\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedLoadOp'})


    Vlseg8e64_vMicro::Vlseg8e64_vMicro(ExtMachInst _machInst, uint32_t _microVl, uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field, uint32_t _numFields, uint32_t _vlen)
    : VlSegMicroInst("vlseg8e64_v_micro", _machInst, SimdUnitStrideSegmentedLoadOp, _microVl, _microIdx , _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
        (field * numMicroops)]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx
                                                + (field * numMicroops)]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vlseg8e64_v::Vlseg8e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlSegMacroInst("vlseg8e64_v", _machInst, SimdUnitStrideSegmentedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vlseg8e64_vMicro(_machInst, micro_vl, i, num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsLoad);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VlSegDeIntrlvMicroInst(_machInst, micro_vl, _machInst.vd + i + (f * num_microops),
                    NFIELDS, i, num_microops, f, vlen, size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// Unknown::unknown(([], {}))

// VlWholeOp::vl1re64_v(['\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl1re64_vMicro::Vl1re64_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl1re64_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl1re64_v::Vl1re64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl1re64_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl1re64_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl2re64_v(['\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl2re64_vMicro::Vl2re64_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl2re64_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl2re64_v::Vl2re64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl2re64_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl2re64_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl4re64_v(['\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl4re64_vMicro::Vl4re64_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl4re64_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl4re64_v::Vl4re64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl4re64_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl4re64_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VlWholeOp::vl8re64_v(['\n                                Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                            '],{'inst_flags': 'SimdWholeRegisterLoadOp'})


Vl8re64_vMicro::Vl8re64_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VlWholeMicroInst("vl8re64_v_micro_micro", _machInst, SimdWholeRegisterLoadOp, _microVl,
      _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    this->flags[IsVector] = true;
    this->flags[IsLoad] = true;
}



Vl8re64_v::Vl8re64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlWholeMacroInst("vl8re64_v", _machInst, SimdWholeRegisterLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vl8re64_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VleOp::vle64ff_v((['\n                        if ((machInst.vm || elem_mask(v0, ei)) &&\n                            i < this->microVl && i < this->faultIdx) {\n                            Vd_ud[i] = Mem_vc.as<uint64_t>()[i];\n                        }\n                    '], {'inst_flags': 'SimdUnitStrideFaultOnlyFirstLoadOp'}))


Vle64ff_vMicro::Vle64ff_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _vlen)
  : VleMicroInst(
        "vle64ff_v_micro", _machInst, SimdUnitStrideFaultOnlyFirstLoadOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma)) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
    }
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
}



Vle64ff_v::Vle64ff_v(ExtMachInst _machInst, uint32_t _vlen)
    : VleMacroInst("vle64ff_v", _machInst, SimdUnitStrideFaultOnlyFirstLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vle64ff_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsLoad);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    if (_opClass == SimdUnitStrideFaultOnlyFirstLoadOp) {
        microop = new VlFFTrimVlMicroOp(_machInst, this->vl, num_microops,
                                        vlen, microops);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VlIndexOp::vluxei64_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_ud[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Vluxei64_vMicro<ElemType>::Vluxei64_vMicro(
    ExtMachInst _machInst,uint32_t _vdRegIdx, uint32_t _vdElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VlIndexMicroInst("vluxei64_v_micro", _machInst, SimdIndexedLoadOp,
      _vdRegIdx, _vdElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _vdRegIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _vs2RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}


    template class Vluxei64_vMicro<uint8_t>;
    template class Vluxei64_vMicro<uint16_t>;
    template class Vluxei64_vMicro<uint32_t>;
    template class Vluxei64_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vluxei64_v<ElemType>::Vluxei64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlIndexMacroInst("vluxei64_v", _machInst, SimdIndexedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const uint32_t vd_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vd_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vd_split_num = (vs2_eewb + vd_eewb - 1) / vd_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint32_t vd_vlmax = vlenb / vd_eewb;
    const uint8_t num_pinvdcpyvs_microops = ceil((float) this->vl/vd_vlmax);
    for (uint32_t i = 0; i < num_pinvdcpyvs_microops; i++) {
        uint32_t vdNumElems = (vl >= vd_vlmax*(i+1)) ? vd_vlmax:vl-vd_vlmax*i;

        microop = new VCpyVsMicroInst(machInst, i, machInst.vs2);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vdRegIdx = i / vd_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vdElemIdx = j + micro_vlmax * (i % vd_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vluxei64_vMicro<ElemType>(machInst,
                vdRegIdx, vdElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vluxei64_v<uint8_t>;
    template class Vluxei64_v<uint16_t>;
    template class Vluxei64_v<uint32_t>;
    template class Vluxei64_v<uint64_t>;
    ;


// VlStrideOp::vlse64_v((['\n                    Vd_ud[microIdx] = Mem_vc.as<uint64_t>()[0];\n                '], {'inst_flags': 'SimdStridedLoadOp'}))


Vlse64_vMicro::Vlse64_vMicro(
    ExtMachInst _machInst, uint32_t _regIdx, uint32_t _microIdx,
    uint32_t _microVl)
  : VlStrideMicroInst("vlse64_v_micro", _machInst, SimdStridedLoadOp,
        _regIdx, _microIdx, _microVl)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _regIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs2]);
    // vtmp0 as dummy src reg to create dependency with pin vd micro
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}



Vlse64_v::Vlse64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlStrideMacroInst("vlse64_v", _machInst, SimdStridedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const int32_t num_elems_per_vreg = vlen / width_EEW(_machInst.width);
    int32_t remaining_vl = this->vl;
    // Num of elems in one vreg
    int32_t micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint8_t num_pinvd_microops = ceil((float) this->vl /
                                                    num_elems_per_vreg);
    for (uint32_t i = 0; i < num_pinvd_microops; i++) {
        uint32_t vdNumElems = (vl >= num_elems_per_vreg*(i+1))
                              ? num_elems_per_vreg : vl-num_elems_per_vreg*i;
        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (int i = 0; micro_vl > 0; ++i) {
        for (int j = 0; j < micro_vl; ++j) {
            microop = new Vlse64_vMicro(machInst, i, j, micro_vl);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= num_elems_per_vreg;
        micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


// VlIndexOp::vloxei64_v((['\n                    Vd_vu[vdElemIdx] = Mem_vc.as<vu>()[0];\n                ', '\n                    EA = Rs1 + Vs2_ud[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedLoadOp'}))


template<typename ElemType>
Vloxei64_vMicro<ElemType>::Vloxei64_vMicro(
    ExtMachInst _machInst,uint32_t _vdRegIdx, uint32_t _vdElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VlIndexMicroInst("vloxei64_v_micro", _machInst, SimdIndexedLoadOp,
      _vdRegIdx, _vdElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _vdRegIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _vs2RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsLoad] = true;
}


    template class Vloxei64_vMicro<uint8_t>;
    template class Vloxei64_vMicro<uint16_t>;
    template class Vloxei64_vMicro<uint32_t>;
    template class Vloxei64_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vloxei64_v<ElemType>::Vloxei64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VlIndexMacroInst("vloxei64_v", _machInst, SimdIndexedLoadOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsVector] = true;;

    const uint32_t vd_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vd_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vd_split_num = (vs2_eewb + vd_eewb - 1) / vd_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    const uint32_t vd_vlmax = vlenb / vd_eewb;
    const uint8_t num_pinvdcpyvs_microops = ceil((float) this->vl/vd_vlmax);
    for (uint32_t i = 0; i < num_pinvdcpyvs_microops; i++) {
        uint32_t vdNumElems = (vl >= vd_vlmax*(i+1)) ? vd_vlmax:vl-vd_vlmax*i;

        microop = new VCpyVsMicroInst(machInst, i, machInst.vs2);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        microop = new VPinVdMicroInst(machInst, i, vdNumElems);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vdRegIdx = i / vd_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vdElemIdx = j + micro_vlmax * (i % vd_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vloxei64_vMicro<ElemType>(machInst,
                vdRegIdx, vdElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsLoad);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vloxei64_v<uint8_t>;
    template class Vloxei64_v<uint16_t>;
    template class Vloxei64_v<uint32_t>;
    template class Vloxei64_v<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FenceOp::fence(['\n                ', 'uint64_t', 'IsReadBarrier', 'IsWriteBarrier', 'No_OpClass'],{})

    Fence::Fence(ExtMachInst machInst)
        : ImmOp<uint64_t>("fence", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        imm = sext<12>(IMM12);;
    }

// FenceOp::fence_i(['\n                ', 'uint64_t', 'IsNonSpeculative', 'IsSerializeAfter', 'IsSquashAfter', 'No_OpClass'],{})

    Fence_i::Fence_i(ExtMachInst machInst)
        : ImmOp<uint64_t>("fence_i", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        imm = sext<12>(IMM12);;
    }

// CBMOp::cbo_inval(['\n                        Mem = 0;\n                    '],{'mem_flags': ['INVALIDATE', 'DST_POC']})

    Cbo_inval::Cbo_inval(ExtMachInst machInst):
        Store("cbo_inval", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = Request::INVALIDATE|Request::DST_POC|MMU::DoubleWordAlign;;
        ;;
    }

// CBMOp::cbo_clean(['\n                        Mem = 0;\n                    '],{'mem_flags': ['CLEAN', 'DST_POC']})

    Cbo_clean::Cbo_clean(ExtMachInst machInst):
        Store("cbo_clean", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = Request::CLEAN|Request::DST_POC|MMU::DoubleWordAlign;;
        ;;
    }

// CBMOp::cbo_flush(['\n                        Mem = 0;\n                    '],{'mem_flags': ['CLEAN', 'INVALIDATE', 'DST_POC']})

    Cbo_flush::Cbo_flush(ExtMachInst machInst):
        Store("cbo_flush", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = Request::CLEAN|Request::INVALIDATE|Request::DST_POC|MMU::DoubleWordAlign;;
        ;;
    }

// CBMOp::cbo_zero(['\n                        Mem = 0;\n                    '],{'mem_flags': ['CACHE_BLOCK_ZERO']})

    Cbo_zero::Cbo_zero(ExtMachInst machInst):
        Store("cbo_zero", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = Request::CACHE_BLOCK_ZERO|MMU::DoubleWordAlign;;
        ;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::slli(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        Rd = rvSext(Rs1 << imm);\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Slli::Slli(ExtMachInst machInst)
        : ImmOp<uint64_t>("slli", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// IOp::zip(['\n                            Rd_sw = _rvk_emu_zip_32(Rs1_sw);\n                        '],{'imm_code': ' imm = SHAMT5; '})

    Zip::Zip(ExtMachInst machInst)
        : ImmOp<int64_t>("zip", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT5; ;
    }

// Unknown::unknown(([], {}))

// IOp::sha256sum0(['\n                            Rd_sw = _rvk_emu_sha256sum0(Rs1_sw);\n                        '],{})

    Sha256sum0::Sha256sum0(ExtMachInst machInst)
        : ImmOp<int64_t>("sha256sum0", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::sha256sum1(['\n                            Rd_sw = _rvk_emu_sha256sum1(Rs1_sw);\n                        '],{})

    Sha256sum1::Sha256sum1(ExtMachInst machInst)
        : ImmOp<int64_t>("sha256sum1", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::sha256sig0(['\n                            Rd_sw = _rvk_emu_sha256sig0(Rs1_sw);\n                        '],{})

    Sha256sig0::Sha256sig0(ExtMachInst machInst)
        : ImmOp<int64_t>("sha256sig0", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::sha256sig1(['\n                            Rd_sw = _rvk_emu_sha256sig1(Rs1_sw);\n                        '],{})

    Sha256sig1::Sha256sig1(ExtMachInst machInst)
        : ImmOp<int64_t>("sha256sig1", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::sha512sum0(['\n                                Rd_sd = _rvk_emu_sha512sum0(Rs1_sd);\n                            '],{})

    Sha512sum0::Sha512sum0(ExtMachInst machInst)
        : ImmOp<int64_t>("sha512sum0", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// IOp::sha512sum1(['\n                                Rd_sd = _rvk_emu_sha512sum1(Rs1_sd);\n                            '],{})

    Sha512sum1::Sha512sum1(ExtMachInst machInst)
        : ImmOp<int64_t>("sha512sum1", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// IOp::sha512sig0(['\n                                Rd_sd = _rvk_emu_sha512sig0(Rs1_sd);\n                            '],{})

    Sha512sig0::Sha512sig0(ExtMachInst machInst)
        : ImmOp<int64_t>("sha512sig0", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// IOp::sha512sig1(['\n                                Rd_sd = _rvk_emu_sha512sig1(Rs1_sd);\n                            '],{})

    Sha512sig1::Sha512sig1(ExtMachInst machInst)
        : ImmOp<int64_t>("sha512sig1", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// IOp::sm3p0(['\n                            Rd_sw = _rvk_emu_sm3p0(Rs1_sw);\n                        '],{})

    Sm3p0::Sm3p0(ExtMachInst machInst)
        : ImmOp<int64_t>("sm3p0", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::sm3p1(['\n                            Rd_sw = _rvk_emu_sm3p1(Rs1_sw);\n                        '],{})

    Sm3p1::Sm3p1(ExtMachInst machInst)
        : ImmOp<int64_t>("sm3p1", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// IOp::bseti(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 | (UINT64_C(1) << index));\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Bseti::Bseti(ExtMachInst machInst)
        : ImmOp<uint64_t>("bseti", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// IOp::aes64im(['\n                                Rd_sd = _rvk_emu_aes64im(Rs1_sd);\n                            '],{})

    Aes64im::Aes64im(ExtMachInst machInst)
        : ImmOp<int64_t>("aes64im", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// IOp::aes64ks1i(['\n                                Rd_sd = _rvk_emu_aes64ks1i(Rs1_sd, imm);\n                            '],{'imm_type': 'int32_t', 'imm_code': ' imm = RNUM; '})

    Aes64ks1i::Aes64ks1i(ExtMachInst machInst)
        : ImmOp<int32_t>("aes64ks1i", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = RNUM; ;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::bclri(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 & (~(UINT64_C(1) << index)));\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Bclri::Bclri(ExtMachInst machInst)
        : ImmOp<uint64_t>("bclri", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// IOp::binvi(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 ^ (UINT64_C(1) << index));\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Binvi::Binvi(ExtMachInst machInst)
        : ImmOp<uint64_t>("binvi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// ROp::clz(['\n                            Rd = (machInst.rv_type == RV32) ? clz32(Rs1) : clz64(Rs1);\n                        '],{})

    Clz::Clz(ExtMachInst machInst)
        : RegOp("clz", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
    }

// ROp::ctz(['\n                            Rd = (machInst.rv_type == RV32) ? ctz32(Rs1) : ctz64(Rs1);\n                        '],{})

    Ctz::Ctz(ExtMachInst machInst)
        : RegOp("ctz", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
    }

// ROp::cpop(['\n                            Rd = (machInst.rv_type == RV32) ? popCount(Rs1<31:0>) : popCount(Rs1);\n                        '],{})

    Cpop::Cpop(ExtMachInst machInst)
        : RegOp("cpop", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
    }

// ROp::sext_b(['\n                            Rd = sext<8>(Rs1_ub);\n                        '],{})

    Sext_b::Sext_b(ExtMachInst machInst)
        : RegOp("sext_b", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
    }

// ROp::sext_h(['\n                            Rd = sext<16>(Rs1_uh);\n                        '],{})

    Sext_h::Sext_h(ExtMachInst machInst)
        : RegOp("sext_h", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::addi(['\n                    Rd_sd = rvSext(Rs1_sd + imm);\n                '],{})

    Addi::Addi(ExtMachInst machInst)
        : ImmOp<int64_t>("addi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::slti(['\n                    Rd = (rvSext(Rs1_sd) < imm) ? 1 : 0;\n                '],{})

    Slti::Slti(ExtMachInst machInst)
        : ImmOp<int64_t>("slti", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::sltiu(['\n                    Rd = (rvZext(Rs1) < imm) ? 1 : 0;\n                ', 'uint64_t'],{'imm_code': ' imm = rvZext(sext<12>(IMM12)); '})

    Sltiu::Sltiu(ExtMachInst machInst)
        : ImmOp<uint64_t>("sltiu", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = rvZext(sext<12>(IMM12)); ;
    }

// IOp::xori(['\n                    Rd = rvSext(Rs1 ^ imm);\n                ', 'uint64_t'],{})

    Xori::Xori(ExtMachInst machInst)
        : ImmOp<uint64_t>("xori", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::srli(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        Rd = rvSext(rvZext(Rs1) >> imm);\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Srli::Srli(ExtMachInst machInst)
        : ImmOp<uint64_t>("srli", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// IOp::unzip(['\n                            Rd_sw = _rvk_emu_unzip_32(Rs1_sw);\n                        '],{'imm_code': ' imm = SHAMT5; '})

    Unzip::Unzip(ExtMachInst machInst)
        : ImmOp<int64_t>("unzip", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT5; ;
    }

// Unknown::unknown(([], {}))

// IOp::orc_b(['\n                        uint64_t result = 0;\n                        result |= (Rs1<7:0> ? UINT64_C(0xff) : 0x0);\n                        result |= (Rs1<15:8> ? UINT64_C(0xff) : 0x0) << 8;\n                        result |= (Rs1<23:16> ? UINT64_C(0xff) : 0x0) << 16;\n                        result |= (Rs1<31:24> ? UINT64_C(0xff) : 0x0) << 24;\n                        result |= (Rs1<39:32> ? UINT64_C(0xff) : 0x0) << 32;\n                        result |= (Rs1<47:40> ? UINT64_C(0xff) : 0x0) << 40;\n                        result |= (Rs1<55:48> ? UINT64_C(0xff) : 0x0) << 48;\n                        result |= (Rs1<63:56> ? UINT64_C(0xff) : 0x0) << 56;\n                        Rd = rvSext(result);\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Orc_b::Orc_b(ExtMachInst machInst)
        : ImmOp<uint64_t>("orc_b", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// IOp::srai(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        Rd_sd = rvSext(Rs1_sd) >> imm;\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Srai::Srai(ExtMachInst machInst)
        : ImmOp<uint64_t>("srai", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// IOp::bexti(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t index = imm & rvSelect(32 - 1, 64 - 1);\n                        Rd = (Rs1 >> index) & 0x1;\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Bexti::Bexti(ExtMachInst machInst)
        : ImmOp<uint64_t>("bexti", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// IOp::rori(['\n                        if (rvSelect((bool)SHAMT6BIT5, false)) {\n                            return std::make_shared<IllegalInstFault>(\n                                    "shmat[5] != 0", machInst);\n                        }\n                        uint64_t xlen = rvSelect(32, 64);\n                        Rd = rvSext((rvZext(Rs1) >> imm)\n                            | (Rs1 << ((xlen - imm) & (xlen - 1))));\n                    '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Rori::Rori(ExtMachInst machInst)
        : ImmOp<uint64_t>("rori", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// ROp::rev8((['\n                            if (rvSelect((bool)SHAMT6BIT5, false)) {\n                                return std::make_shared<IllegalInstFault>(\n                                        "shmat[5] != 0", machInst);\n                            }\n                            if (machInst.rv_type == RV32) {\n                                Rd_sd = _rvk_emu_grev_32(Rs1_sd, 0x18);\n                            } else {\n                                Rd_sd = _rvk_emu_grev_64(Rs1_sd, 0x38);\n                            }\n                        '], {}))

    Rev8::Rev8(ExtMachInst machInst)
        : RegOp("rev8", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
    }

// ROp::brev8((['\n                            if (machInst.rv_type == RV32) {\n                                Rd_sd = _rvk_emu_brev8_32(Rs1_sd);\n                            } else {\n                                Rd_sd = _rvk_emu_brev8_64(Rs1_sd);\n                            }\n                        '], {}))

    Brev8::Brev8(ExtMachInst machInst)
        : RegOp("brev8", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::ori(['\n                    Rd = rvSext(Rs1 | imm);\n                ', 'uint64_t'],{})

    Ori::Ori(ExtMachInst machInst)
        : ImmOp<uint64_t>("ori", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::andi(['\n                    Rd = rvSext(Rs1 & imm);\n                ', 'uint64_t'],{})

    Andi::Andi(ExtMachInst machInst)
        : ImmOp<uint64_t>("andi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// UOp::auipc((['\n            Rd = rvSext(PC + (sext<20>(imm) << 12));\n        '], {}))

    Auipc::Auipc(ExtMachInst machInst)
        : ImmOp<int64_t>("auipc", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        imm = IMM20;;
    }

// IOp::addiw(['\n                        Rd_sw = (int32_t)(Rs1_sw + imm);\n                    ', 'int32_t'],{})

    Addiw::Addiw(ExtMachInst machInst)
        : ImmOp<int32_t>("addiw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::slliw(['\n                            Rd_sd = Rs1_sw << imm;\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT5; '})

    Slliw::Slliw(ExtMachInst machInst)
        : ImmOp<uint64_t>("slliw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT5; ;
    }

// IOp::slli_uw(['\n                            Rd = ((uint64_t)(Rs1_uw)) << imm;\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT6; '})

    Slli_uw::Slli_uw(ExtMachInst machInst)
        : ImmOp<uint64_t>("slli_uw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT6; ;
    }

// IOp::clzw(['\n                                Rd = clz32(Rs1);\n                            '],{})

    Clzw::Clzw(ExtMachInst machInst)
        : ImmOp<int64_t>("clzw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::ctzw(['\n                                Rd = ctz32(Rs1);\n                            '],{})

    Ctzw::Ctzw(ExtMachInst machInst)
        : ImmOp<int64_t>("ctzw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// IOp::cpopw(['\n                                Rd = popCount(Rs1<31:0>);\n                            '],{})

    Cpopw::Cpopw(ExtMachInst machInst)
        : ImmOp<int64_t>("cpopw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
        imm = sext<12>(IMM12);;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// IOp::srliw(['\n                            Rd_sd = (int32_t)(Rs1_uw >> imm);\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT5; '})

    Srliw::Srliw(ExtMachInst machInst)
        : ImmOp<uint64_t>("srliw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT5; ;
    }

// IOp::sraiw(['\n                            Rd_sd = Rs1_sw >> imm;\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT5; '})

    Sraiw::Sraiw(ExtMachInst machInst)
        : ImmOp<uint64_t>("sraiw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT5; ;
    }

// IOp::roriw(['\n                            Rd = (int32_t) ((Rs1_uw >> imm) | (Rs1_uw << ((32 - imm) & (32 - 1))));\n                        '],{'imm_type': 'uint64_t', 'imm_code': ' imm = SHAMT5; '})

    Roriw::Roriw(ExtMachInst machInst)
        : ImmOp<uint64_t>("roriw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;;
         imm = SHAMT5; ;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Store::sb(['\n                    Mem_ub = Rs2_ub;\n                '],{})

    Sb::Sb(ExtMachInst machInst):
        Store("sb", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::ByteAlign;;
        offset = sext<12>(IMM5 | (IMM7 << 5));;
    }

// Store::sh(['\n                    Mem_uh = Rs2_uh;\n                '],{})

    Sh::Sh(ExtMachInst machInst):
        Store("sh", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::HalfWordAlign;;
        offset = sext<12>(IMM5 | (IMM7 << 5));;
    }

// Store::sw(['\n                    Mem_uw = Rs2_uw;\n                '],{})

    Sw::Sw(ExtMachInst machInst):
        Store("sw", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::WordAlign;;
        offset = sext<12>(IMM5 | (IMM7 << 5));;
    }

// Store::sd(['\n                        Mem_ud = Rs2_ud;\n                    '],{})

    Sd::Sd(ExtMachInst machInst):
        Store("sd", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        offset = sext<12>(IMM5 | (IMM7 << 5));;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Store::fsh(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                "FPU is off", machInst);\n\n                    Mem_uh = unboxF16(boxF16(Fs2_bits));\n                '],{'inst_flags': 'FloatMemWriteOp'})

    Fsh::Fsh(ExtMachInst machInst):
        Store("fsh", machInst, FloatMemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::HalfWordAlign;;
        offset = sext<12>(IMM5 | (IMM7 << 5));;
    }

// Store::fsw(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                "FPU is off", machInst);\n\n                    Mem_uw = unboxF32(boxF32(Fs2_bits));\n                '],{'inst_flags': 'FloatMemWriteOp'})

    Fsw::Fsw(ExtMachInst machInst):
        Store("fsw", machInst, FloatMemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::WordAlign;;
        offset = sext<12>(IMM5 | (IMM7 << 5));;
    }

// Store::fsd(['\n                    STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                    if (status.fs == FPUStatus::OFF)\n                        return std::make_shared<IllegalInstFault>(\n                                "FPU is off", machInst);\n\n                    Mem_ud = Fs2_bits;\n                '],{'inst_flags': 'FloatMemWriteOp'})

    Fsd::Fsd(ExtMachInst machInst):
        Store("fsd", machInst, FloatMemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;
	memAccessFlags = MMU::DoubleWordAlign;;
        offset = sext<12>(IMM5 | (IMM7 << 5));;
    }

// VseOp::vse8_v((['\n                            Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                        '], {'inst_flags': 'SimdUnitStrideStoreOp'}))


Vse8_vMicro::Vse8_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VseMicroInst(
        "vse8_v_micro", _machInst, SimdUnitStrideStoreOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _microIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vse8_v::Vse8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VseMacroInst("vse8_v", _machInst, SimdUnitStrideStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vse8_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
}


// VsSegOp::vsseg2e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg2e8_vMicro::Vsseg2e8_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg2e8_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg2e8_v::Vsseg2e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg2e8_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg2e8_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg3e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg3e8_vMicro::Vsseg3e8_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg3e8_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg3e8_v::Vsseg3e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg3e8_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg3e8_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg4e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg4e8_vMicro::Vsseg4e8_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg4e8_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg4e8_v::Vsseg4e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg4e8_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg4e8_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg5e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg5e8_vMicro::Vsseg5e8_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg5e8_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg5e8_v::Vsseg5e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg5e8_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg5e8_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg6e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg6e8_vMicro::Vsseg6e8_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg6e8_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg6e8_v::Vsseg6e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg6e8_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg6e8_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg7e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg7e8_vMicro::Vsseg7e8_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg7e8_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg7e8_v::Vsseg7e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg7e8_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg7e8_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg8e8_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg8e8_vMicro::Vsseg8e8_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg8e8_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg8e8_v::Vsseg8e8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg8e8_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg8e8_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// Unknown::unknown(([], {}))

// VsWholeOp::vs1r_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdWholeRegisterStoreOp'})


Vs1r_vMicro::Vs1r_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VsWholeMicroInst(
        "vs1r_v_micro", _machInst, SimdWholeRegisterStoreOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _microIdx]);
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vs1r_v::Vs1r_v(ExtMachInst _machInst, uint32_t _vlen)
  : VsWholeMacroInst("vs1r_v", _machInst, SimdWholeRegisterStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;
    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vs1r_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VsWholeOp::vs2r_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdWholeRegisterStoreOp'})


Vs2r_vMicro::Vs2r_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VsWholeMicroInst(
        "vs2r_v_micro", _machInst, SimdWholeRegisterStoreOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _microIdx]);
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vs2r_v::Vs2r_v(ExtMachInst _machInst, uint32_t _vlen)
  : VsWholeMacroInst("vs2r_v", _machInst, SimdWholeRegisterStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;
    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vs2r_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VsWholeOp::vs4r_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdWholeRegisterStoreOp'})


Vs4r_vMicro::Vs4r_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VsWholeMicroInst(
        "vs4r_v_micro", _machInst, SimdWholeRegisterStoreOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _microIdx]);
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vs4r_v::Vs4r_v(ExtMachInst _machInst, uint32_t _vlen)
  : VsWholeMacroInst("vs4r_v", _machInst, SimdWholeRegisterStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;
    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vs4r_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// VsWholeOp::vs8r_v(['\n                                Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                            '],{'inst_flags': 'SimdWholeRegisterStoreOp'})


Vs8r_vMicro::Vs8r_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VsWholeMicroInst(
        "vs8r_v_micro", _machInst, SimdWholeRegisterStoreOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _microIdx]);
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vs8r_v::Vs8r_v(ExtMachInst _machInst, uint32_t _vlen)
  : VsWholeMacroInst("vs8r_v", _machInst, SimdWholeRegisterStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    size_t NFIELDS = machInst.nf + 1;
    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);

    StaticInstPtr microop;
    for (int i = 0; i < NFIELDS; ++i) {
        microop = new Vs8r_vMicro(_machInst, micro_vlmax, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VsmOp::vsm_v((['\n                        Mem_vc.as<uint8_t>()[i] = Vs3_ub[i];\n                    '], {'inst_flags': 'SimdUnitStrideMaskStoreOp'}))


Vsm_v::Vsm_v(ExtMachInst _machInst, uint32_t _vlen)
    : VseMacroInst("vsm_v", _machInst, SimdUnitStrideMaskStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    int32_t micro_vl = (this->vl + 7) / 8;

    StaticInstPtr microop;
    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
    } else {
        microop = new Vse8_vMicro(_machInst, micro_vl, 0, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
    }
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}


// Unknown::unknown(([], {}))

// VsIndexOp::vsuxei8_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_ub[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Vsuxei8_vMicro<ElemType>::Vsuxei8_vMicro(ExtMachInst _machInst,
    uint32_t _vs3RegIdx, uint32_t _vs3ElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VsIndexMicroInst("vsuxei8_v_micro", _machInst, SimdIndexedStoreOp,
      _vs3RegIdx, _vs3ElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _vs2RegIdx]);
    // We treat agnostic as undistrubed
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _vs3RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}


    template class Vsuxei8_vMicro<uint8_t>;
    template class Vsuxei8_vMicro<uint16_t>;
    template class Vsuxei8_vMicro<uint32_t>;
    template class Vsuxei8_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vsuxei8_v<ElemType>::Vsuxei8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsIndexMacroInst("vsuxei8_v", _machInst, SimdIndexedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const uint32_t vs3_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vs3_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vs3_split_num = (vs2_eewb + vs3_eewb - 1) / vs3_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vs3_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vs3RegIdx = i / vs3_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vs3ElemIdx = j + micro_vlmax * (i % vs3_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vsuxei8_vMicro<ElemType>(machInst,
                vs3RegIdx, vs3ElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vsuxei8_v<uint8_t>;
    template class Vsuxei8_v<uint16_t>;
    template class Vsuxei8_v<uint32_t>;
    template class Vsuxei8_v<uint64_t>;
    ;


// VsStrideOp::vsse8_v((['\n                    Mem_vc.as<uint8_t>()[0] = Vs3_ub[microIdx];\n                '], {'inst_flags': 'SimdStridedStoreOp'}))


Vsse8_vMicro::Vsse8_vMicro(
    ExtMachInst _machInst, uint32_t _regIdx, uint32_t _microIdx,
    uint32_t _microVl)
  : VsStrideMicroInst("vsse8_v_micro""_micro", _machInst, SimdStridedStoreOp,
      _regIdx, _microIdx, _microVl)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs2]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _regIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}



Vsse8_v::Vsse8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsStrideMacroInst("vsse8_v", _machInst, SimdStridedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t num_elems_per_vreg = vlen / width_EEW(_machInst.width);
    int32_t remaining_vl = this->vl;
    // Num of elems in one vreg
    int32_t micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; micro_vl > 0; ++i) {
        for (int j = 0; j < micro_vl; ++j) {
            microop = new Vsse8_vMicro(machInst, i, j, micro_vl);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= num_elems_per_vreg;
        micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


// VsIndexOp::vsoxei8_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_ub[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Vsoxei8_vMicro<ElemType>::Vsoxei8_vMicro(ExtMachInst _machInst,
    uint32_t _vs3RegIdx, uint32_t _vs3ElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VsIndexMicroInst("vsoxei8_v_micro", _machInst, SimdIndexedStoreOp,
      _vs3RegIdx, _vs3ElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _vs2RegIdx]);
    // We treat agnostic as undistrubed
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _vs3RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}


    template class Vsoxei8_vMicro<uint8_t>;
    template class Vsoxei8_vMicro<uint16_t>;
    template class Vsoxei8_vMicro<uint32_t>;
    template class Vsoxei8_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vsoxei8_v<ElemType>::Vsoxei8_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsIndexMacroInst("vsoxei8_v", _machInst, SimdIndexedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const uint32_t vs3_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vs3_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vs3_split_num = (vs2_eewb + vs3_eewb - 1) / vs3_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vs3_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vs3RegIdx = i / vs3_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vs3ElemIdx = j + micro_vlmax * (i % vs3_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vsoxei8_vMicro<ElemType>(machInst,
                vs3RegIdx, vs3ElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vsoxei8_v<uint8_t>;
    template class Vsoxei8_v<uint16_t>;
    template class Vsoxei8_v<uint32_t>;
    template class Vsoxei8_v<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VseOp::vse16_v((['\n                            Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                        '], {'inst_flags': 'SimdUnitStrideStoreOp'}))


Vse16_vMicro::Vse16_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VseMicroInst(
        "vse16_v_micro", _machInst, SimdUnitStrideStoreOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _microIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vse16_v::Vse16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VseMacroInst("vse16_v", _machInst, SimdUnitStrideStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vse16_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
}


// VsSegOp::vsseg2e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg2e16_vMicro::Vsseg2e16_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg2e16_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg2e16_v::Vsseg2e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg2e16_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg2e16_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg3e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg3e16_vMicro::Vsseg3e16_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg3e16_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg3e16_v::Vsseg3e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg3e16_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg3e16_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg4e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg4e16_vMicro::Vsseg4e16_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg4e16_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg4e16_v::Vsseg4e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg4e16_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg4e16_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg5e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg5e16_vMicro::Vsseg5e16_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg5e16_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg5e16_v::Vsseg5e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg5e16_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg5e16_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg6e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg6e16_vMicro::Vsseg6e16_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg6e16_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg6e16_v::Vsseg6e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg6e16_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg6e16_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg7e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg7e16_vMicro::Vsseg7e16_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg7e16_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg7e16_v::Vsseg7e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg7e16_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg7e16_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg8e16_v(['\n                                Mem_vc.as<uint16_t>()[i] = Vs3_uh[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg8e16_vMicro::Vsseg8e16_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg8e16_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg8e16_v::Vsseg8e16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg8e16_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg8e16_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VsIndexOp::vsuxei16_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_uh[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Vsuxei16_vMicro<ElemType>::Vsuxei16_vMicro(ExtMachInst _machInst,
    uint32_t _vs3RegIdx, uint32_t _vs3ElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VsIndexMicroInst("vsuxei16_v_micro", _machInst, SimdIndexedStoreOp,
      _vs3RegIdx, _vs3ElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _vs2RegIdx]);
    // We treat agnostic as undistrubed
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _vs3RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}


    template class Vsuxei16_vMicro<uint8_t>;
    template class Vsuxei16_vMicro<uint16_t>;
    template class Vsuxei16_vMicro<uint32_t>;
    template class Vsuxei16_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vsuxei16_v<ElemType>::Vsuxei16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsIndexMacroInst("vsuxei16_v", _machInst, SimdIndexedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const uint32_t vs3_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vs3_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vs3_split_num = (vs2_eewb + vs3_eewb - 1) / vs3_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vs3_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vs3RegIdx = i / vs3_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vs3ElemIdx = j + micro_vlmax * (i % vs3_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vsuxei16_vMicro<ElemType>(machInst,
                vs3RegIdx, vs3ElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vsuxei16_v<uint8_t>;
    template class Vsuxei16_v<uint16_t>;
    template class Vsuxei16_v<uint32_t>;
    template class Vsuxei16_v<uint64_t>;
    ;


// VsStrideOp::vsse16_v((['\n                    Mem_vc.as<uint16_t>()[0] = Vs3_uh[microIdx];\n                '], {'inst_flags': 'SimdStridedStoreOp'}))


Vsse16_vMicro::Vsse16_vMicro(
    ExtMachInst _machInst, uint32_t _regIdx, uint32_t _microIdx,
    uint32_t _microVl)
  : VsStrideMicroInst("vsse16_v_micro""_micro", _machInst, SimdStridedStoreOp,
      _regIdx, _microIdx, _microVl)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs2]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _regIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}



Vsse16_v::Vsse16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsStrideMacroInst("vsse16_v", _machInst, SimdStridedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t num_elems_per_vreg = vlen / width_EEW(_machInst.width);
    int32_t remaining_vl = this->vl;
    // Num of elems in one vreg
    int32_t micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; micro_vl > 0; ++i) {
        for (int j = 0; j < micro_vl; ++j) {
            microop = new Vsse16_vMicro(machInst, i, j, micro_vl);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= num_elems_per_vreg;
        micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


// VsIndexOp::vsoxei16_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_uh[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Vsoxei16_vMicro<ElemType>::Vsoxei16_vMicro(ExtMachInst _machInst,
    uint32_t _vs3RegIdx, uint32_t _vs3ElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VsIndexMicroInst("vsoxei16_v_micro", _machInst, SimdIndexedStoreOp,
      _vs3RegIdx, _vs3ElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _vs2RegIdx]);
    // We treat agnostic as undistrubed
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _vs3RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}


    template class Vsoxei16_vMicro<uint8_t>;
    template class Vsoxei16_vMicro<uint16_t>;
    template class Vsoxei16_vMicro<uint32_t>;
    template class Vsoxei16_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vsoxei16_v<ElemType>::Vsoxei16_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsIndexMacroInst("vsoxei16_v", _machInst, SimdIndexedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const uint32_t vs3_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vs3_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vs3_split_num = (vs2_eewb + vs3_eewb - 1) / vs3_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vs3_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vs3RegIdx = i / vs3_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vs3ElemIdx = j + micro_vlmax * (i % vs3_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vsoxei16_vMicro<ElemType>(machInst,
                vs3RegIdx, vs3ElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vsoxei16_v<uint8_t>;
    template class Vsoxei16_v<uint16_t>;
    template class Vsoxei16_v<uint32_t>;
    template class Vsoxei16_v<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VseOp::vse32_v((['\n                            Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                        '], {'inst_flags': 'SimdUnitStrideStoreOp'}))


Vse32_vMicro::Vse32_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VseMicroInst(
        "vse32_v_micro", _machInst, SimdUnitStrideStoreOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _microIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vse32_v::Vse32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VseMacroInst("vse32_v", _machInst, SimdUnitStrideStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vse32_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
}


// VsSegOp::vsseg2e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg2e32_vMicro::Vsseg2e32_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg2e32_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg2e32_v::Vsseg2e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg2e32_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg2e32_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg3e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg3e32_vMicro::Vsseg3e32_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg3e32_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg3e32_v::Vsseg3e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg3e32_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg3e32_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg4e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg4e32_vMicro::Vsseg4e32_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg4e32_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg4e32_v::Vsseg4e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg4e32_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg4e32_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg5e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg5e32_vMicro::Vsseg5e32_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg5e32_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg5e32_v::Vsseg5e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg5e32_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg5e32_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg6e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg6e32_vMicro::Vsseg6e32_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg6e32_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg6e32_v::Vsseg6e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg6e32_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg6e32_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg7e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg7e32_vMicro::Vsseg7e32_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg7e32_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg7e32_v::Vsseg7e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg7e32_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg7e32_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg8e32_v(['\n                                Mem_vc.as<uint32_t>()[i] = Vs3_uw[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg8e32_vMicro::Vsseg8e32_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg8e32_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg8e32_v::Vsseg8e32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg8e32_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg8e32_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VsIndexOp::vsuxei32_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_uw[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Vsuxei32_vMicro<ElemType>::Vsuxei32_vMicro(ExtMachInst _machInst,
    uint32_t _vs3RegIdx, uint32_t _vs3ElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VsIndexMicroInst("vsuxei32_v_micro", _machInst, SimdIndexedStoreOp,
      _vs3RegIdx, _vs3ElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _vs2RegIdx]);
    // We treat agnostic as undistrubed
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _vs3RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}


    template class Vsuxei32_vMicro<uint8_t>;
    template class Vsuxei32_vMicro<uint16_t>;
    template class Vsuxei32_vMicro<uint32_t>;
    template class Vsuxei32_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vsuxei32_v<ElemType>::Vsuxei32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsIndexMacroInst("vsuxei32_v", _machInst, SimdIndexedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const uint32_t vs3_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vs3_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vs3_split_num = (vs2_eewb + vs3_eewb - 1) / vs3_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vs3_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vs3RegIdx = i / vs3_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vs3ElemIdx = j + micro_vlmax * (i % vs3_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vsuxei32_vMicro<ElemType>(machInst,
                vs3RegIdx, vs3ElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vsuxei32_v<uint8_t>;
    template class Vsuxei32_v<uint16_t>;
    template class Vsuxei32_v<uint32_t>;
    template class Vsuxei32_v<uint64_t>;
    ;


// VsStrideOp::vsse32_v((['\n                    Mem_vc.as<uint32_t>()[0] = Vs3_uw[microIdx];\n                '], {'inst_flags': 'SimdStridedStoreOp'}))


Vsse32_vMicro::Vsse32_vMicro(
    ExtMachInst _machInst, uint32_t _regIdx, uint32_t _microIdx,
    uint32_t _microVl)
  : VsStrideMicroInst("vsse32_v_micro""_micro", _machInst, SimdStridedStoreOp,
      _regIdx, _microIdx, _microVl)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs2]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _regIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}



Vsse32_v::Vsse32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsStrideMacroInst("vsse32_v", _machInst, SimdStridedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t num_elems_per_vreg = vlen / width_EEW(_machInst.width);
    int32_t remaining_vl = this->vl;
    // Num of elems in one vreg
    int32_t micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; micro_vl > 0; ++i) {
        for (int j = 0; j < micro_vl; ++j) {
            microop = new Vsse32_vMicro(machInst, i, j, micro_vl);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= num_elems_per_vreg;
        micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


// VsIndexOp::vsoxei32_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_uw[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Vsoxei32_vMicro<ElemType>::Vsoxei32_vMicro(ExtMachInst _machInst,
    uint32_t _vs3RegIdx, uint32_t _vs3ElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VsIndexMicroInst("vsoxei32_v_micro", _machInst, SimdIndexedStoreOp,
      _vs3RegIdx, _vs3ElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _vs2RegIdx]);
    // We treat agnostic as undistrubed
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _vs3RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}


    template class Vsoxei32_vMicro<uint8_t>;
    template class Vsoxei32_vMicro<uint16_t>;
    template class Vsoxei32_vMicro<uint32_t>;
    template class Vsoxei32_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vsoxei32_v<ElemType>::Vsoxei32_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsIndexMacroInst("vsoxei32_v", _machInst, SimdIndexedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const uint32_t vs3_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vs3_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vs3_split_num = (vs2_eewb + vs3_eewb - 1) / vs3_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vs3_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vs3RegIdx = i / vs3_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vs3ElemIdx = j + micro_vlmax * (i % vs3_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vsoxei32_vMicro<ElemType>(machInst,
                vs3RegIdx, vs3ElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vsoxei32_v<uint8_t>;
    template class Vsoxei32_v<uint16_t>;
    template class Vsoxei32_v<uint32_t>;
    template class Vsoxei32_v<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// VseOp::vse64_v((['\n                            Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                        '], {'inst_flags': 'SimdUnitStrideStoreOp'}))


Vse64_vMicro::Vse64_vMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, uint32_t _vlen)
  : VseMicroInst(
        "vse64_v_micro", _machInst, SimdUnitStrideStoreOp, _microVl, _microIdx, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _microIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vse64_v::Vse64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VseMacroInst("vse64_v", _machInst, SimdUnitStrideStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);

    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vse64_vMicro(_machInst, micro_vl, i, vlen);
        microop->setDelayedCommit();
        microop->setFlag(IsStore);
        this->microops.push_back(microop);
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
}


// VsSegOp::vsseg2e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg2e64_vMicro::Vsseg2e64_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg2e64_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg2e64_v::Vsseg2e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg2e64_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg2e64_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg3e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg3e64_vMicro::Vsseg3e64_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg3e64_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg3e64_v::Vsseg3e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg3e64_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg3e64_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg4e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg4e64_vMicro::Vsseg4e64_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg4e64_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg4e64_v::Vsseg4e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg4e64_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg4e64_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg5e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg5e64_vMicro::Vsseg5e64_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg5e64_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg5e64_v::Vsseg5e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg5e64_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg5e64_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg6e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg6e64_vMicro::Vsseg6e64_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg6e64_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg6e64_v::Vsseg6e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg6e64_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg6e64_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg7e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg7e64_vMicro::Vsseg7e64_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg7e64_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg7e64_v::Vsseg7e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg7e64_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg7e64_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// VsSegOp::vsseg8e64_v(['\n                                Mem_vc.as<uint64_t>()[i] = Vs3_ud[i];\n                            '],{'inst_flags': 'SimdUnitStrideSegmentedStoreOp'})


    Vsseg8e64_vMicro::Vsseg8e64_vMicro(ExtMachInst _machInst, uint32_t _microVl,
    uint32_t _microIdx, uint32_t _numMicroops, uint32_t _field,
    uint32_t _numFields, uint32_t _vlen)
    : VsSegMicroInst("vsseg8e64_v_micro", _machInst, SimdUnitStrideSegmentedStoreOp, _microVl,
    _microIdx, _numMicroops, _field, _numFields, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;

    _numSrcRegs = 0;
    _numDestRegs = 0;
    field = _field;
    numFields = _numFields;
    numMicroops = _numMicroops;

    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + _microIdx +
            (field * numMicroops)]);

    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsVector] = true;
    this->flags[IsStore] = true;
}



Vsseg8e64_v::Vsseg8e64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsSegMacroInst("vsseg8e64_v", _machInst, SimdUnitStrideSegmentedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t micro_vlmax = vlen / width_EEW(_machInst.width);
    const uint32_t num_microops = ceil((float) this->vl / (micro_vlmax));
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    size_t NFIELDS = machInst.nf + 1;
    StaticInstPtr microop;
    uint32_t size_per_elem = width_EEW(_machInst.width) / 8;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    } else {
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new VsSegIntrlvMicroInst(_machInst, micro_vl,
                    _machInst.vs3, NFIELDS, i, num_microops, f, vlen,
                    size_per_elem);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
        for (int f = 0; f < NFIELDS; ++f) {
            remaining_vl = this->vl;
            micro_vl = std::min(remaining_vl, micro_vlmax);
            for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
                microop = new Vsseg8e64_vMicro(_machInst, micro_vl, i,
                    num_microops, f, NFIELDS, vlen);
                microop->setDelayedCommit();
                microop->setFlag(IsStore);
                this->microops.push_back(microop);
                micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
            }
        }
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VsIndexOp::vsuxei64_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_ud[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Vsuxei64_vMicro<ElemType>::Vsuxei64_vMicro(ExtMachInst _machInst,
    uint32_t _vs3RegIdx, uint32_t _vs3ElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VsIndexMicroInst("vsuxei64_v_micro", _machInst, SimdIndexedStoreOp,
      _vs3RegIdx, _vs3ElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _vs2RegIdx]);
    // We treat agnostic as undistrubed
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _vs3RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}


    template class Vsuxei64_vMicro<uint8_t>;
    template class Vsuxei64_vMicro<uint16_t>;
    template class Vsuxei64_vMicro<uint32_t>;
    template class Vsuxei64_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vsuxei64_v<ElemType>::Vsuxei64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsIndexMacroInst("vsuxei64_v", _machInst, SimdIndexedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const uint32_t vs3_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vs3_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vs3_split_num = (vs2_eewb + vs3_eewb - 1) / vs3_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vs3_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vs3RegIdx = i / vs3_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vs3ElemIdx = j + micro_vlmax * (i % vs3_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vsuxei64_vMicro<ElemType>(machInst,
                vs3RegIdx, vs3ElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vsuxei64_v<uint8_t>;
    template class Vsuxei64_v<uint16_t>;
    template class Vsuxei64_v<uint32_t>;
    template class Vsuxei64_v<uint64_t>;
    ;


// VsStrideOp::vsse64_v((['\n                    Mem_vc.as<uint64_t>()[0] = Vs3_ud[microIdx];\n                '], {'inst_flags': 'SimdStridedStoreOp'}))


Vsse64_vMicro::Vsse64_vMicro(
    ExtMachInst _machInst, uint32_t _regIdx, uint32_t _microIdx,
    uint32_t _microVl)
  : VsStrideMicroInst("vsse64_v_micro""_micro", _machInst, SimdStridedStoreOp,
      _regIdx, _microIdx, _microVl)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs2]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _regIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}



Vsse64_v::Vsse64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsStrideMacroInst("vsse64_v", _machInst, SimdStridedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const int32_t num_elems_per_vreg = vlen / width_EEW(_machInst.width);
    int32_t remaining_vl = this->vl;
    // Num of elems in one vreg
    int32_t micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; micro_vl > 0; ++i) {
        for (int j = 0; j < micro_vl; ++j) {
            microop = new Vsse64_vMicro(machInst, i, j, micro_vl);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= num_elems_per_vreg;
        micro_vl = std::min(remaining_vl, num_elems_per_vreg);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


// VsIndexOp::vsoxei64_v((['\n                    Mem_vc.as<vu>()[0] = Vs3_vu[vs3ElemIdx];\n                ', '\n                    EA = Rs1 + Vs2_ud[vs2ElemIdx];\n                '], {'inst_flags': 'SimdIndexedStoreOp'}))


template<typename ElemType>
Vsoxei64_vMicro<ElemType>::Vsoxei64_vMicro(ExtMachInst _machInst,
    uint32_t _vs3RegIdx, uint32_t _vs3ElemIdx,
    uint32_t _vs2RegIdx, uint32_t _vs2ElemIdx)
  : VsIndexMicroInst("vsoxei64_v_micro", _machInst, SimdIndexedStoreOp,
      _vs3RegIdx, _vs3ElemIdx, _vs2RegIdx, _vs2ElemIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _vs2RegIdx]);
    // We treat agnostic as undistrubed
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs3 + _vs3RegIdx]);
    if (!_machInst.vm) {
        setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);
    }
    this->flags[IsStore] = true;
}


    template class Vsoxei64_vMicro<uint8_t>;
    template class Vsoxei64_vMicro<uint16_t>;
    template class Vsoxei64_vMicro<uint32_t>;
    template class Vsoxei64_vMicro<uint64_t>;
    ;



template<typename ElemType>
Vsoxei64_v<ElemType>::Vsoxei64_v(ExtMachInst _machInst, uint32_t _vlen)
    : VsIndexMacroInst("vsoxei64_v", _machInst, SimdIndexedStoreOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsVector] = true;;

    const uint32_t vs3_eewb = sizeof(ElemType);
    const uint32_t vs2_eewb = width_EEW(_machInst.width) / 8;
    const uint8_t vs2_split_num = (vs3_eewb + vs2_eewb - 1) / vs2_eewb;
    const uint8_t vs3_split_num = (vs2_eewb + vs3_eewb - 1) / vs3_eewb;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vs3_eewb, vs2_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (uint32_t i = 0; micro_vl > 0; i++) {
        for (uint32_t j = 0; j < micro_vl; ++j) {
            uint32_t vs3RegIdx = i / vs3_split_num;
            uint32_t vs2RegIdx = i / vs2_split_num;
            uint32_t vs3ElemIdx = j + micro_vlmax * (i % vs3_split_num);
            uint32_t vs2ElemIdx = j + micro_vlmax * (i % vs2_split_num);
            microop = new Vsoxei64_vMicro<ElemType>(machInst,
                vs3RegIdx, vs3ElemIdx, vs2RegIdx, vs2ElemIdx);
            microop->setFlag(IsDelayedCommit);
            microop->setFlag(IsStore);
            this->microops.push_back(microop);
        }
        remaining_vl -= micro_vlmax;
        micro_vl = std::min(remaining_vl, micro_vlmax);
    }

    this->microops.front()->setFlag(IsFirstMicroop);
    this->microops.back()->setFlag(IsLastMicroop);
    this->flags[IsVector] = true;
}


    template class Vsoxei64_v<uint8_t>;
    template class Vsoxei64_v<uint16_t>;
    template class Vsoxei64_v<uint32_t>;
    template class Vsoxei64_v<uint64_t>;
    ;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// LoadReserved::lr_w((['\n                    Rd_sd = Mem_sw;\n                '], {'mem_flags': 'LLSC'}))

    Lr_w::Lr_w(ExtMachInst machInst):
        LoadReserved("lr_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr lrsc;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        lrsc = new Lr_wMicro(machInst, this);

        if (!RL) {
            lrsc->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            lrsc->setFlag(IsLastMicroop);
        } else {
            lrsc->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, lrsc, acq_fence};
        } else if (RL) {
            microops = {rel_fence, lrsc};
        } else if (AQ) {
            microops = {lrsc, acq_fence};
        } else {
            microops = {lrsc};
        }
    }

    Lr_w::Lr_wMicro::Lr_wMicro(
        ExtMachInst machInst, Lr_w *_p)
            : LoadReservedMicro("lr_w", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::LLSC|MMU::WordAlign;;
    }

// StoreCond::sc_w((['\n                    Mem_uw = Rs2_uw;\n                ', '\n                    Rd = rvSext(result);\n                '], {'inst_flags': 'IsStoreConditional', 'mem_flags': 'LLSC'}))

    Sc_w::Sc_w(ExtMachInst machInst):
        StoreCond("sc_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr lrsc;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        lrsc = new Sc_wMicro(machInst, this);

        if (!RL) {
            lrsc->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            lrsc->setFlag(IsLastMicroop);
        } else {
            lrsc->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, lrsc, acq_fence};
        } else if (RL) {
            microops = {rel_fence, lrsc};
        } else if (AQ) {
            microops = {lrsc, acq_fence};
        } else {
            microops = {lrsc};
        }
    }

    Sc_w::Sc_wMicro::Sc_wMicro(
        ExtMachInst machInst, Sc_w *_p)
            : StoreCondMicro("sc_w", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	memAccessFlags = memAccessFlags | Request::LLSC|MMU::WordAlign;;
    }

// AtomicMemOp::amoadd_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<int32_t> *amo_op =\n                          new AtomicGenericOp<int32_t>(Rs2_sw,\n                                  [](int32_t* b, int32_t a){ *b += a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoadd_w::Amoadd_w(ExtMachInst machInst)
            : AtomicMemOp("amoadd_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoadd_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoadd_w::Amoadd_wRMW::Amoadd_wRMW(
        ExtMachInst machInst, Amoadd_w *_p)
            : AtomicMemOpMicro("amoadd_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amoswap_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                          new AtomicGenericOp<uint32_t>(Rs2_uw,\n                                  [](uint32_t* b, uint32_t a){ *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoswap_w::Amoswap_w(ExtMachInst machInst)
            : AtomicMemOp("amoswap_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoswap_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoswap_w::Amoswap_wRMW::Amoswap_wRMW(
        ExtMachInst machInst, Amoswap_w *_p)
            : AtomicMemOpMicro("amoswap_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amoxor_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                          new AtomicGenericOp<uint32_t>(Rs2_uw,\n                                  [](uint32_t* b, uint32_t a){ *b ^= a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoxor_w::Amoxor_w(ExtMachInst machInst)
            : AtomicMemOp("amoxor_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoxor_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoxor_w::Amoxor_wRMW::Amoxor_wRMW(
        ExtMachInst machInst, Amoxor_w *_p)
            : AtomicMemOpMicro("amoxor_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amoor_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                          new AtomicGenericOp<uint32_t>(Rs2_uw,\n                                  [](uint32_t* b, uint32_t a){ *b |= a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoor_w::Amoor_w(ExtMachInst machInst)
            : AtomicMemOp("amoor_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoor_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoor_w::Amoor_wRMW::Amoor_wRMW(
        ExtMachInst machInst, Amoor_w *_p)
            : AtomicMemOpMicro("amoor_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amoand_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                          new AtomicGenericOp<uint32_t>(Rs2_uw,\n                                  [](uint32_t* b, uint32_t a){ *b &= a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoand_w::Amoand_w(ExtMachInst machInst)
            : AtomicMemOp("amoand_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoand_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoand_w::Amoand_wRMW::Amoand_wRMW(
        ExtMachInst machInst, Amoand_w *_p)
            : AtomicMemOpMicro("amoand_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amomin_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<int32_t> *amo_op =\n                      new AtomicGenericOp<int32_t>(Rs2_sw,\n                        [](int32_t* b, int32_t a){ if (a < *b) *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amomin_w::Amomin_w(ExtMachInst machInst)
            : AtomicMemOp("amomin_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amomin_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amomin_w::Amomin_wRMW::Amomin_wRMW(
        ExtMachInst machInst, Amomin_w *_p)
            : AtomicMemOpMicro("amomin_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amomax_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<int32_t> *amo_op =\n                      new AtomicGenericOp<int32_t>(Rs2_sw,\n                        [](int32_t* b, int32_t a){ if (a > *b) *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amomax_w::Amomax_w(ExtMachInst machInst)
            : AtomicMemOp("amomax_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amomax_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amomax_w::Amomax_wRMW::Amomax_wRMW(
        ExtMachInst machInst, Amomax_w *_p)
            : AtomicMemOpMicro("amomax_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amominu_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                      new AtomicGenericOp<uint32_t>(Rs2_uw,\n                        [](uint32_t* b, uint32_t a){ if (a < *b) *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amominu_w::Amominu_w(ExtMachInst machInst)
            : AtomicMemOp("amominu_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amominu_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amominu_w::Amominu_wRMW::Amominu_wRMW(
        ExtMachInst machInst, Amominu_w *_p)
            : AtomicMemOpMicro("amominu_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amomaxu_w((['\n                    Rd_sd = Mem_sw;\n                ', '\n                    TypedAtomicOpFunctor<uint32_t> *amo_op =\n                      new AtomicGenericOp<uint32_t>(Rs2_uw,\n                        [](uint32_t* b, uint32_t a){ if (a > *b) *b = a; });\n                '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amomaxu_w::Amomaxu_w(ExtMachInst machInst)
            : AtomicMemOp("amomaxu_w", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amomaxu_wRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amomaxu_w::Amomaxu_wRMW::Amomaxu_wRMW(
        ExtMachInst machInst, Amomaxu_w *_p)
            : AtomicMemOpMicro("amomaxu_w[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::WordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// Unknown::unknown(([], {}))

// LoadReserved::lr_d((['\n                        Rd_sd = Mem_sd;\n                    '], {'mem_flags': 'LLSC'}))

    Lr_d::Lr_d(ExtMachInst machInst):
        LoadReserved("lr_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr lrsc;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        lrsc = new Lr_dMicro(machInst, this);

        if (!RL) {
            lrsc->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            lrsc->setFlag(IsLastMicroop);
        } else {
            lrsc->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, lrsc, acq_fence};
        } else if (RL) {
            microops = {rel_fence, lrsc};
        } else if (AQ) {
            microops = {lrsc, acq_fence};
        } else {
            microops = {lrsc};
        }
    }

    Lr_d::Lr_dMicro::Lr_dMicro(
        ExtMachInst machInst, Lr_d *_p)
            : LoadReservedMicro("lr_d", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::LLSC|MMU::DoubleWordAlign;;
    }

// StoreCond::sc_d((['\n                        Mem = Rs2;\n                    ', '\n                        Rd = result;\n                    '], {'mem_flags': 'LLSC', 'inst_flags': 'IsStoreConditional'}))

    Sc_d::Sc_d(ExtMachInst machInst):
        StoreCond("sc_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr lrsc;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        lrsc = new Sc_dMicro(machInst, this);

        if (!RL) {
            lrsc->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            lrsc->setFlag(IsLastMicroop);
        } else {
            lrsc->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, lrsc, acq_fence};
        } else if (RL) {
            microops = {rel_fence, lrsc};
        } else if (AQ) {
            microops = {lrsc, acq_fence};
        } else {
            microops = {lrsc};
        }
    }

    Sc_d::Sc_dMicro::Sc_dMicro(
        ExtMachInst machInst, Sc_d *_p)
            : StoreCondMicro("sc_d", machInst, MemWriteOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	memAccessFlags = memAccessFlags | Request::LLSC|MMU::DoubleWordAlign;;
    }

// AtomicMemOp::amoadd_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<int64_t> *amo_op =\n                              new AtomicGenericOp<int64_t>(Rs2_sd,\n                                      [](int64_t* b, int64_t a){ *b += a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoadd_d::Amoadd_d(ExtMachInst machInst)
            : AtomicMemOp("amoadd_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoadd_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoadd_d::Amoadd_dRMW::Amoadd_dRMW(
        ExtMachInst machInst, Amoadd_d *_p)
            : AtomicMemOpMicro("amoadd_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amoswap_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                              new AtomicGenericOp<uint64_t>(Rs2_ud,\n                                      [](uint64_t* b, uint64_t a){ *b = a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoswap_d::Amoswap_d(ExtMachInst machInst)
            : AtomicMemOp("amoswap_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoswap_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoswap_d::Amoswap_dRMW::Amoswap_dRMW(
        ExtMachInst machInst, Amoswap_d *_p)
            : AtomicMemOpMicro("amoswap_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amoxor_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                              new AtomicGenericOp<uint64_t>(Rs2_ud,\n                                     [](uint64_t* b, uint64_t a){ *b ^= a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoxor_d::Amoxor_d(ExtMachInst machInst)
            : AtomicMemOp("amoxor_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoxor_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoxor_d::Amoxor_dRMW::Amoxor_dRMW(
        ExtMachInst machInst, Amoxor_d *_p)
            : AtomicMemOpMicro("amoxor_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amoor_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                              new AtomicGenericOp<uint64_t>(Rs2_ud,\n                                     [](uint64_t* b, uint64_t a){ *b |= a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoor_d::Amoor_d(ExtMachInst machInst)
            : AtomicMemOp("amoor_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoor_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoor_d::Amoor_dRMW::Amoor_dRMW(
        ExtMachInst machInst, Amoor_d *_p)
            : AtomicMemOpMicro("amoor_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amoand_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                              new AtomicGenericOp<uint64_t>(Rs2_ud,\n                                     [](uint64_t* b, uint64_t a){ *b &= a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amoand_d::Amoand_d(ExtMachInst machInst)
            : AtomicMemOp("amoand_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amoand_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amoand_d::Amoand_dRMW::Amoand_dRMW(
        ExtMachInst machInst, Amoand_d *_p)
            : AtomicMemOpMicro("amoand_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amomin_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<int64_t> *amo_op =\n                          new AtomicGenericOp<int64_t>(Rs2_sd,\n                            [](int64_t* b, int64_t a){ if (a < *b) *b = a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amomin_d::Amomin_d(ExtMachInst machInst)
            : AtomicMemOp("amomin_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amomin_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amomin_d::Amomin_dRMW::Amomin_dRMW(
        ExtMachInst machInst, Amomin_d *_p)
            : AtomicMemOpMicro("amomin_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amomax_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<int64_t> *amo_op =\n                          new AtomicGenericOp<int64_t>(Rs2_sd,\n                            [](int64_t* b, int64_t a){ if (a > *b) *b = a; });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amomax_d::Amomax_d(ExtMachInst machInst)
            : AtomicMemOp("amomax_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amomax_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amomax_d::Amomax_dRMW::Amomax_dRMW(
        ExtMachInst machInst, Amomax_d *_p)
            : AtomicMemOpMicro("amomax_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amominu_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                          new AtomicGenericOp<uint64_t>(Rs2_ud,\n                            [](uint64_t* b, uint64_t a){\n                              if (a < *b) *b = a;\n                            });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amominu_d::Amominu_d(ExtMachInst machInst)
            : AtomicMemOp("amominu_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amominu_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amominu_d::Amominu_dRMW::Amominu_dRMW(
        ExtMachInst machInst, Amominu_d *_p)
            : AtomicMemOpMicro("amominu_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// AtomicMemOp::amomaxu_d((['\n                        Rd_sd = Mem_sd;\n                    ', '\n                        TypedAtomicOpFunctor<uint64_t> *amo_op =\n                          new AtomicGenericOp<uint64_t>(Rs2_ud,\n                            [](uint64_t* b, uint64_t a){\n                              if (a > *b) *b = a;\n                            });\n                    '], {'mem_flags': 'ATOMIC_RETURN_OP'}))

    Amomaxu_d::Amomaxu_d(ExtMachInst machInst)
            : AtomicMemOp("amomaxu_d", machInst, IntAluOp)
    {
        ;

        StaticInstPtr rel_fence;
        StaticInstPtr rmw_op;
        StaticInstPtr acq_fence;

        // set up release fence
        if (RL) {
            rel_fence = new MemFenceMicro(machInst, No_OpClass);
            rel_fence->setFlag(IsFirstMicroop);
            rel_fence->setFlag(IsReadBarrier);
            rel_fence->setFlag(IsWriteBarrier);
            rel_fence->setFlag(IsDelayedCommit);
        }

        // set up atomic rmw op
        rmw_op = new Amomaxu_dRMW(machInst, this);

        if (!RL) {
            rmw_op->setFlag(IsFirstMicroop);
        }

        if (!AQ) {
            rmw_op->setFlag(IsLastMicroop);
        } else {
            rmw_op->setFlag(IsDelayedCommit);
        }

        // set up acquire fence
        if (AQ) {
            acq_fence = new MemFenceMicro(machInst, No_OpClass);
            acq_fence->setFlag(IsLastMicroop);
            acq_fence->setFlag(IsReadBarrier);
            acq_fence->setFlag(IsWriteBarrier);
        }

        if (RL && AQ) {
            microops = {rel_fence, rmw_op, acq_fence};
        } else if (RL) {
            microops = {rel_fence, rmw_op};
        } else if (AQ) {
            microops = {rmw_op, acq_fence};
        } else {
            microops = {rmw_op};
        }
    }

    Amomaxu_d::Amomaxu_dRMW::Amomaxu_dRMW(
        ExtMachInst machInst, Amomaxu_d *_p)
            : AtomicMemOpMicro("amomaxu_d[l]", machInst, MemReadOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	memAccessFlags = memAccessFlags | Request::ATOMIC_RETURN_OP|MMU::DoubleWordAlign;;

        // overwrite default flags
        flags[IsLoad] = false;
        flags[IsStore] = false;
        flags[IsAtomic] = true;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::add(['\n                            Rd = rvSext(Rs1_sd + Rs2_sd);\n                        '],{})

    Add::Add(ExtMachInst machInst)
        : RegOp("add", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::sub(['\n                            Rd = rvSext(Rs1_sd - Rs2_sd);\n                        '],{})

    Sub::Sub(ExtMachInst machInst)
        : RegOp("sub", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::mul(['\n                            Rd = rvSext(Rs1_sd * Rs2_sd);\n                        ', 'IntMultOp'],{})

    Mul::Mul(ExtMachInst machInst)
        : RegOp("mul", machInst, IntMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::sha512sum0r(['\n                                Rd_sw = _rvk_emu_sha512sum0r(Rs1_sw, Rs2_sw);\n                            '],{})

    Sha512sum0r::Sha512sum0r(ExtMachInst machInst)
        : RegOp("sha512sum0r", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sum1r(['\n                                Rd_sw = _rvk_emu_sha512sum1r(Rs1_sw, Rs2_sw);\n                            '],{})

    Sha512sum1r::Sha512sum1r(ExtMachInst machInst)
        : RegOp("sha512sum1r", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sig0l(['\n                                Rd_sw = _rvk_emu_sha512sig0l(Rs1_sw, Rs2_sw);\n                            '],{})

    Sha512sig0l::Sha512sig0l(ExtMachInst machInst)
        : RegOp("sha512sig0l", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sig1l(['\n                                Rd_sw = _rvk_emu_sha512sig1l(Rs1_sw, Rs2_sw);\n                            '],{})

    Sha512sig1l::Sha512sig1l(ExtMachInst machInst)
        : RegOp("sha512sig1l", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sig0h(['\n                                Rd_sw = _rvk_emu_sha512sig0h(Rs1_sw, Rs2_sw);\n                            '],{})

    Sha512sig0h::Sha512sig0h(ExtMachInst machInst)
        : RegOp("sha512sig0h", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sha512sig1h(['\n                                Rd_sw = _rvk_emu_sha512sig1h(Rs1_sw, Rs2_sw);\n                            '],{})

    Sha512sig1h::Sha512sig1h(ExtMachInst machInst)
        : RegOp("sha512sig1h", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BSOp::aes32esi((['\n                            Rd_sw = _rvk_emu_aes32esi(Rs1_sw, Rs2_sw, bs);\n                        '], {}))

    Aes32esi::Aes32esi(ExtMachInst machInst)
        : BSOp("aes32esi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
        bs = (uint8_t)BS;;
    }

// Unknown::unknown(([], {}))

// BSOp::aes32esmi((['\n                            Rd_sw = _rvk_emu_aes32esmi(Rs1_sw, Rs2_sw, bs);\n                        '], {}))

    Aes32esmi::Aes32esmi(ExtMachInst machInst)
        : BSOp("aes32esmi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
        bs = (uint8_t)BS;;
    }

// Unknown::unknown(([], {}))

// BSOp::aes32dsi((['\n                            Rd_sw = _rvk_emu_aes32dsi(Rs1_sw, Rs2_sw, bs);\n                        '], {}))

    Aes32dsi::Aes32dsi(ExtMachInst machInst)
        : BSOp("aes32dsi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
        bs = (uint8_t)BS;;
    }

// Unknown::unknown(([], {}))

// BSOp::aes32dsmi((['\n                            Rd_sw = _rvk_emu_aes32dsmi(Rs1_sw, Rs2_sw, bs);\n                        '], {}))

    Aes32dsmi::Aes32dsmi(ExtMachInst machInst)
        : BSOp("aes32dsmi", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
        bs = (uint8_t)BS;;
    }

// Unknown::unknown(([], {}))

// BSOp::sm4ed((['\n                        Rd_sw = _rvk_emu_sm4ed(Rs1_sw, Rs2_sw, bs);\n                    '], {}))

    Sm4ed::Sm4ed(ExtMachInst machInst)
        : BSOp("sm4ed", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
        bs = (uint8_t)BS;;
    }

// ROp::aes64es(['\n                                Rd_sd = _rvk_emu_aes64es(Rs1_sd, Rs2_sd);\n                            '],{})

    Aes64es::Aes64es(ExtMachInst machInst)
        : RegOp("aes64es", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BSOp::sm4ks((['\n                        Rd_sw = _rvk_emu_sm4ks(Rs1_sw, Rs2_sw, bs);\n                    '], {}))

    Sm4ks::Sm4ks(ExtMachInst machInst)
        : BSOp("sm4ks", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
        bs = (uint8_t)BS;;
    }

// ROp::aes64esm(['\n                                Rd_sd = _rvk_emu_aes64esm(Rs1_sd, Rs2_sd);\n                            '],{})

    Aes64esm::Aes64esm(ExtMachInst machInst)
        : RegOp("aes64esm", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::aes64ds(['\n                                Rd_sd = _rvk_emu_aes64ds(Rs1_sd, Rs2_sd);\n                            '],{})

    Aes64ds::Aes64ds(ExtMachInst machInst)
        : RegOp("aes64ds", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::aes64dsm(['\n                                Rd_sd = _rvk_emu_aes64dsm(Rs1_sd, Rs2_sd);\n                            '],{})

    Aes64dsm::Aes64dsm(ExtMachInst machInst)
        : RegOp("aes64dsm", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::aes64ks2(['\n                                Rd_sd = _rvk_emu_aes64ks2(Rs1_sd, Rs2_sd);\n                            '],{})

    Aes64ks2::Aes64ks2(ExtMachInst machInst)
        : RegOp("aes64ks2", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ROp::sll(['\n                        Rd = rvSext(Rs1 << rvSelect(Rs2<4:0>, Rs2<5:0>));\n                    '],{})

    Sll::Sll(ExtMachInst machInst)
        : RegOp("sll", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::mulh(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = mulh<int32_t>(Rs1_sd, Rs2_sd);\n                        } else {\n                            Rd_sd = mulh<int64_t>(Rs1_sd, Rs2_sd);\n                        }\n                    ', 'IntMultOp'],{})

    Mulh::Mulh(ExtMachInst machInst)
        : RegOp("mulh", machInst, IntMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::clmul(['\n                        uint64_t result = 0;\n                        for (int i = 0; i < rvSelect(32, 64); i++) {\n                            if ((Rs2 >> i) & 1) {\n                                result ^= Rs1 << i;\n                            }\n                        }\n                        Rd = rvSext(result);\n                    '],{})

    Clmul::Clmul(ExtMachInst machInst)
        : RegOp("clmul", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::bset(['\n                        Rs2 &= rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 | (UINT64_C(1) << Rs2));\n                    '],{})

    Bset::Bset(ExtMachInst machInst)
        : RegOp("bset", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::bclr(['\n                        Rs2 &= rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 & (~(UINT64_C(1) << Rs2)));\n                    '],{})

    Bclr::Bclr(ExtMachInst machInst)
        : RegOp("bclr", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::rol(['\n                        uint64_t xlen = rvSelect(32, 64);\n                        int shamt = Rs2 & (xlen - 1);\n                        Rd = rvSext((Rs1 << shamt)\n                            | (rvZext(Rs1) >> ((xlen - shamt) & (xlen - 1))));\n                    '],{})

    Rol::Rol(ExtMachInst machInst)
        : RegOp("rol", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::binv(['\n                        Rs2 &= rvSelect(32 - 1, 64 - 1);\n                        Rd = rvSext(Rs1 ^ (UINT64_C(1) << Rs2));\n                    '],{})

    Binv::Binv(ExtMachInst machInst)
        : RegOp("binv", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::slt(['\n                        Rd = (rvSext(Rs1_sd) < rvSext(Rs2_sd)) ? 1 : 0;\n                    '],{})

    Slt::Slt(ExtMachInst machInst)
        : RegOp("slt", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::mulhsu(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = mulhsu<int32_t>(Rs1_sd, Rs2);\n                        } else {\n                            Rd_sd = mulhsu<int64_t>(Rs1_sd, Rs2);\n                        }\n                    ', 'IntMultOp'],{})

    Mulhsu::Mulhsu(ExtMachInst machInst)
        : RegOp("mulhsu", machInst, IntMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::clmulr(['\n                        uint64_t result = 0;\n                        uint64_t xlen = rvSelect(32, 64);\n                        uint64_t zextRs1 = rvZext(Rs1);\n                        for (int i = 0; i < xlen; i++) {\n                            if ((Rs2 >> i) & 1) {\n                                result ^= zextRs1 >> (xlen-i-1);\n                            }\n                        }\n                        Rd = rvSext(result);\n                    '],{})

    Clmulr::Clmulr(ExtMachInst machInst)
        : RegOp("clmulr", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::sh1add(['\n                        Rd = rvSext((Rs1 << 1) + Rs2);\n                    '],{})

    Sh1add::Sh1add(ExtMachInst machInst)
        : RegOp("sh1add", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::xperm4(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = _rvk_emu_xperm4_32(Rs1_sd, Rs2_sd);\n                        } else {\n                            Rd_sd = _rvk_emu_xperm4_64(Rs1_sd, Rs2_sd);\n                        }\n                    '],{})

    Xperm4::Xperm4(ExtMachInst machInst)
        : RegOp("xperm4", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::sltu(['\n                        Rd = (rvZext(Rs1) < rvZext(Rs2)) ? 1 : 0;\n                    '],{})

    Sltu::Sltu(ExtMachInst machInst)
        : RegOp("sltu", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::mulhu(['\n                        if (machInst.rv_type == RV32) {\n                            Rd = (int32_t)mulhu<uint32_t>(Rs1, Rs2);\n                        } else {\n                            Rd = mulhu<uint64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntMultOp'],{})

    Mulhu::Mulhu(ExtMachInst machInst)
        : RegOp("mulhu", machInst, IntMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::clmulh(['\n                        uint64_t result = 0;\n                        uint64_t xlen = rvSelect(32, 64);\n                        uint64_t zextRs1 = rvZext(Rs1);\n                        for (int i = 1; i < xlen; i++) {\n                            if ((Rs2 >> i) & 1) {\n                                result ^= zextRs1 >> (xlen-i);\n                            }\n                        }\n                        // The MSB can never be 1, no need to sign extend.\n                        Rd = result;\n                    '],{})

    Clmulh::Clmulh(ExtMachInst machInst)
        : RegOp("clmulh", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::xor(['\n                        Rd = rvSext(Rs1 ^ Rs2);\n                    '],{})

    Xor::Xor(ExtMachInst machInst)
        : RegOp("xor", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::div(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = div<int32_t>(Rs1, Rs2);\n                        } else {\n                            Rd_sd = div<int64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntDivOp'],{})

    Div::Div(ExtMachInst machInst)
        : RegOp("div", machInst, IntDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::pack(['\n                        int xlen = rvSelect(32, 64);\n                        Rd = rvSext(\n                            (bits(Rs2, xlen/2-1, 0) << (xlen / 2)) | \\\n                            bits(Rs1, xlen/2-1, 0)\n                        );\n                    '],{})

    Pack::Pack(ExtMachInst machInst)
        : RegOp("pack", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::min(['\n                        Rd_sd = std::min(rvSext(Rs1_sd), rvSext(Rs2_sd));\n                    '],{})

    Min::Min(ExtMachInst machInst)
        : RegOp("min", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::sh2add(['\n                        Rd = rvSext((Rs1 << 2) + Rs2);\n                    '],{})

    Sh2add::Sh2add(ExtMachInst machInst)
        : RegOp("sh2add", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::xperm8(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = _rvk_emu_xperm8_32(Rs1_sd, Rs2_sd);\n                        } else {\n                            Rd_sd = _rvk_emu_xperm8_64(Rs1_sd, Rs2_sd);\n                        }\n                    '],{})

    Xperm8::Xperm8(ExtMachInst machInst)
        : RegOp("xperm8", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::xnor(['\n                        Rd = rvSext(~(Rs1 ^ Rs2));\n                    '],{})

    Xnor::Xnor(ExtMachInst machInst)
        : RegOp("xnor", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::srl(['\n                        Rd = rvSext(rvZext(Rs1) >>\n                                    rvSelect(Rs2<4:0>, Rs2<5:0>));\n                    '],{})

    Srl::Srl(ExtMachInst machInst)
        : RegOp("srl", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::divu(['\n                        if (machInst.rv_type == RV32) {\n                            Rd = (int32_t)divu<uint32_t>(Rs1, Rs2);\n                        } else {\n                            Rd = divu<uint64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntDivOp'],{})

    Divu::Divu(ExtMachInst machInst)
        : RegOp("divu", machInst, IntDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::czero_eqz(['\n                        Rd = rvSext(Rs2) == 0 ? 0 : rvSext(Rs1);\n                    '],{})

    Czero_eqz::Czero_eqz(ExtMachInst machInst)
        : RegOp("czero_eqz", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::sra(['\n                        Rd = rvSext(Rs1_sd) >> rvSelect(Rs2<4:0>, Rs2<5:0>);\n                    '],{})

    Sra::Sra(ExtMachInst machInst)
        : RegOp("sra", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::minu(['\n                        Rd = rvSext(std::min(rvZext(Rs1), rvZext(Rs2)));\n                    '],{})

    Minu::Minu(ExtMachInst machInst)
        : RegOp("minu", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::bext(["\n                        Rs2 &= (rvSelect(32, 64) - 1);\n                        // It doesn't need to sign ext because MSB is always 0\n                        Rd = (Rs1 >> Rs2) & 0x1;\n                    "],{})

    Bext::Bext(ExtMachInst machInst)
        : RegOp("bext", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::ror(['\n                        uint64_t xlen = rvSelect(32, 64);\n                        int shamt = Rs2 & (xlen - 1);\n                        Rd = rvSext((rvZext(Rs1) >> shamt)\n                            | (Rs1 << ((xlen - shamt) & (xlen - 1))));\n                    '],{})

    Ror::Ror(ExtMachInst machInst)
        : RegOp("ror", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::or(['\n                        Rd = rvSext(Rs1 | Rs2);\n                    '],{})

    Or::Or(ExtMachInst machInst)
        : RegOp("or", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::rem(['\n                        if (machInst.rv_type == RV32) {\n                            Rd_sd = rem<int32_t>(Rs1, Rs2);\n                        } else {\n                            Rd_sd = rem<int64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntDivOp'],{})

    Rem::Rem(ExtMachInst machInst)
        : RegOp("rem", machInst, IntDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::max(['\n                        Rd_sd = std::max(rvSext(Rs1_sd), rvSext(Rs2_sd));\n                    '],{})

    Max::Max(ExtMachInst machInst)
        : RegOp("max", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::sh3add(['\n                        Rd = rvSext((Rs1 << 3) + Rs2);\n                    '],{})

    Sh3add::Sh3add(ExtMachInst machInst)
        : RegOp("sh3add", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::orn(['\n                        Rd = rvSext(Rs1 | (~Rs2));\n                    '],{})

    Orn::Orn(ExtMachInst machInst)
        : RegOp("orn", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::and(['\n                        Rd = rvSext(Rs1 & Rs2);\n                    '],{})

    And::And(ExtMachInst machInst)
        : RegOp("and", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::remu(['\n                        if (machInst.rv_type == RV32) {\n                            Rd = (int32_t)remu<uint32_t>(Rs1, Rs2);\n                        } else {\n                            Rd = remu<uint64_t>(Rs1, Rs2);\n                        }\n                    ', 'IntDivOp'],{})

    Remu::Remu(ExtMachInst machInst)
        : RegOp("remu", machInst, IntDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::packh(["\n                        // It doesn't need to sign ext as MSB is always 0\n                        Rd = (Rs2_ub << 8) | Rs1_ub;\n                    "],{})

    Packh::Packh(ExtMachInst machInst)
        : RegOp("packh", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::maxu(['\n                        Rd = rvSext(std::max(rvZext(Rs1), rvZext(Rs2)));\n                    '],{})

    Maxu::Maxu(ExtMachInst machInst)
        : RegOp("maxu", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::czero_nez(['\n                        Rd = rvSext(Rs2) != 0 ? 0 : rvSext(Rs1);\n                    '],{})

    Czero_nez::Czero_nez(ExtMachInst machInst)
        : RegOp("czero_nez", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::andn(['\n                        Rd = rvSext(Rs1 & (~Rs2));\n                    '],{})

    Andn::Andn(ExtMachInst machInst)
        : RegOp("andn", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// UOp::lui((['\n            Rd = (sext<20>(imm) << 12);\n        '], {}))

    Lui::Lui(ExtMachInst machInst)
        : ImmOp<int64_t>("lui", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        imm = IMM20;;
    }

// ROp::addw(['\n                            Rd_sd = Rs1_sw + Rs2_sw;\n                        '],{})

    Addw::Addw(ExtMachInst machInst)
        : RegOp("addw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::mulw(['\n                            Rd_sd = (int32_t)(Rs1_sw*Rs2_sw);\n                        ', 'IntMultOp'],{})

    Mulw::Mulw(ExtMachInst machInst)
        : RegOp("mulw", machInst, IntMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::add_uw(['\n                            Rd = Rs1_uw + Rs2;\n                        '],{})

    Add_uw::Add_uw(ExtMachInst machInst)
        : RegOp("add_uw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::subw(['\n                            Rd_sd = Rs1_sw - Rs2_sw;\n                        '],{})

    Subw::Subw(ExtMachInst machInst)
        : RegOp("subw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::sllw(['\n                            Rd_sd = Rs1_sw << Rs2<4:0>;\n                        '],{})

    Sllw::Sllw(ExtMachInst machInst)
        : RegOp("sllw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::rolw(['\n                            int shamt = Rs2 & (32 - 1);\n                            Rd = (int32_t) ((Rs1_uw << shamt) | (Rs1_uw >> ((32 - shamt) & (32 - 1))));\n                        '],{})

    Rolw::Rolw(ExtMachInst machInst)
        : RegOp("rolw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::sh1add_uw(['\n                            Rd = (((uint64_t)Rs1_uw) << 1) + Rs2;\n                        '],{})

    Sh1add_uw::Sh1add_uw(ExtMachInst machInst)
        : RegOp("sh1add_uw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::divw(['\n                            Rd_sd = div<int32_t>(Rs1, Rs2);\n                        ', 'IntDivOp'],{})

    Divw::Divw(ExtMachInst machInst)
        : RegOp("divw", machInst, IntDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::packw(['\n                            Rd_sd = sext<32>((Rs2_uh << 16) | Rs1_uh);\n                        '],{})

    Packw::Packw(ExtMachInst machInst)
        : RegOp("packw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::sh2add_uw(['\n                            Rd = (((uint64_t)Rs1_uw) << 2) + Rs2;\n                        '],{})

    Sh2add_uw::Sh2add_uw(ExtMachInst machInst)
        : RegOp("sh2add_uw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::srlw(['\n                            Rd_sd = (int32_t)(Rs1_uw >> Rs2<4:0>);\n                        '],{})

    Srlw::Srlw(ExtMachInst machInst)
        : RegOp("srlw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::divuw(['\n                            Rd = sext<32>(divu<uint32_t>(Rs1, Rs2));\n                        ', 'IntDivOp'],{})

    Divuw::Divuw(ExtMachInst machInst)
        : RegOp("divuw", machInst, IntDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::sraw(['\n                            Rd_sd = Rs1_sw >> Rs2<4:0>;\n                        '],{})

    Sraw::Sraw(ExtMachInst machInst)
        : RegOp("sraw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::rorw(['\n                            int shamt = Rs2 & (32 - 1);\n                            Rd = (int32_t) ((Rs1_uw >> shamt) | (Rs1_uw << ((32 - shamt) & (32 - 1))));\n                        '],{})

    Rorw::Rorw(ExtMachInst machInst)
        : RegOp("rorw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::remw(['\n                            Rd_sd = rem<int32_t>(Rs1, Rs2);\n                        ', 'IntDivOp'],{})

    Remw::Remw(ExtMachInst machInst)
        : RegOp("remw", machInst, IntDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// ROp::sh3add_uw(['\n                            Rd = (((uint64_t)Rs1_uw) << 3) + Rs2;\n                        '],{})

    Sh3add_uw::Sh3add_uw(ExtMachInst machInst)
        : RegOp("sh3add_uw", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// ROp::remuw(['\n                        Rd = sext<32>(remu<uint32_t>(Rs1, Rs2));\n                    ', 'IntDivOp'],{})

    Remuw::Remuw(ExtMachInst machInst)
        : RegOp("remuw", machInst, IntDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fmadd_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mulAdd(f32(freg(Fs1_bits)),\n                                         f32(freg(Fs2_bits)),\n                                         f32(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fmadd_s::Fmadd_s(ExtMachInst machInst)
        : RegOp("fmadd_s", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// FPROp::fmadd_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mulAdd(f64(freg(Fs1_bits)),\n                                         f64(freg(Fs2_bits)),\n                                         f64(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fmadd_d::Fmadd_d(ExtMachInst machInst)
        : RegOp("fmadd_d", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// FPROp::fmadd_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mulAdd(f16(freg(Fs1_bits)),\n                                         f16(freg(Fs2_bits)),\n                                         f16(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fmadd_h::Fmadd_h(ExtMachInst machInst)
        : RegOp("fmadd_h", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fmsub_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mulAdd(f32(freg(Fs1_bits)),\n                                    f32(freg(Fs2_bits)),\n                                    f32(f32(freg(Fs3_bits)).v ^\n                                        mask(31, 31))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fmsub_s::Fmsub_s(ExtMachInst machInst)
        : RegOp("fmsub_s", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// FPROp::fmsub_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mulAdd(f64(freg(Fs1_bits)),\n                                    f64(freg(Fs2_bits)),\n                                    f64(f64(freg(Fs3_bits)).v ^\n                                        mask(63, 63))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fmsub_d::Fmsub_d(ExtMachInst machInst)
        : RegOp("fmsub_d", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// FPROp::fmsub_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mulAdd(f16(freg(Fs1_bits)),\n                                    f16(freg(Fs2_bits)),\n                                    f16(f16(freg(Fs3_bits)).v ^\n                                        mask(15, 15))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fmsub_h::Fmsub_h(ExtMachInst machInst)
        : RegOp("fmsub_h", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fnmsub_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mulAdd(f32(f32(freg(Fs1_bits)).v ^\n                                             mask(31, 31)),\n                                         f32(freg(Fs2_bits)),\n                                         f32(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fnmsub_s::Fnmsub_s(ExtMachInst machInst)
        : RegOp("fnmsub_s", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// FPROp::fnmsub_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mulAdd(f64(f64(freg(Fs1_bits)).v ^\n                                             mask(63, 63)),\n                                         f64(freg(Fs2_bits)),\n                                         f64(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fnmsub_d::Fnmsub_d(ExtMachInst machInst)
        : RegOp("fnmsub_d", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// FPROp::fnmsub_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mulAdd(f16(f16(freg(Fs1_bits)).v ^\n                                             mask(15, 15)),\n                                         f16(freg(Fs2_bits)),\n                                         f16(freg(Fs3_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fnmsub_h::Fnmsub_h(ExtMachInst machInst)
        : RegOp("fnmsub_h", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fnmadd_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mulAdd(f32(f32(freg(Fs1_bits)).v ^\n                                             mask(31, 31)),\n                                    f32(freg(Fs2_bits)),\n                                    f32(f32(freg(Fs3_bits)).v ^\n                                        mask(31, 31))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fnmadd_s::Fnmadd_s(ExtMachInst machInst)
        : RegOp("fnmadd_s", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// FPROp::fnmadd_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mulAdd(f64(f64(freg(Fs1_bits)).v ^\n                                             mask(63, 63)),\n                                    f64(freg(Fs2_bits)),\n                                    f64(f64(freg(Fs3_bits)).v ^\n                                        mask(63, 63))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fnmadd_d::Fnmadd_d(ExtMachInst machInst)
        : RegOp("fnmadd_d", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// FPROp::fnmadd_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mulAdd(f16(f16(freg(Fs1_bits)).v ^\n                                             mask(15, 15)),\n                                    f16(freg(Fs2_bits)),\n                                    f16(f16(freg(Fs3_bits)).v ^\n                                        mask(15, 15))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultAccOp'],{})

    Fnmadd_h::Fnmadd_h(ExtMachInst machInst)
        : RegOp("fnmadd_h", machInst, FloatMultAccOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS3]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fadd_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_add(f32(freg(Fs1_bits)),\n                                      f32(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fadd_s::Fadd_s(ExtMachInst machInst)
        : RegOp("fadd_s", machInst, FloatAddOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fadd_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_add(f64(freg(Fs1_bits)),\n                                      f64(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fadd_d::Fadd_d(ExtMachInst machInst)
        : RegOp("fadd_d", machInst, FloatAddOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fadd_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_add(f16(freg(Fs1_bits)),\n                                      f16(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fadd_h::Fadd_h(ExtMachInst machInst)
        : RegOp("fadd_h", machInst, FloatAddOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsub_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_sub(f32(freg(Fs1_bits)),\n                                      f32(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fsub_s::Fsub_s(ExtMachInst machInst)
        : RegOp("fsub_s", machInst, FloatAddOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsub_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_sub(f64(freg(Fs1_bits)),\n                                      f64(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fsub_d::Fsub_d(ExtMachInst machInst)
        : RegOp("fsub_d", machInst, FloatAddOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsub_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_sub(f16(freg(Fs1_bits)),\n                                      f16(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatAddOp'],{})

    Fsub_h::Fsub_h(ExtMachInst machInst)
        : RegOp("fsub_h", machInst, FloatAddOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fmul_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_mul(f32(freg(Fs1_bits)),\n                                      f32(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultOp'],{})

    Fmul_s::Fmul_s(ExtMachInst machInst)
        : RegOp("fmul_s", machInst, FloatMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fmul_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_mul(f64(freg(Fs1_bits)),\n                                      f64(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultOp'],{})

    Fmul_d::Fmul_d(ExtMachInst machInst)
        : RegOp("fmul_d", machInst, FloatMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fmul_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_mul(f16(freg(Fs1_bits)),\n                                      f16(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatMultOp'],{})

    Fmul_h::Fmul_h(ExtMachInst machInst)
        : RegOp("fmul_h", machInst, FloatMultOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fdiv_s(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f32_div(f32(freg(Fs1_bits)),\n                                      f32(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatDivOp'],{})

    Fdiv_s::Fdiv_s(ExtMachInst machInst)
        : RegOp("fdiv_s", machInst, FloatDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fdiv_d(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f64_div(f64(freg(Fs1_bits)),\n                                      f64(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatDivOp'],{})

    Fdiv_d::Fdiv_d(ExtMachInst machInst)
        : RegOp("fdiv_d", machInst, FloatDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fdiv_h(['\n                    RM_REQUIRED;\n                    freg_t fd;\n                    fd = freg(f16_div(f16(freg(Fs1_bits)),\n                                      f16(freg(Fs2_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatDivOp'],{})

    Fdiv_h::Fdiv_h(ExtMachInst machInst)
        : RegOp("fdiv_h", machInst, FloatDivOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsgnj_s(['\n                        auto sign = bits(unboxF32(Fs2_bits), 31);\n                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fsgnj_s::Fsgnj_s(ExtMachInst machInst)
        : RegOp("fsgnj_s", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsgnjn_s(['\n                        auto sign = ~bits(unboxF32(Fs2_bits), 31);\n                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fsgnjn_s::Fsgnjn_s(ExtMachInst machInst)
        : RegOp("fsgnjn_s", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsgnjx_s(['\n                        auto sign = bits(\n                            unboxF32(Fs1_bits) ^ unboxF32(Fs2_bits), 31);\n                        Fd_bits = boxF32(insertBits(unboxF32(Fs1_bits), 31,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fsgnjx_s::Fsgnjx_s(ExtMachInst machInst)
        : RegOp("fsgnjx_s", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fsgnj_d(['\n                        Fd_bits = insertBits(Fs2_bits, 62, 0, Fs1_bits);\n                    ', 'FloatMiscOp'],{})

    Fsgnj_d::Fsgnj_d(ExtMachInst machInst)
        : RegOp("fsgnj_d", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsgnjn_d(['\n                        Fd_bits = insertBits(~Fs2_bits, 62, 0, Fs1_bits);\n                    ', 'FloatMiscOp'],{})

    Fsgnjn_d::Fsgnjn_d(ExtMachInst machInst)
        : RegOp("fsgnjn_d", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsgnjx_d(['\n                        Fd_bits = insertBits(\n                                Fs1_bits ^ Fs2_bits, 62, 0, Fs1_bits);\n                    ', 'FloatMiscOp'],{})

    Fsgnjx_d::Fsgnjx_d(ExtMachInst machInst)
        : RegOp("fsgnjx_d", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fsgnj_h(['\n                        auto sign = bits(unboxF16(Fs2_bits), 15);\n                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fsgnj_h::Fsgnj_h(ExtMachInst machInst)
        : RegOp("fsgnj_h", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsgnjn_h(['\n                        auto sign = ~bits(unboxF16(Fs2_bits), 15);\n                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fsgnjn_h::Fsgnjn_h(ExtMachInst machInst)
        : RegOp("fsgnjn_h", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fsgnjx_h(['\n                        auto sign = bits(\n                            unboxF16(Fs1_bits) ^ unboxF16(Fs2_bits), 15);\n                        Fd_bits = boxF16(insertBits(unboxF16(Fs1_bits), 15,\n                                                    sign));\n                        ', 'FloatMiscOp'],{})

    Fsgnjx_h::Fsgnjx_h(ExtMachInst machInst)
        : RegOp("fsgnjx_h", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fmin_s(['\n                        float32_t fs1 = f32(freg(Fs1_bits));\n                        float32_t fs2 = f32(freg(Fs2_bits));\n                        float32_t fd;\n                        bool less = f32_lt_quiet(fs1, fs2) ||\n                            (f32_eq(fs1, fs2) && bits(fs1.v, 31));\n\n                        fd = less || isNaNF32UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF32UI(fs1.v) && isNaNF32UI(fs2.v))\n                            fd = f32(defaultNaNF32UI);\n                        Fd_bits = freg(fd).v;\n                        ', 'FloatCmpOp'],{})

    Fmin_s::Fmin_s(ExtMachInst machInst)
        : RegOp("fmin_s", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fmax_s(['\n                        float32_t fs1 = f32(freg(Fs1_bits));\n                        float32_t fs2 = f32(freg(Fs2_bits));\n                        float32_t fd;\n                        bool greater = f32_lt_quiet(fs2, fs1) ||\n                            (f32_eq(fs2, fs1) && bits(fs2.v, 31));\n\n                        fd = greater || isNaNF32UI(fs2.v) ? fs1: fs2;\n                        if (isNaNF32UI(fs1.v) && isNaNF32UI(fs2.v))\n                            fd = f32(defaultNaNF32UI);\n                        Fd_bits = freg(fd).v;\n                        ', 'FloatCmpOp'],{})

    Fmax_s::Fmax_s(ExtMachInst machInst)
        : RegOp("fmax_s", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fmin_d(['\n                        float64_t fs1 = f64(freg(Fs1_bits));\n                        float64_t fs2 = f64(freg(Fs2_bits));\n                        float64_t fd;\n                        bool less = f64_lt_quiet(fs1, fs2) ||\n                            (f64_eq(fs1, fs2) && bits(fs1.v, 63));\n\n                        fd = less || isNaNF64UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF64UI(fs1.v) && isNaNF64UI(fs2.v))\n                            fd = f64(defaultNaNF64UI);\n                        Fd_bits = freg(fd).v;\n                    ', 'FloatCmpOp'],{})

    Fmin_d::Fmin_d(ExtMachInst machInst)
        : RegOp("fmin_d", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fmax_d(['\n                        float64_t fs1 = f64(freg(Fs1_bits));\n                        float64_t fs2 = f64(freg(Fs2_bits));\n                        float64_t fd;\n                        bool greater = f64_lt_quiet(fs2, fs1) ||\n                            (f64_eq(fs2, fs1) && bits(fs2.v, 63));\n\n                        fd = greater || isNaNF64UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF64UI(fs1.v) && isNaNF64UI(fs2.v))\n                            fd = f64(defaultNaNF64UI);\n                        Fd_bits = freg(fd).v;\n                    ', 'FloatCmpOp'],{})

    Fmax_d::Fmax_d(ExtMachInst machInst)
        : RegOp("fmax_d", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fmin_h(['\n                        float16_t fs1 = f16(freg(Fs1_bits));\n                        float16_t fs2 = f16(freg(Fs2_bits));\n                        float16_t fd;\n                        bool less = f16_lt_quiet(fs1, fs2) ||\n                            (f16_eq(fs1, fs2) && bits(fs1.v, 15));\n\n                        fd = less || isNaNF16UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF16UI(fs1.v) && isNaNF16UI(fs2.v))\n                            fd = f16(defaultNaNF16UI);\n                        Fd_bits = freg(fd).v;\n                        ', 'FloatCmpOp'],{})

    Fmin_h::Fmin_h(ExtMachInst machInst)
        : RegOp("fmin_h", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// FPROp::fmax_h(['\n                        float16_t fs1 = f16(freg(Fs1_bits));\n                        float16_t fs2 = f16(freg(Fs2_bits));\n                        float16_t fd;\n                        bool greater = f16_lt_quiet(fs2, fs1) ||\n                            (f16_eq(fs2, fs1) && bits(fs2.v, 15));\n\n                        fd = greater || isNaNF16UI(fs2.v) ? fs1 : fs2;\n                        if (isNaNF16UI(fs1.v) && isNaNF16UI(fs2.v))\n                            fd = f16(defaultNaNF16UI);\n                        Fd_bits = freg(fd).v;\n                        ', 'FloatCmpOp'],{})

    Fmax_h::Fmax_h(ExtMachInst machInst)
        : RegOp("fmax_h", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_s_d(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f64_to_f32(f64(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fcvt_s_d::Fcvt_s_d(ExtMachInst machInst)
        : RegOp("fcvt_s_d", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// FPROp::fcvt_s_h(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f16_to_f32(f16(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fcvt_s_h::Fcvt_s_h(ExtMachInst machInst)
        : RegOp("fcvt_s_h", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_d_s(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f32_to_f64(f32(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fcvt_d_s::Fcvt_d_s(ExtMachInst machInst)
        : RegOp("fcvt_d_s", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// FPROp::fcvt_d_h(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f16_to_f64(f16(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fcvt_d_h::Fcvt_d_h(ExtMachInst machInst)
        : RegOp("fcvt_d_h", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_h_s(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f32_to_f16(f32(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fcvt_h_s::Fcvt_h_s(ExtMachInst machInst)
        : RegOp("fcvt_h_s", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// FPROp::fcvt_h_d(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(f64_to_f16(f64(freg(Fs1_bits))));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fcvt_h_d::Fcvt_h_d(ExtMachInst machInst)
        : RegOp("fcvt_h_d", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fsqrt_s(['\n                    if (RS2 != 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x1", machInst);\n                    }\n                    freg_t fd;\n                    RM_REQUIRED;\n                    fd = freg(f32_sqrt(f32(freg(Fs1_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatSqrtOp'],{})

    Fsqrt_s::Fsqrt_s(ExtMachInst machInst)
        : RegOp("fsqrt_s", machInst, FloatSqrtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// FPROp::fsqrt_d(['\n                    if (RS2 != 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x1", machInst);\n                    }\n                    freg_t fd;\n                    RM_REQUIRED;\n                    fd = freg(f64_sqrt(f64(freg(Fs1_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatSqrtOp'],{})

    Fsqrt_d::Fsqrt_d(ExtMachInst machInst)
        : RegOp("fsqrt_d", machInst, FloatSqrtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// FPROp::fsqrt_h(['\n                    if (RS2 != 0) {\n                        return std::make_shared<IllegalInstFault>(\n                                "source reg x1", machInst);\n                    }\n                    freg_t fd;\n                    RM_REQUIRED;\n                    fd = freg(f16_sqrt(f16(freg(Fs1_bits))));\n                    Fd_bits = fd.v;\n                ', 'FloatSqrtOp'],{})

    Fsqrt_h::Fsqrt_h(ExtMachInst machInst)
        : RegOp("fsqrt_h", machInst, FloatSqrtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;;
    }

// FPROp::fle_s(['\n                        Rd = f32_le(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fle_s::Fle_s(ExtMachInst machInst)
        : RegOp("fle_s", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::flt_s(['\n                        Rd = f32_lt(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Flt_s::Flt_s(ExtMachInst machInst)
        : RegOp("flt_s", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::feq_s(['\n                        Rd = f32_eq(f32(freg(Fs1_bits)), f32(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Feq_s::Feq_s(ExtMachInst machInst)
        : RegOp("feq_s", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fle_d(['\n                        Rd = f64_le(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fle_d::Fle_d(ExtMachInst machInst)
        : RegOp("fle_d", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::flt_d(['\n                        Rd = f64_lt(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Flt_d::Flt_d(ExtMachInst machInst)
        : RegOp("flt_d", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::feq_d(['\n                        Rd = f64_eq(f64(freg(Fs1_bits)), f64(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Feq_d::Feq_d(ExtMachInst machInst)
        : RegOp("feq_d", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fle_h(['\n                        Rd = f16_le(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Fle_h::Fle_h(ExtMachInst machInst)
        : RegOp("fle_h", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::flt_h(['\n                        Rd = f16_lt(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Flt_h::Flt_h(ExtMachInst machInst)
        : RegOp("flt_h", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::feq_h(['\n                        Rd = f16_eq(f16(freg(Fs1_bits)), f16(freg(Fs2_bits)));\n                    ', 'FloatCmpOp'],{})

    Feq_h::Feq_h(ExtMachInst machInst)
        : RegOp("feq_h", machInst, FloatCmpOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS2]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_w_s(['\n                        RM_REQUIRED;\n                        Rd_sd = sext<32>(f32_to_i32(f32(freg(Fs1_bits)), rm,\n                                                    true));\n                    ', 'FloatCvtOp'],{})

    Fcvt_w_s::Fcvt_w_s(ExtMachInst machInst)
        : RegOp("fcvt_w_s", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_wu_s(['\n                        RM_REQUIRED;\n                        Rd = sext<32>(f32_to_ui32(f32(freg(Fs1_bits)), rm,\n                                                  true));\n                    ', 'FloatCvtOp'],{})

    Fcvt_wu_s::Fcvt_wu_s(ExtMachInst machInst)
        : RegOp("fcvt_wu_s", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_l_s(['\n                            RM_REQUIRED;\n                            Rd_sd = f32_to_i64(f32(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fcvt_l_s::Fcvt_l_s(ExtMachInst machInst)
        : RegOp("fcvt_l_s", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_lu_s(['\n                            RM_REQUIRED;\n                            Rd = f32_to_ui64(f32(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fcvt_lu_s::Fcvt_lu_s(ExtMachInst machInst)
        : RegOp("fcvt_lu_s", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_w_d(['\n                        RM_REQUIRED;\n                        Rd_sd = sext<32>(f64_to_i32(f64(freg(Fs1_bits)), rm,\n                                                    true));\n                    ', 'FloatCvtOp'],{})

    Fcvt_w_d::Fcvt_w_d(ExtMachInst machInst)
        : RegOp("fcvt_w_d", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_wu_d(['\n                        RM_REQUIRED;\n                        Rd = sext<32>(f64_to_ui32(f64(freg(Fs1_bits)), rm,\n                                                  true));\n                    ', 'FloatCvtOp'],{})

    Fcvt_wu_d::Fcvt_wu_d(ExtMachInst machInst)
        : RegOp("fcvt_wu_d", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_l_d(['\n                            RM_REQUIRED;\n                            Rd_sd = f64_to_i64(f64(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fcvt_l_d::Fcvt_l_d(ExtMachInst machInst)
        : RegOp("fcvt_l_d", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_lu_d(['\n                            RM_REQUIRED;\n                            Rd = f64_to_ui64(f64(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fcvt_lu_d::Fcvt_lu_d(ExtMachInst machInst)
        : RegOp("fcvt_lu_d", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_w_h(['\n                        RM_REQUIRED;\n                        Rd_sd = sext<32>(f16_to_i32(f16(freg(Fs1_bits)), rm,\n                                                    true));\n                    ', 'FloatCvtOp'],{})

    Fcvt_w_h::Fcvt_w_h(ExtMachInst machInst)
        : RegOp("fcvt_w_h", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_wu_h(['\n                        RM_REQUIRED;\n                        Rd = sext<32>(f16_to_ui32(f16(freg(Fs1_bits)), rm,\n                                                  true));\n                    ', 'FloatCvtOp'],{})

    Fcvt_wu_h::Fcvt_wu_h(ExtMachInst machInst)
        : RegOp("fcvt_wu_h", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_l_h(['\n                            RM_REQUIRED;\n                            Rd_sd = f16_to_i64(f16(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fcvt_l_h::Fcvt_l_h(ExtMachInst machInst)
        : RegOp("fcvt_l_h", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_lu_h(['\n                            RM_REQUIRED;\n                            Rd = f16_to_ui64(f16(freg(Fs1_bits)), rm, true);\n                        ', 'FloatCvtOp'],{})

    Fcvt_lu_h::Fcvt_lu_h(ExtMachInst machInst)
        : RegOp("fcvt_lu_h", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_s_w(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(i32_to_f32(Rs1_sw));\n                        Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fcvt_s_w::Fcvt_s_w(ExtMachInst machInst)
        : RegOp("fcvt_s_w", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_s_wu(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(ui32_to_f32(Rs1_uw));\n                        Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fcvt_s_wu::Fcvt_s_wu(ExtMachInst machInst)
        : RegOp("fcvt_s_wu", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_s_l(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(i64_to_f32(Rs1_ud));\n                            Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fcvt_s_l::Fcvt_s_l(ExtMachInst machInst)
        : RegOp("fcvt_s_l", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_s_lu(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(ui64_to_f32(Rs1));\n                            Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fcvt_s_lu::Fcvt_s_lu(ExtMachInst machInst)
        : RegOp("fcvt_s_lu", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_d_w(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(i32_to_f64(Rs1_sw));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fcvt_d_w::Fcvt_d_w(ExtMachInst machInst)
        : RegOp("fcvt_d_w", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_d_wu(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(ui32_to_f64(Rs1_uw));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fcvt_d_wu::Fcvt_d_wu(ExtMachInst machInst)
        : RegOp("fcvt_d_wu", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_d_l(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(i64_to_f64(Rs1_sd));\n                            Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fcvt_d_l::Fcvt_d_l(ExtMachInst machInst)
        : RegOp("fcvt_d_l", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_d_lu(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(ui64_to_f64(Rs1));\n                            Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fcvt_d_lu::Fcvt_d_lu(ExtMachInst machInst)
        : RegOp("fcvt_d_lu", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fcvt_h_w(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(i32_to_f16((int32_t)Rs1_sw));\n                        Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fcvt_h_w::Fcvt_h_w(ExtMachInst machInst)
        : RegOp("fcvt_h_w", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_h_wu(['\n                        RM_REQUIRED;\n                        freg_t fd;\n                        fd = freg(ui32_to_f16((uint32_t)Rs1_uw));\n                        Fd_bits = fd.v;\n                        ', 'FloatCvtOp'],{})

    Fcvt_h_wu::Fcvt_h_wu(ExtMachInst machInst)
        : RegOp("fcvt_h_wu", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fcvt_h_l(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(i64_to_f16(Rs1_ud));\n                            Fd_bits = fd.v;\n                            ', 'FloatCvtOp'],{})

    Fcvt_h_l::Fcvt_h_l(ExtMachInst machInst)
        : RegOp("fcvt_h_l", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fcvt_h_lu(['\n                            RM_REQUIRED;\n                            freg_t fd;\n                            fd = freg(ui64_to_f16(Rs1));\n                            Fd_bits = fd.v;\n                            ', 'FloatCvtOp'],{})

    Fcvt_h_lu::Fcvt_h_lu(ExtMachInst machInst)
        : RegOp("fcvt_h_lu", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FPROp::fmv_x_w(['\n                        uint64_t result = (uint32_t)Fs1_bits;\n                        if ((result&0x80000000) != 0) {\n                            result |= (0xFFFFFFFFULL << 32);\n                        }\n                        Rd = result;\n                    ', 'FloatCvtOp'],{})

    Fmv_x_w::Fmv_x_w(ExtMachInst machInst)
        : RegOp("fmv_x_w", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fclass_s(['\n                        Rd = rvSext(f32_classify(f32(freg(Fs1_bits))));\n                    ', 'FloatMiscOp'],{})

    Fclass_s::Fclass_s(ExtMachInst machInst)
        : RegOp("fclass_s", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fmv_x_d(['\n                            Rd = freg(Fs1_bits).v;\n                        ', 'FloatCvtOp'],{})

    Fmv_x_d::Fmv_x_d(ExtMachInst machInst)
        : RegOp("fmv_x_d", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fclass_d(['\n                        Rd = f64_classify(f64(freg(Fs1_bits)));\n                    ', 'FloatMiscOp'],{})

    Fclass_d::Fclass_d(ExtMachInst machInst)
        : RegOp("fclass_d", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fmv_x_h(['\n                        uint64_t result = (uint16_t)Fs1_bits;\n                        if ((result&0x8000) != 0) {\n                            result |= (0xFFFFFFFFFFFFULL << 16);\n                        }\n                        Rd = result;\n                    ', 'FloatCvtOp'],{})

    Fmv_x_h::Fmv_x_h(ExtMachInst machInst)
        : RegOp("fmv_x_h", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fclass_h(['\n                        Rd = f16_classify(f16(freg(Fs1_bits)));\n                    ', 'FloatMiscOp'],{})

    Fclass_h::Fclass_h(ExtMachInst machInst)
        : RegOp("fclass_h", machInst, FloatMiscOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fmv_w_x(['\n                    freg_t fd;\n                    fd = freg(f32(Rs1_uw));\n                    Fd_bits = fd.v;\n                ', 'FloatCvtOp'],{})

    Fmv_w_x::Fmv_w_x(ExtMachInst machInst)
        : RegOp("fmv_w_x", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// FPROp::fmv_d_x(['\n                        freg_t fd;\n                        fd = freg(f64(Rs1));\n                        Fd_bits = fd.v;\n                    ', 'FloatCvtOp'],{})

    Fmv_d_x::Fmv_d_x(ExtMachInst machInst)
        : RegOp("fmv_d_x", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// FPROp::fmv_h_x(['\n                    freg_t fd;\n                    fd = freg(f16(Rs1_uh));\n                    Fd_bits = fd.v;\n                ', 'FloatCvtOp'],{})

    Fmv_h_x::Fmv_h_x(ExtMachInst machInst)
        : RegOp("fmv_h_x", machInst, FloatCvtOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

// Unknown::unknown(([], {}))

// VectorIntFormat::vadd_vv(['\n                        Vd_vu[i] = Vs2_vu[i] + Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vadd_vvMicro<ElemType>::Vadd_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vadd_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vadd_vvMicro<uint8_t>;
template class Vadd_vvMicro<uint16_t>;
template class Vadd_vvMicro<uint32_t>;
template class Vadd_vvMicro<uint64_t>;
;



template<typename ElemType>
Vadd_vv<ElemType>::Vadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vadd_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vadd_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vadd_vv<uint8_t>;
template class Vadd_vv<uint16_t>;
template class Vadd_vv<uint32_t>;
template class Vadd_vv<uint64_t>;
;


// VectorIntFormat::vsub_vv(['\n                        Vd_vu[i] = Vs2_vu[i] - Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vsub_vvMicro<ElemType>::Vsub_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsub_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsub_vvMicro<uint8_t>;
template class Vsub_vvMicro<uint16_t>;
template class Vsub_vvMicro<uint32_t>;
template class Vsub_vvMicro<uint64_t>;
;



template<typename ElemType>
Vsub_vv<ElemType>::Vsub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsub_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsub_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsub_vv<uint8_t>;
template class Vsub_vv<uint16_t>;
template class Vsub_vv<uint32_t>;
template class Vsub_vv<uint64_t>;
;


// VectorIntFormat::vminu_vv(['\n                        Vd_vu[i] = Vs2_vu[i] < Vs1_vu[i] ?\n                                Vs2_vu[i] : Vs1_vu[i];\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vminu_vvMicro<ElemType>::Vminu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vminu_vv_micro", _machInst,
                     SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vminu_vvMicro<uint8_t>;
template class Vminu_vvMicro<uint16_t>;
template class Vminu_vvMicro<uint32_t>;
template class Vminu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vminu_vv<ElemType>::Vminu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vminu_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vminu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vminu_vv<uint8_t>;
template class Vminu_vv<uint16_t>;
template class Vminu_vv<uint32_t>;
template class Vminu_vv<uint64_t>;
;


// VectorIntFormat::vmin_vv(['\n                        Vd_vi[i] = Vs2_vi[i] < Vs1_vi[i] ?\n                                Vs2_vi[i] : Vs1_vi[i];\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmin_vvMicro<ElemType>::Vmin_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmin_vv_micro", _machInst,
                     SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmin_vvMicro<uint8_t>;
template class Vmin_vvMicro<uint16_t>;
template class Vmin_vvMicro<uint32_t>;
template class Vmin_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmin_vv<ElemType>::Vmin_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmin_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmin_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmin_vv<uint8_t>;
template class Vmin_vv<uint16_t>;
template class Vmin_vv<uint32_t>;
template class Vmin_vv<uint64_t>;
;


// VectorIntFormat::vmaxu_vv(['\n                        Vd_vu[i] = Vs2_vu[i] > Vs1_vu[i] ?\n                                Vs2_vu[i] : Vs1_vu[i];\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmaxu_vvMicro<ElemType>::Vmaxu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmaxu_vv_micro", _machInst,
                     SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmaxu_vvMicro<uint8_t>;
template class Vmaxu_vvMicro<uint16_t>;
template class Vmaxu_vvMicro<uint32_t>;
template class Vmaxu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmaxu_vv<ElemType>::Vmaxu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmaxu_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmaxu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmaxu_vv<uint8_t>;
template class Vmaxu_vv<uint16_t>;
template class Vmaxu_vv<uint32_t>;
template class Vmaxu_vv<uint64_t>;
;


// VectorIntFormat::vmax_vv(['\n                        Vd_vi[i] = Vs2_vi[i] > Vs1_vi[i] ?\n                                Vs2_vi[i] : Vs1_vi[i];\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmax_vvMicro<ElemType>::Vmax_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmax_vv_micro", _machInst,
                     SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmax_vvMicro<uint8_t>;
template class Vmax_vvMicro<uint16_t>;
template class Vmax_vvMicro<uint32_t>;
template class Vmax_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmax_vv<ElemType>::Vmax_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmax_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmax_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmax_vv<uint8_t>;
template class Vmax_vv<uint16_t>;
template class Vmax_vv<uint32_t>;
template class Vmax_vv<uint64_t>;
;


// VectorIntFormat::vand_vv(['\n                        Vd_vu[i] = Vs2_vu[i] & Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAluOp'],{})


template<typename ElemType>
Vand_vvMicro<ElemType>::Vand_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vand_vv_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vand_vvMicro<uint8_t>;
template class Vand_vvMicro<uint16_t>;
template class Vand_vvMicro<uint32_t>;
template class Vand_vvMicro<uint64_t>;
;



template<typename ElemType>
Vand_vv<ElemType>::Vand_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vand_vv", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vand_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vand_vv<uint8_t>;
template class Vand_vv<uint16_t>;
template class Vand_vv<uint32_t>;
template class Vand_vv<uint64_t>;
;


// VectorIntFormat::vor_vv(['\n                        Vd_vu[i] = Vs2_vu[i] | Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAluOp'],{})


template<typename ElemType>
Vor_vvMicro<ElemType>::Vor_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vor_vv_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vor_vvMicro<uint8_t>;
template class Vor_vvMicro<uint16_t>;
template class Vor_vvMicro<uint32_t>;
template class Vor_vvMicro<uint64_t>;
;



template<typename ElemType>
Vor_vv<ElemType>::Vor_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vor_vv", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vor_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vor_vv<uint8_t>;
template class Vor_vv<uint16_t>;
template class Vor_vv<uint32_t>;
template class Vor_vv<uint64_t>;
;


// VectorIntFormat::vxor_vv(['\n                        Vd_vu[i] = Vs2_vu[i] ^ Vs1_vu[i];\n                    ', 'OPIVV', 'SimdAluOp'],{})


template<typename ElemType>
Vxor_vvMicro<ElemType>::Vxor_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vxor_vv_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vxor_vvMicro<uint8_t>;
template class Vxor_vvMicro<uint16_t>;
template class Vxor_vvMicro<uint32_t>;
template class Vxor_vvMicro<uint64_t>;
;



template<typename ElemType>
Vxor_vv<ElemType>::Vxor_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vxor_vv", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vxor_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vxor_vv<uint8_t>;
template class Vxor_vv<uint16_t>;
template class Vxor_vv<uint32_t>;
template class Vxor_vv<uint64_t>;
;


// VectorGatherFormat::vrgather_vv((['\n                    for (uint32_t i = 0; i < microVl; i++) {\n                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;\n                        if (this->vm || elem_mask(v0, ei)) {\n                            const uint64_t idx = Vs1_vu[i]\n                                - vs2_elems * vs2_idx;\n                            if (Vs1_vu[i] >= vlmax)\n                                Vd_vu[i] = 0;\n                            else if (idx < vs2_elems)\n                                Vd_vu[i] = Vs2_vu[idx];\n                        }\n                    }\n                ', 'OPIVV', 'SimdMiscOp'], {}))


template<typename ElemType, typename IndexType>
Vrgather_vvMicro<ElemType, IndexType>::Vrgather_vvMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vrgather_vv_micro", _machInst,
                 SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    [[maybe_unused]] constexpr uint32_t vd_eewb = sizeof(ElemType);
    [[maybe_unused]] constexpr uint32_t vs2_eewb = sizeof(ElemType);
    [[maybe_unused]] constexpr uint32_t vs1_eewb = sizeof(IndexType);
    constexpr uint32_t vs1_split_num = (vd_eewb + vs1_eewb - 1) / vs1_eewb;
    constexpr uint32_t vd_split_num = (vs1_eewb + vd_eewb - 1) / vd_eewb;
    const int8_t lmul = vtype_vlmul(vtype);
    const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    [[maybe_unused]] const uint32_t vs2_idx = _microIdx % vs2_vregs;
    [[maybe_unused]] const uint32_t vs1_idx =
        _microIdx / vs2_vregs / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_idx =
        _microIdx / vs2_vregs / vd_split_num;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vd_idx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + vs1_idx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2_idx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + vd_idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vrgather_vvMicro<uint8_t, uint8_t>;
template class Vrgather_vvMicro<uint16_t, uint16_t>;
template class Vrgather_vvMicro<uint32_t, uint32_t>;
template class Vrgather_vvMicro<uint64_t, uint64_t>;
;



template<typename ElemType, typename IndexType>
Vrgather_vv<ElemType, IndexType>::Vrgather_vv(ExtMachInst _machInst,
    uint32_t _vlen)
    : VectorArithMacroInst("vrgather_vv", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    constexpr uint32_t vd_eewb = sizeof(ElemType);
    constexpr uint32_t vs2_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_eewb = sizeof(IndexType);
    const int8_t lmul = vtype_vlmul(vtype);
    const int8_t vs1_emul = lmul + __builtin_ctz(vs1_eewb)
                                 - __builtin_ctz(vs2_eewb);
    const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    const uint8_t vs1_vregs = vs1_emul < 0 ? 1 : 1 << vs1_emul;
    const uint8_t vd_vregs = vs2_vregs;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs1_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    uint32_t vd_vlmax = vlenb / vd_eewb;
    uint32_t vs1_vlmax = vlenb / vs1_eewb;
    for (uint32_t i = 0; i < ceil((float) this->vl / vd_vlmax); i++) {
        uint32_t pinvd_micro_vl = (vd_vlmax*(i+1) <= remaining_vl)
                                  ? vd_vlmax : remaining_vl;
        uint8_t num_vd_pins = ceil((float) pinvd_micro_vl/vs1_vlmax)*vs2_vregs;
        microop = new VPinVdMicroInst(machInst, i, num_vd_pins);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        remaining_vl -= pinvd_micro_vl;
    }

    remaining_vl = this->vl;
    for (uint32_t i = 0; i < std::max(vs1_vregs, vd_vregs) && micro_vl > 0;
            i++) {
        for (uint8_t j = 0; j < vs2_vregs; j++) {
            microop = new Vrgather_vvMicro<ElemType, IndexType>(
                _machInst, micro_vl, i * vs2_vregs + j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vrgather_vv<uint8_t, uint8_t>;
template class Vrgather_vv<uint16_t, uint16_t>;
template class Vrgather_vv<uint32_t, uint32_t>;
template class Vrgather_vv<uint64_t, uint64_t>;
;


// VectorGatherFormat::vrgatherei16_vv((['\n                    for (uint32_t i = 0; i < microVl; i++) {\n                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;\n                        if (this->vm || elem_mask(v0, ei)) {\n                            const uint32_t idx = Vs1_uh[i + vs1_bias]\n                                - vs2_elems * vs2_idx;\n                            if (Vs1_uh[i + vs1_bias] >= vlmax)\n                                Vd_vu[i + vd_bias] = 0;\n                            else if (idx < vs2_elems)\n                                Vd_vu[i + vd_bias] = Vs2_vu[idx];\n                        }\n                    }\n                ', 'OPIVV', 'SimdMiscOp'], {}))


template<typename ElemType, typename IndexType>
Vrgatherei16_vvMicro<ElemType, IndexType>::Vrgatherei16_vvMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vrgatherei16_vv_micro", _machInst,
                 SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    [[maybe_unused]] constexpr uint32_t vd_eewb = sizeof(ElemType);
    [[maybe_unused]] constexpr uint32_t vs2_eewb = sizeof(ElemType);
    [[maybe_unused]] constexpr uint32_t vs1_eewb = sizeof(IndexType);
    constexpr uint32_t vs1_split_num = (vd_eewb + vs1_eewb - 1) / vs1_eewb;
    constexpr uint32_t vd_split_num = (vs1_eewb + vd_eewb - 1) / vd_eewb;
    const int8_t lmul = vtype_vlmul(vtype);
    const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    [[maybe_unused]] const uint32_t vs2_idx = _microIdx % vs2_vregs;
    [[maybe_unused]] const uint32_t vs1_idx =
        _microIdx / vs2_vregs / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_idx =
        _microIdx / vs2_vregs / vd_split_num;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vd_idx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + vs1_idx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2_idx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + vd_idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vrgatherei16_vvMicro<uint8_t, uint16_t>;
template class Vrgatherei16_vvMicro<uint16_t, uint16_t>;
template class Vrgatherei16_vvMicro<uint32_t, uint16_t>;
template class Vrgatherei16_vvMicro<uint64_t, uint16_t>;
;



template<typename ElemType, typename IndexType>
Vrgatherei16_vv<ElemType, IndexType>::Vrgatherei16_vv(ExtMachInst _machInst,
    uint32_t _vlen)
    : VectorArithMacroInst("vrgatherei16_vv", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    constexpr uint32_t vd_eewb = sizeof(ElemType);
    constexpr uint32_t vs2_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_eewb = sizeof(IndexType);
    const int8_t lmul = vtype_vlmul(vtype);
    const int8_t vs1_emul = lmul + __builtin_ctz(vs1_eewb)
                                 - __builtin_ctz(vs2_eewb);
    const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    const uint8_t vs1_vregs = vs1_emul < 0 ? 1 : 1 << vs1_emul;
    const uint8_t vd_vregs = vs2_vregs;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs1_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    uint32_t vd_vlmax = vlenb / vd_eewb;
    uint32_t vs1_vlmax = vlenb / vs1_eewb;
    for (uint32_t i = 0; i < ceil((float) this->vl / vd_vlmax); i++) {
        uint32_t pinvd_micro_vl = (vd_vlmax*(i+1) <= remaining_vl)
                                  ? vd_vlmax : remaining_vl;
        uint8_t num_vd_pins = ceil((float) pinvd_micro_vl/vs1_vlmax)*vs2_vregs;
        microop = new VPinVdMicroInst(machInst, i, num_vd_pins);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        remaining_vl -= pinvd_micro_vl;
    }

    remaining_vl = this->vl;
    for (uint32_t i = 0; i < std::max(vs1_vregs, vd_vregs) && micro_vl > 0;
            i++) {
        for (uint8_t j = 0; j < vs2_vregs; j++) {
            microop = new Vrgatherei16_vvMicro<ElemType, IndexType>(
                _machInst, micro_vl, i * vs2_vregs + j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vrgatherei16_vv<uint8_t, uint16_t>;
template class Vrgatherei16_vv<uint16_t, uint16_t>;
template class Vrgatherei16_vv<uint32_t, uint16_t>;
template class Vrgatherei16_vv<uint64_t, uint16_t>;
;


// VectorIntFormat::vadc_vvm(['\n                            Vd_vi[i] = Vs2_vi[i] + Vs1_vi[i]\n                                    + elem_mask(v0, ei);\n                        ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vadc_vvmMicro<ElemType>::Vadc_vvmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vadc_vvm_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vadc_vvmMicro<uint8_t>;
template class Vadc_vvmMicro<uint16_t>;
template class Vadc_vvmMicro<uint32_t>;
template class Vadc_vvmMicro<uint64_t>;
;



template<typename ElemType>
Vadc_vvm<ElemType>::Vadc_vvm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vadc_vvm", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vadc_vvmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vadc_vvm<uint8_t>;
template class Vadc_vvm<uint16_t>;
template class Vadc_vvm<uint32_t>;
template class Vadc_vvm<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vsbc_vvm(['\n                            Vd_vi[i] = Vs2_vi[i] - Vs1_vi[i]\n                                    - elem_mask(v0, ei);\n                        ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vsbc_vvmMicro<ElemType>::Vsbc_vvmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsbc_vvm_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsbc_vvmMicro<uint8_t>;
template class Vsbc_vvmMicro<uint16_t>;
template class Vsbc_vvmMicro<uint32_t>;
template class Vsbc_vvmMicro<uint64_t>;
;



template<typename ElemType>
Vsbc_vvm<ElemType>::Vsbc_vvm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsbc_vvm", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsbc_vvmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsbc_vvm<uint8_t>;
template class Vsbc_vvm<uint16_t>;
template class Vsbc_vvm<uint32_t>;
template class Vsbc_vvm<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vmerge_vvm(['\n                            Vd_vu[i] = elem_mask(v0, ei)\n                                    ? Vs1_vu[i]\n                                    : Vs2_vu[i];\n                        ', 'OPIVV', 'SimdMiscOp'],{})


template<typename ElemType>
Vmerge_vvmMicro<ElemType>::Vmerge_vvmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmerge_vvm_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmerge_vvmMicro<uint8_t>;
template class Vmerge_vvmMicro<uint16_t>;
template class Vmerge_vvmMicro<uint32_t>;
template class Vmerge_vvmMicro<uint64_t>;
;



template<typename ElemType>
Vmerge_vvm<ElemType>::Vmerge_vvm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmerge_vvm", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmerge_vvmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmerge_vvm<uint8_t>;
template class Vmerge_vvm<uint16_t>;
template class Vmerge_vvm<uint32_t>;
template class Vmerge_vvm<uint64_t>;
;


// VectorIntFormat::vmv_v_v(['\n                                Vd_vu[i] = Vs1_vu[i];\n                            ', 'OPIVV', 'SimdMiscOp'],{})


template<typename ElemType>
Vmv_v_vMicro<ElemType>::Vmv_v_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmv_v_v_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        ;
}

template class Vmv_v_vMicro<uint8_t>;
template class Vmv_v_vMicro<uint16_t>;
template class Vmv_v_vMicro<uint32_t>;
template class Vmv_v_vMicro<uint64_t>;
;



template<typename ElemType>
Vmv_v_v<ElemType>::Vmv_v_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmv_v_v", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmv_v_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmv_v_v<uint8_t>;
template class Vmv_v_v<uint16_t>;
template class Vmv_v_v<uint32_t>;
template class Vmv_v_v<uint64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorIntVxsatFormat::vsaddu_vv(['\n                        Vd_vu[i] = sat_addu<vu>(Vs2_vu[i], Vs1_vu[i],\n                            vxsatptr);\n                    ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vsaddu_vvMicro<ElemType>::Vsaddu_vvMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vsaddu_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsaddu_vvMicro<uint8_t>;
template class Vsaddu_vvMicro<uint16_t>;
template class Vsaddu_vvMicro<uint32_t>;
template class Vsaddu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vsaddu_vv<ElemType>::Vsaddu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsaddu_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsaddu_vvMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsaddu_vv<uint8_t>;
template class Vsaddu_vv<uint16_t>;
template class Vsaddu_vv<uint32_t>;
template class Vsaddu_vv<uint64_t>;
;


// VectorIntVxsatFormat::vsadd_vv(['\n                        Vd_vu[i] = sat_add<vi>(Vs2_vu[i], Vs1_vu[i],\n                            vxsatptr);\n                    ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vsadd_vvMicro<ElemType>::Vsadd_vvMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vsadd_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsadd_vvMicro<uint8_t>;
template class Vsadd_vvMicro<uint16_t>;
template class Vsadd_vvMicro<uint32_t>;
template class Vsadd_vvMicro<uint64_t>;
;



template<typename ElemType>
Vsadd_vv<ElemType>::Vsadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsadd_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsadd_vvMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsadd_vv<uint8_t>;
template class Vsadd_vv<uint16_t>;
template class Vsadd_vv<uint32_t>;
template class Vsadd_vv<uint64_t>;
;


// VectorIntVxsatFormat::vssubu_vv(['\n                        Vd_vu[i] = sat_subu<vu>(Vs2_vu[i], Vs1_vu[i],\n                            vxsatptr);\n                    ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vssubu_vvMicro<ElemType>::Vssubu_vvMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vssubu_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssubu_vvMicro<uint8_t>;
template class Vssubu_vvMicro<uint16_t>;
template class Vssubu_vvMicro<uint32_t>;
template class Vssubu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vssubu_vv<ElemType>::Vssubu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssubu_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssubu_vvMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssubu_vv<uint8_t>;
template class Vssubu_vv<uint16_t>;
template class Vssubu_vv<uint32_t>;
template class Vssubu_vv<uint64_t>;
;


// VectorIntVxsatFormat::vssub_vv(['\n                        Vd_vu[i] = sat_sub<vi>(Vs2_vu[i], Vs1_vu[i],\n                            vxsatptr);\n                    ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vssub_vvMicro<ElemType>::Vssub_vvMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vssub_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssub_vvMicro<uint8_t>;
template class Vssub_vvMicro<uint16_t>;
template class Vssub_vvMicro<uint32_t>;
template class Vssub_vvMicro<uint64_t>;
;



template<typename ElemType>
Vssub_vv<ElemType>::Vssub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssub_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssub_vvMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssub_vv<uint8_t>;
template class Vssub_vv<uint16_t>;
template class Vssub_vv<uint32_t>;
template class Vssub_vv<uint64_t>;
;


// VectorIntVxsatFormat::vsmul_vv(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        bool overflow = Vs1_vi[i] == Vs2_vi[i] &&\n                                        Vs1_vi[i] == min;\n                        __int128_t result = (__int128_t)Vs1_vi[i] *\n                                            (__int128_t)Vs2_vi[i];\n                        result = int_rounding<__int128_t>(\n                            result, 0 /* TODO */, sew - 1);\n                        result = result >> (sew - 1);\n                        if (overflow) {\n                            result = max;\n                            *vxsatptr = true;\n                        }\n\n                        Vd_vi[i] = (vi)result;\n                    ', 'OPIVV', 'SimdMultOp'],{})


template<typename ElemType>
Vsmul_vvMicro<ElemType>::Vsmul_vvMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vsmul_vv_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsmul_vvMicro<uint8_t>;
template class Vsmul_vvMicro<uint16_t>;
template class Vsmul_vvMicro<uint32_t>;
template class Vsmul_vvMicro<uint64_t>;
;



template<typename ElemType>
Vsmul_vv<ElemType>::Vsmul_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsmul_vv", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsmul_vvMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsmul_vv<uint8_t>;
template class Vsmul_vv<uint16_t>;
template class Vsmul_vv<uint32_t>;
template class Vsmul_vv<uint64_t>;
;


// VectorIntFormat::vsll_vv(['\n                        Vd_vu[i] = Vs2_vu[i] << (Vs1_vu[i] & (sew - 1));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template<typename ElemType>
Vsll_vvMicro<ElemType>::Vsll_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsll_vv_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsll_vvMicro<uint8_t>;
template class Vsll_vvMicro<uint16_t>;
template class Vsll_vvMicro<uint32_t>;
template class Vsll_vvMicro<uint64_t>;
;



template<typename ElemType>
Vsll_vv<ElemType>::Vsll_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsll_vv", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsll_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsll_vv<uint8_t>;
template class Vsll_vv<uint16_t>;
template class Vsll_vv<uint32_t>;
template class Vsll_vv<uint64_t>;
;


// VectorIntFormat::vsrl_vv(['\n                        Vd_vu[i] = Vs2_vu[i] >> (Vs1_vu[i] & (sew - 1));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template<typename ElemType>
Vsrl_vvMicro<ElemType>::Vsrl_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsrl_vv_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsrl_vvMicro<uint8_t>;
template class Vsrl_vvMicro<uint16_t>;
template class Vsrl_vvMicro<uint32_t>;
template class Vsrl_vvMicro<uint64_t>;
;



template<typename ElemType>
Vsrl_vv<ElemType>::Vsrl_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsrl_vv", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsrl_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsrl_vv<uint8_t>;
template class Vsrl_vv<uint16_t>;
template class Vsrl_vv<uint32_t>;
template class Vsrl_vv<uint64_t>;
;


// VectorIntFormat::vsra_vv(['\n                        Vd_vi[i] = Vs2_vi[i] >> (Vs1_vu[i] & (sew - 1));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template<typename ElemType>
Vsra_vvMicro<ElemType>::Vsra_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsra_vv_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsra_vvMicro<uint8_t>;
template class Vsra_vvMicro<uint16_t>;
template class Vsra_vvMicro<uint32_t>;
template class Vsra_vvMicro<uint64_t>;
;



template<typename ElemType>
Vsra_vv<ElemType>::Vsra_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsra_vv", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsra_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsra_vv<uint8_t>;
template class Vsra_vv<uint16_t>;
template class Vsra_vv<uint32_t>;
template class Vsra_vv<uint64_t>;
;


// VectorIntFormat::vssrl_vv(['\n                        int sh = Vs1_vu[i] & (sew - 1);\n                        __uint128_t val = Vs2_vu[i];\n\n                        val = int_rounding<__uint128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vu[i] = val >> sh;\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template<typename ElemType>
Vssrl_vvMicro<ElemType>::Vssrl_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vssrl_vv_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssrl_vvMicro<uint8_t>;
template class Vssrl_vvMicro<uint16_t>;
template class Vssrl_vvMicro<uint32_t>;
template class Vssrl_vvMicro<uint64_t>;
;



template<typename ElemType>
Vssrl_vv<ElemType>::Vssrl_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssrl_vv", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssrl_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssrl_vv<uint8_t>;
template class Vssrl_vv<uint16_t>;
template class Vssrl_vv<uint32_t>;
template class Vssrl_vv<uint64_t>;
;


// VectorIntFormat::vssra_vv(['\n                        int sh = Vs1_vi[i] & (sew - 1);\n                        __int128_t val = Vs2_vi[i];\n\n                        val = int_rounding<__int128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vi[i] = val >> sh;\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template<typename ElemType>
Vssra_vvMicro<ElemType>::Vssra_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vssra_vv_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssra_vvMicro<uint8_t>;
template class Vssra_vvMicro<uint16_t>;
template class Vssra_vvMicro<uint32_t>;
template class Vssra_vvMicro<uint64_t>;
;



template<typename ElemType>
Vssra_vv<ElemType>::Vssra_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssra_vv", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssra_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssra_vv<uint8_t>;
template class Vssra_vv<uint16_t>;
template class Vssra_vv<uint32_t>;
template class Vssra_vv<uint64_t>;
;


// VectorReduceIntWideningFormat::vwredsumu_vs(['\n                        Vd_vwu[0] = reduce_loop(std::plus<vwu>(),\n                            Vs1_vwu, Vs2_vu);\n                    ', 'OPIVV', 'SimdReduceAddOp'],{})


template<typename ElemType>
Vwredsumu_vsMicro<ElemType>::Vwredsumu_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vwredsumu_vs_micro", _machInst,
                 SimdReduceAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwredsumu_vsMicro<uint8_t>;
template class Vwredsumu_vsMicro<uint16_t>;
template class Vwredsumu_vsMicro<uint32_t>;
;



template<typename ElemType>
Vwredsumu_vs<ElemType>::Vwredsumu_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwredsumu_vs", _machInst, SimdReduceAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwredsumu_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwredsumu_vs<uint8_t>;
template class Vwredsumu_vs<uint16_t>;
template class Vwredsumu_vs<uint32_t>;
;


// VectorReduceIntWideningFormat::vwredsum_vs(['\n                        Vd_vwu[0] = reduce_loop(std::plus<vwi>(),\n                            Vs1_vwi, Vs2_vi);\n                    ', 'OPIVV', 'SimdReduceAddOp'],{})


template<typename ElemType>
Vwredsum_vsMicro<ElemType>::Vwredsum_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vwredsum_vs_micro", _machInst,
                 SimdReduceAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwredsum_vsMicro<uint8_t>;
template class Vwredsum_vsMicro<uint16_t>;
template class Vwredsum_vsMicro<uint32_t>;
;



template<typename ElemType>
Vwredsum_vs<ElemType>::Vwredsum_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwredsum_vs", _machInst, SimdReduceAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwredsum_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwredsum_vs<uint8_t>;
template class Vwredsum_vs<uint16_t>;
template class Vwredsum_vs<uint32_t>;
;


// VectorIntMaskFormat::vmadc_vvm(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vu[i], Vs1_vu[i],\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vmadc_vvmMicro<ElemType>::Vmadc_vvmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmadc_vvm_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmadc_vvmMicro<uint8_t>;
template class Vmadc_vvmMicro<uint16_t>;
template class Vmadc_vvmMicro<uint32_t>;
template class Vmadc_vvmMicro<uint64_t>;
;



template<typename ElemType>
Vmadc_vvm<ElemType>::Vmadc_vvm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmadc_vvm", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmadc_vvmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmadc_vvm<uint8_t>;
template class Vmadc_vvm<uint16_t>;
template class Vmadc_vvm<uint32_t>;
template class Vmadc_vvm<uint64_t>;
;


// VectorIntMaskFormat::vmadc_vv(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vu[i], Vs1_vu[i]));\n                        ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vmadc_vvMicro<ElemType>::Vmadc_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmadc_vv_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
;
}

template class Vmadc_vvMicro<uint8_t>;
template class Vmadc_vvMicro<uint16_t>;
template class Vmadc_vvMicro<uint32_t>;
template class Vmadc_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmadc_vv<ElemType>::Vmadc_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmadc_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmadc_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmadc_vv<uint8_t>;
template class Vmadc_vv<uint16_t>;
template class Vmadc_vv<uint32_t>;
template class Vmadc_vv<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmsbc_vvm(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                borrow_out(Vs2_vi[i], Vs1_vi[i],\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vmsbc_vvmMicro<ElemType>::Vmsbc_vvmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsbc_vvm_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsbc_vvmMicro<uint8_t>;
template class Vmsbc_vvmMicro<uint16_t>;
template class Vmsbc_vvmMicro<uint32_t>;
template class Vmsbc_vvmMicro<uint64_t>;
;



template<typename ElemType>
Vmsbc_vvm<ElemType>::Vmsbc_vvm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsbc_vvm", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsbc_vvmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsbc_vvm<uint8_t>;
template class Vmsbc_vvm<uint16_t>;
template class Vmsbc_vvm<uint32_t>;
template class Vmsbc_vvm<uint64_t>;
;


// VectorIntMaskFormat::vmsbc_vv(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                borrow_out(Vs2_vi[i], Vs1_vi[i]));\n                        ', 'OPIVV', 'SimdAddOp'],{})


template<typename ElemType>
Vmsbc_vvMicro<ElemType>::Vmsbc_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsbc_vv_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
;
}

template class Vmsbc_vvMicro<uint8_t>;
template class Vmsbc_vvMicro<uint16_t>;
template class Vmsbc_vvMicro<uint32_t>;
template class Vmsbc_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmsbc_vv<ElemType>::Vmsbc_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsbc_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsbc_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsbc_vv<uint8_t>;
template class Vmsbc_vv<uint16_t>;
template class Vmsbc_vv<uint32_t>;
template class Vmsbc_vv<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmseq_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] == Vs1_vu[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmseq_vvMicro<ElemType>::Vmseq_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmseq_vv_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmseq_vvMicro<uint8_t>;
template class Vmseq_vvMicro<uint16_t>;
template class Vmseq_vvMicro<uint32_t>;
template class Vmseq_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmseq_vv<ElemType>::Vmseq_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmseq_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmseq_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmseq_vv<uint8_t>;
template class Vmseq_vv<uint16_t>;
template class Vmseq_vv<uint32_t>;
template class Vmseq_vv<uint64_t>;
;


// VectorIntMaskFormat::vmsne_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] != Vs1_vu[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsne_vvMicro<ElemType>::Vmsne_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsne_vv_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsne_vvMicro<uint8_t>;
template class Vmsne_vvMicro<uint16_t>;
template class Vmsne_vvMicro<uint32_t>;
template class Vmsne_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmsne_vv<ElemType>::Vmsne_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsne_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsne_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsne_vv<uint8_t>;
template class Vmsne_vv<uint16_t>;
template class Vmsne_vv<uint32_t>;
template class Vmsne_vv<uint64_t>;
;


// VectorIntMaskFormat::vmsltu_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] < Vs1_vu[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsltu_vvMicro<ElemType>::Vmsltu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsltu_vv_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsltu_vvMicro<uint8_t>;
template class Vmsltu_vvMicro<uint16_t>;
template class Vmsltu_vvMicro<uint32_t>;
template class Vmsltu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmsltu_vv<ElemType>::Vmsltu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsltu_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsltu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsltu_vv<uint8_t>;
template class Vmsltu_vv<uint16_t>;
template class Vmsltu_vv<uint32_t>;
template class Vmsltu_vv<uint64_t>;
;


// VectorIntMaskFormat::vmslt_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] < Vs1_vi[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmslt_vvMicro<ElemType>::Vmslt_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmslt_vv_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmslt_vvMicro<uint8_t>;
template class Vmslt_vvMicro<uint16_t>;
template class Vmslt_vvMicro<uint32_t>;
template class Vmslt_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmslt_vv<ElemType>::Vmslt_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmslt_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmslt_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmslt_vv<uint8_t>;
template class Vmslt_vv<uint16_t>;
template class Vmslt_vv<uint32_t>;
template class Vmslt_vv<uint64_t>;
;


// VectorIntMaskFormat::vmsleu_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] <= Vs1_vu[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsleu_vvMicro<ElemType>::Vmsleu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsleu_vv_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsleu_vvMicro<uint8_t>;
template class Vmsleu_vvMicro<uint16_t>;
template class Vmsleu_vvMicro<uint32_t>;
template class Vmsleu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmsleu_vv<ElemType>::Vmsleu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsleu_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsleu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsleu_vv<uint8_t>;
template class Vmsleu_vv<uint16_t>;
template class Vmsleu_vv<uint32_t>;
template class Vmsleu_vv<uint64_t>;
;


// VectorIntMaskFormat::vmsle_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] <= Vs1_vi[i]));\n                    ', 'OPIVV', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsle_vvMicro<ElemType>::Vmsle_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsle_vv_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsle_vvMicro<uint8_t>;
template class Vmsle_vvMicro<uint16_t>;
template class Vmsle_vvMicro<uint32_t>;
template class Vmsle_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmsle_vv<ElemType>::Vmsle_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsle_vv", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsle_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsle_vv<uint8_t>;
template class Vmsle_vv<uint16_t>;
template class Vmsle_vv<uint32_t>;
template class Vmsle_vv<uint64_t>;
;


// VectorIntNarrowingFormat::vnsrl_wv(['\n                        Vd_vu[i + offset] = (vu)(Vs2_vwu[i] >>\n                            ((vwu)Vs1_vu[i + offset] & (sew * 2 - 1)));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template<typename ElemType>
Vnsrl_wvMicro<ElemType>::Vnsrl_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnsrl_wv_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnsrl_wvMicro<uint8_t>;
template class Vnsrl_wvMicro<uint16_t>;
template class Vnsrl_wvMicro<uint32_t>;
;



template<typename ElemType>
Vnsrl_wv<ElemType>::Vnsrl_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnsrl_wv", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnsrl_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnsrl_wv<uint8_t>;
template class Vnsrl_wv<uint16_t>;
template class Vnsrl_wv<uint32_t>;
;


// VectorIntNarrowingFormat::vnsra_wv(['\n                        Vd_vi[i + offset] = (vi)(Vs2_vwi[i] >>\n                            ((vwu)Vs1_vu[i + offset] & (sew * 2 - 1)));\n                    ', 'OPIVV', 'SimdShiftOp'],{})


template<typename ElemType>
Vnsra_wvMicro<ElemType>::Vnsra_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnsra_wv_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnsra_wvMicro<uint8_t>;
template class Vnsra_wvMicro<uint16_t>;
template class Vnsra_wvMicro<uint32_t>;
;



template<typename ElemType>
Vnsra_wv<ElemType>::Vnsra_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnsra_wv", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnsra_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnsra_wv<uint8_t>;
template class Vnsra_wv<uint16_t>;
template class Vnsra_wv<uint32_t>;
;


// VectorIntNarrowingFormat::vnclipu_wv(['\n                        vu max = std::numeric_limits<vu>::max();\n                        uint64_t sign_mask =\n                            std::numeric_limits<uint64_t>::max() << sew;\n                        __uint128_t res = Vs2_vwu[i];\n                        unsigned shift = Vs1_vu[i + offset] & ((sew * 2) - 1);\n\n                        res = int_rounding<__uint128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res & sign_mask) {\n                            res = max;\n                            // TODO: vxsat\n                        }\n\n                        Vd_vu[i + offset] = (vu)res;\n                    ', 'OPIVV', 'SimdCvtOp'],{})


template<typename ElemType>
Vnclipu_wvMicro<ElemType>::Vnclipu_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnclipu_wv_micro", _machInst,
                     SimdCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnclipu_wvMicro<uint8_t>;
template class Vnclipu_wvMicro<uint16_t>;
template class Vnclipu_wvMicro<uint32_t>;
;



template<typename ElemType>
Vnclipu_wv<ElemType>::Vnclipu_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnclipu_wv", _machInst, SimdCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnclipu_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnclipu_wv<uint8_t>;
template class Vnclipu_wv<uint16_t>;
template class Vnclipu_wv<uint32_t>;
;


// VectorIntNarrowingFormat::vnclip_wv(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        __int128_t res = Vs2_vwi[i];\n                        unsigned shift = Vs1_vi[i + offset] & ((sew * 2) - 1);\n\n                        res = int_rounding<__int128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res < min) {\n                            res = min;\n                            // TODO: vxsat\n                        } else if (res > max) {\n                            res = max;\n                            // TODO: vxsat\n                        }\n\n                        Vd_vi[i + offset] = (vi)res;\n                    ', 'OPIVV', 'SimdCvtOp'],{})


template<typename ElemType>
Vnclip_wvMicro<ElemType>::Vnclip_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnclip_wv_micro", _machInst,
                     SimdCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnclip_wvMicro<uint8_t>;
template class Vnclip_wvMicro<uint16_t>;
template class Vnclip_wvMicro<uint32_t>;
;



template<typename ElemType>
Vnclip_wv<ElemType>::Vnclip_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnclip_wv", _machInst, SimdCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnclip_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnclip_wv<uint8_t>;
template class Vnclip_wv<uint16_t>;
template class Vnclip_wv<uint32_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatFormat::vfadd_vv((['\n                    auto fd = fadd<et>(ftype<et>(Vs2_vu[i]),\n                                       ftype<et>(Vs1_vu[i]));\n                    Vd_vu[i] = fd.v;\n                ', 'OPFVV', 'SimdFloatAddOp'], {}))

template<typename ElemType>
Vfadd_vvMicro<ElemType>::Vfadd_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfadd_vv_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfadd_vvMicro<float16_t>;
template class Vfadd_vvMicro<float32_t>;
template class Vfadd_vvMicro<float64_t>;
;


template<typename ElemType>
Vfadd_vv<ElemType>::Vfadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfadd_vv", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfadd_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfadd_vv<float16_t>;
template class Vfadd_vv<float32_t>;
template class Vfadd_vv<float64_t>;
;


// VectorReduceFloatFormat::vfredusum_vs((['\n                    Vd_vu[0] = reduce_loop([](const vu& src1, const vu& src2) {\n                        return fadd<et>(ftype<et>(src1), ftype<et>(src2));\n                    }, Vs1_vu, Vs2_vu);\n                ', 'OPFVV', 'SimdFloatReduceAddOp'], {}))


template<typename ElemType>
Vfredusum_vsMicro<ElemType>::Vfredusum_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vfredusum_vs_micro", _machInst,
                 SimdFloatReduceAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfredusum_vsMicro<float16_t>;
template class Vfredusum_vsMicro<float32_t>;
template class Vfredusum_vsMicro<float64_t>;
;



template<typename ElemType>
Vfredusum_vs<ElemType>::Vfredusum_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfredusum_vs", _machInst, SimdFloatReduceAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfredusum_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfredusum_vs<float16_t>;
template class Vfredusum_vs<float32_t>;
template class Vfredusum_vs<float64_t>;
;


// VectorFloatFormat::vfsub_vv((['\n                    auto fd = fsub<et>(ftype<et>(Vs2_vu[i]),\n                                       ftype<et>(Vs1_vu[i]));\n                    Vd_vu[i] = fd.v;\n                ', 'OPFVV', 'SimdFloatAddOp'], {}))

template<typename ElemType>
Vfsub_vvMicro<ElemType>::Vfsub_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsub_vv_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsub_vvMicro<float16_t>;
template class Vfsub_vvMicro<float32_t>;
template class Vfsub_vvMicro<float64_t>;
;


template<typename ElemType>
Vfsub_vv<ElemType>::Vfsub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsub_vv", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsub_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsub_vv<float16_t>;
template class Vfsub_vv<float32_t>;
template class Vfsub_vv<float64_t>;
;


// VectorReduceFloatFormat::vfredosum_vs((['\n                    Vd_vu[0] = reduce_loop([](const vu& src1, const vu& src2) {\n                        return fadd<et>(ftype<et>(src1), ftype<et>(src2));\n                    }, Vs1_vu, Vs2_vu);\n                ', 'OPFVV', 'SimdFloatReduceAddOp'], {}))


template<typename ElemType>
Vfredosum_vsMicro<ElemType>::Vfredosum_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vfredosum_vs_micro", _machInst,
                 SimdFloatReduceAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfredosum_vsMicro<float16_t>;
template class Vfredosum_vsMicro<float32_t>;
template class Vfredosum_vsMicro<float64_t>;
;



template<typename ElemType>
Vfredosum_vs<ElemType>::Vfredosum_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfredosum_vs", _machInst, SimdFloatReduceAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfredosum_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfredosum_vs<float16_t>;
template class Vfredosum_vs<float32_t>;
template class Vfredosum_vs<float64_t>;
;


// VectorFloatFormat::vfmin_vv((['\n                    auto fd = fmin<et>(ftype<et>(Vs2_vu[i]),\n                                       ftype<et>(Vs1_vu[i]));\n                    Vd_vu[i] = fd.v;\n                ', 'OPFVV', 'SimdFloatCmpOp'], {}))

template<typename ElemType>
Vfmin_vvMicro<ElemType>::Vfmin_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmin_vv_micro", _machInst,
                     SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmin_vvMicro<float16_t>;
template class Vfmin_vvMicro<float32_t>;
template class Vfmin_vvMicro<float64_t>;
;


template<typename ElemType>
Vfmin_vv<ElemType>::Vfmin_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmin_vv", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmin_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmin_vv<float16_t>;
template class Vfmin_vv<float32_t>;
template class Vfmin_vv<float64_t>;
;


// VectorReduceFloatFormat::vfredmin_vs((['\n                    Vd_vu[0] = reduce_loop([](const vu& src1, const vu& src2) {\n                        return fmin<et>(ftype<et>(src1), ftype<et>(src2));\n                    }, Vs1_vu, Vs2_vu);\n                ', 'OPFVV', 'SimdFloatReduceCmpOp'], {}))


template<typename ElemType>
Vfredmin_vsMicro<ElemType>::Vfredmin_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vfredmin_vs_micro", _machInst,
                 SimdFloatReduceCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfredmin_vsMicro<float16_t>;
template class Vfredmin_vsMicro<float32_t>;
template class Vfredmin_vsMicro<float64_t>;
;



template<typename ElemType>
Vfredmin_vs<ElemType>::Vfredmin_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfredmin_vs", _machInst, SimdFloatReduceCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfredmin_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfredmin_vs<float16_t>;
template class Vfredmin_vs<float32_t>;
template class Vfredmin_vs<float64_t>;
;


// VectorFloatFormat::vfmax_vv((['\n                    auto fd = fmax<et>(ftype<et>(Vs2_vu[i]),\n                                       ftype<et>(Vs1_vu[i]));\n                    Vd_vu[i] = fd.v;\n                ', 'OPFVV', 'SimdFloatCmpOp'], {}))

template<typename ElemType>
Vfmax_vvMicro<ElemType>::Vfmax_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmax_vv_micro", _machInst,
                     SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmax_vvMicro<float16_t>;
template class Vfmax_vvMicro<float32_t>;
template class Vfmax_vvMicro<float64_t>;
;


template<typename ElemType>
Vfmax_vv<ElemType>::Vfmax_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmax_vv", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmax_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmax_vv<float16_t>;
template class Vfmax_vv<float32_t>;
template class Vfmax_vv<float64_t>;
;


// VectorReduceFloatFormat::vfredmax_vs((['\n                    Vd_vu[0] = reduce_loop([](const vu& src1, const vu& src2) {\n                        return fmax<et>(ftype<et>(src1), ftype<et>(src2));\n                    }, Vs1_vu, Vs2_vu);\n                ', 'OPFVV', 'SimdFloatReduceCmpOp'], {}))


template<typename ElemType>
Vfredmax_vsMicro<ElemType>::Vfredmax_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vfredmax_vs_micro", _machInst,
                 SimdFloatReduceCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfredmax_vsMicro<float16_t>;
template class Vfredmax_vsMicro<float32_t>;
template class Vfredmax_vsMicro<float64_t>;
;



template<typename ElemType>
Vfredmax_vs<ElemType>::Vfredmax_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfredmax_vs", _machInst, SimdFloatReduceCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfredmax_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfredmax_vs<float16_t>;
template class Vfredmax_vs<float32_t>;
template class Vfredmax_vs<float64_t>;
;


// VectorFloatFormat::vfsgnj_vv((['\n                    Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                         ftype<et>(Vs1_vu[i]),\n                                         false, false).v;\n                ', 'OPFVV', 'SimdFloatCvtOp'], {}))

template<typename ElemType>
Vfsgnj_vvMicro<ElemType>::Vfsgnj_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsgnj_vv_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsgnj_vvMicro<float16_t>;
template class Vfsgnj_vvMicro<float32_t>;
template class Vfsgnj_vvMicro<float64_t>;
;


template<typename ElemType>
Vfsgnj_vv<ElemType>::Vfsgnj_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsgnj_vv", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsgnj_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsgnj_vv<float16_t>;
template class Vfsgnj_vv<float32_t>;
template class Vfsgnj_vv<float64_t>;
;


// VectorFloatFormat::vfsgnjn_vv((['\n                    Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                         ftype<et>(Vs1_vu[i]),\n                                         true, false).v;\n                ', 'OPFVV', 'SimdFloatCvtOp'], {}))

template<typename ElemType>
Vfsgnjn_vvMicro<ElemType>::Vfsgnjn_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsgnjn_vv_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsgnjn_vvMicro<float16_t>;
template class Vfsgnjn_vvMicro<float32_t>;
template class Vfsgnjn_vvMicro<float64_t>;
;


template<typename ElemType>
Vfsgnjn_vv<ElemType>::Vfsgnjn_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsgnjn_vv", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsgnjn_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsgnjn_vv<float16_t>;
template class Vfsgnjn_vv<float32_t>;
template class Vfsgnjn_vv<float64_t>;
;


// VectorFloatFormat::vfsgnjx_vv((['\n                    Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                         ftype<et>(Vs1_vu[i]),\n                                         false, true).v;\n                ', 'OPFVV', 'SimdFloatCvtOp'], {}))

template<typename ElemType>
Vfsgnjx_vvMicro<ElemType>::Vfsgnjx_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsgnjx_vv_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsgnjx_vvMicro<float16_t>;
template class Vfsgnjx_vvMicro<float32_t>;
template class Vfsgnjx_vvMicro<float64_t>;
;


template<typename ElemType>
Vfsgnjx_vv<ElemType>::Vfsgnjx_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsgnjx_vv", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsgnjx_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsgnjx_vv<float16_t>;
template class Vfsgnjx_vv<float32_t>;
template class Vfsgnjx_vv<float64_t>;
;


// VectorNonSplitFormat::vfmv_f_s((['\n                            freg_t fd = freg(ftype<et>(Vs2_vu[0]));\n                            Fd_bits = fd.v;\n                        ', 'OPFVV', 'SimdMiscOp'], {}))


template<typename ElemType>
Vfmv_f_s<ElemType>::Vfmv_f_s(ExtMachInst _machInst)
    : VectorNonSplitInst("vfmv_f_s", _machInst, SimdMiscOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, floatRegClass[FD]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    ;
}

template class Vfmv_f_s<float16_t>;
template class Vfmv_f_s<float32_t>;
template class Vfmv_f_s<float64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorFloatCvtFormat::vfcvt_xu_f_v(['\n                            Vd_vu[i] = f_to_ui<et>(ftype<et>(Vs2_vu[i]),\n                                                   softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfcvt_xu_f_vMicro<ElemType>::Vfcvt_xu_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfcvt_xu_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfcvt_xu_f_vMicro<float16_t>;
template class Vfcvt_xu_f_vMicro<float32_t>;
template class Vfcvt_xu_f_vMicro<float64_t>;
;


template<typename ElemType>
Vfcvt_xu_f_v<ElemType>::Vfcvt_xu_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfcvt_xu_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfcvt_xu_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfcvt_xu_f_v<float16_t>;
template class Vfcvt_xu_f_v<float32_t>;
template class Vfcvt_xu_f_v<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_x_f_v(['\n                            Vd_vu[i] = f_to_i<et>(ftype<et>(Vs2_vu[i]),\n                                                  softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfcvt_x_f_vMicro<ElemType>::Vfcvt_x_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfcvt_x_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfcvt_x_f_vMicro<float16_t>;
template class Vfcvt_x_f_vMicro<float32_t>;
template class Vfcvt_x_f_vMicro<float64_t>;
;


template<typename ElemType>
Vfcvt_x_f_v<ElemType>::Vfcvt_x_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfcvt_x_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfcvt_x_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfcvt_x_f_v<float16_t>;
template class Vfcvt_x_f_v<float32_t>;
template class Vfcvt_x_f_v<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_f_xu_v(['\n                            auto fd = ui_to_f<et>(Vs2_vu[i]);\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfcvt_f_xu_vMicro<ElemType>::Vfcvt_f_xu_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfcvt_f_xu_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfcvt_f_xu_vMicro<float16_t>;
template class Vfcvt_f_xu_vMicro<float32_t>;
template class Vfcvt_f_xu_vMicro<float64_t>;
;


template<typename ElemType>
Vfcvt_f_xu_v<ElemType>::Vfcvt_f_xu_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfcvt_f_xu_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfcvt_f_xu_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfcvt_f_xu_v<float16_t>;
template class Vfcvt_f_xu_v<float32_t>;
template class Vfcvt_f_xu_v<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_f_x_v(['\n                            auto fd = i_to_f<et>(Vs2_vu[i]);\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfcvt_f_x_vMicro<ElemType>::Vfcvt_f_x_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfcvt_f_x_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfcvt_f_x_vMicro<float16_t>;
template class Vfcvt_f_x_vMicro<float32_t>;
template class Vfcvt_f_x_vMicro<float64_t>;
;


template<typename ElemType>
Vfcvt_f_x_v<ElemType>::Vfcvt_f_x_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfcvt_f_x_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfcvt_f_x_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfcvt_f_x_v<float16_t>;
template class Vfcvt_f_x_v<float32_t>;
template class Vfcvt_f_x_v<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_rtz_xu_f_v(['\n                            Vd_vu[i] = f_to_ui<et>(ftype<et>(Vs2_vu[i]),\n                                                   softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfcvt_rtz_xu_f_vMicro<ElemType>::Vfcvt_rtz_xu_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfcvt_rtz_xu_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfcvt_rtz_xu_f_vMicro<float16_t>;
template class Vfcvt_rtz_xu_f_vMicro<float32_t>;
template class Vfcvt_rtz_xu_f_vMicro<float64_t>;
;


template<typename ElemType>
Vfcvt_rtz_xu_f_v<ElemType>::Vfcvt_rtz_xu_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfcvt_rtz_xu_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfcvt_rtz_xu_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfcvt_rtz_xu_f_v<float16_t>;
template class Vfcvt_rtz_xu_f_v<float32_t>;
template class Vfcvt_rtz_xu_f_v<float64_t>;
;


// VectorFloatCvtFormat::vfcvt_rtz_x_f_v(['\n                            Vd_vu[i] = f_to_i<et>(ftype<et>(Vs2_vu[i]),\n                                                  softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfcvt_rtz_x_f_vMicro<ElemType>::Vfcvt_rtz_x_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfcvt_rtz_x_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfcvt_rtz_x_f_vMicro<float16_t>;
template class Vfcvt_rtz_x_f_vMicro<float32_t>;
template class Vfcvt_rtz_x_f_vMicro<float64_t>;
;


template<typename ElemType>
Vfcvt_rtz_x_f_v<ElemType>::Vfcvt_rtz_x_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfcvt_rtz_x_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfcvt_rtz_x_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfcvt_rtz_x_f_v<float16_t>;
template class Vfcvt_rtz_x_f_v<float32_t>;
template class Vfcvt_rtz_x_f_v<float64_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_xu_f_v(['\n                            Vd_vwu[i] = f_to_wui<et>(\n                                ftype<et>(Vs2_vu[i + offset]),\n                                softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfwcvt_xu_f_vMicro<ElemType>::Vfwcvt_xu_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwcvt_xu_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwcvt_xu_f_vMicro<float8_t>;
template class Vfwcvt_xu_f_vMicro<float16_t>;
template class Vfwcvt_xu_f_vMicro<float32_t>;
;



template<typename ElemType>
Vfwcvt_xu_f_v<ElemType>::Vfwcvt_xu_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwcvt_xu_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwcvt_xu_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwcvt_xu_f_v<float8_t>;
template class Vfwcvt_xu_f_v<float16_t>;
template class Vfwcvt_xu_f_v<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_x_f_v(['\n                            Vd_vwu[i] = f_to_wi<et>(\n                                ftype<et>(Vs2_vu[i + offset]),\n                                softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfwcvt_x_f_vMicro<ElemType>::Vfwcvt_x_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwcvt_x_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwcvt_x_f_vMicro<float8_t>;
template class Vfwcvt_x_f_vMicro<float16_t>;
template class Vfwcvt_x_f_vMicro<float32_t>;
;



template<typename ElemType>
Vfwcvt_x_f_v<ElemType>::Vfwcvt_x_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwcvt_x_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwcvt_x_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwcvt_x_f_v<float8_t>;
template class Vfwcvt_x_f_v<float16_t>;
template class Vfwcvt_x_f_v<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_f_xu_v(['\n                            auto fd = ui_to_wf<vu>(Vs2_vu[i + offset]);\n                            Vd_vwu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfwcvt_f_xu_vMicro<ElemType>::Vfwcvt_f_xu_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwcvt_f_xu_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwcvt_f_xu_vMicro<float8_t>;
template class Vfwcvt_f_xu_vMicro<float16_t>;
template class Vfwcvt_f_xu_vMicro<float32_t>;
;



template<typename ElemType>
Vfwcvt_f_xu_v<ElemType>::Vfwcvt_f_xu_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwcvt_f_xu_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwcvt_f_xu_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwcvt_f_xu_v<float8_t>;
template class Vfwcvt_f_xu_v<float16_t>;
template class Vfwcvt_f_xu_v<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_f_x_v(['\n                            auto fd = i_to_wf<vu>(Vs2_vu[i + offset]);\n                            Vd_vwu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfwcvt_f_x_vMicro<ElemType>::Vfwcvt_f_x_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwcvt_f_x_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwcvt_f_x_vMicro<float8_t>;
template class Vfwcvt_f_x_vMicro<float16_t>;
template class Vfwcvt_f_x_vMicro<float32_t>;
;



template<typename ElemType>
Vfwcvt_f_x_v<ElemType>::Vfwcvt_f_x_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwcvt_f_x_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwcvt_f_x_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwcvt_f_x_v<float8_t>;
template class Vfwcvt_f_x_v<float16_t>;
template class Vfwcvt_f_x_v<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_f_f_v(['\n                            auto fd = f_to_wf<et>(\n                                ftype<et>(Vs2_vu[i + offset]));\n                            Vd_vwu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfwcvt_f_f_vMicro<ElemType>::Vfwcvt_f_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwcvt_f_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwcvt_f_f_vMicro<float8_t>;
template class Vfwcvt_f_f_vMicro<float16_t>;
template class Vfwcvt_f_f_vMicro<float32_t>;
;



template<typename ElemType>
Vfwcvt_f_f_v<ElemType>::Vfwcvt_f_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwcvt_f_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwcvt_f_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwcvt_f_f_v<float8_t>;
template class Vfwcvt_f_f_v<float16_t>;
template class Vfwcvt_f_f_v<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_rtz_xu_f_v(['\n                            Vd_vwu[i] = f_to_wui<et>(\n                                ftype<et>(Vs2_vu[i + offset]),\n                                softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfwcvt_rtz_xu_f_vMicro<ElemType>::Vfwcvt_rtz_xu_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwcvt_rtz_xu_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwcvt_rtz_xu_f_vMicro<float8_t>;
template class Vfwcvt_rtz_xu_f_vMicro<float16_t>;
template class Vfwcvt_rtz_xu_f_vMicro<float32_t>;
;



template<typename ElemType>
Vfwcvt_rtz_xu_f_v<ElemType>::Vfwcvt_rtz_xu_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwcvt_rtz_xu_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwcvt_rtz_xu_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwcvt_rtz_xu_f_v<float8_t>;
template class Vfwcvt_rtz_xu_f_v<float16_t>;
template class Vfwcvt_rtz_xu_f_v<float32_t>;
;


// VectorFloatWideningCvtFormat::vfwcvt_rtz_x_f_v(['\n                            Vd_vwu[i] = f_to_wi<et>(\n                                ftype<et>(Vs2_vu[i + offset]),\n                                softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfwcvt_rtz_x_f_vMicro<ElemType>::Vfwcvt_rtz_x_f_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwcvt_rtz_x_f_v_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwcvt_rtz_x_f_vMicro<float8_t>;
template class Vfwcvt_rtz_x_f_vMicro<float16_t>;
template class Vfwcvt_rtz_x_f_vMicro<float32_t>;
;



template<typename ElemType>
Vfwcvt_rtz_x_f_v<ElemType>::Vfwcvt_rtz_x_f_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwcvt_rtz_x_f_v", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwcvt_rtz_x_f_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwcvt_rtz_x_f_v<float8_t>;
template class Vfwcvt_rtz_x_f_v<float16_t>;
template class Vfwcvt_rtz_x_f_v<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_xu_f_w(['\n                            Vd_vu[i + offset] = f_to_nui<vu>(\n                                ftype<ewt>(Vs2_vwu[i]),\n                                softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfncvt_xu_f_wMicro<ElemType>::Vfncvt_xu_f_wMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfncvt_xu_f_w_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfncvt_xu_f_wMicro<float8_t>;
template class Vfncvt_xu_f_wMicro<float16_t>;
template class Vfncvt_xu_f_wMicro<float32_t>;
;



template<typename ElemType>
Vfncvt_xu_f_w<ElemType>::Vfncvt_xu_f_w(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfncvt_xu_f_w", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfncvt_xu_f_wMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfncvt_xu_f_w<float8_t>;
template class Vfncvt_xu_f_w<float16_t>;
template class Vfncvt_xu_f_w<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_x_f_w(['\n                            Vd_vu[i + offset] = f_to_ni<vu>(\n                                ftype<ewt>(Vs2_vwu[i]),\n                                softfloat_roundingMode);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfncvt_x_f_wMicro<ElemType>::Vfncvt_x_f_wMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfncvt_x_f_w_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfncvt_x_f_wMicro<float8_t>;
template class Vfncvt_x_f_wMicro<float16_t>;
template class Vfncvt_x_f_wMicro<float32_t>;
;



template<typename ElemType>
Vfncvt_x_f_w<ElemType>::Vfncvt_x_f_w(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfncvt_x_f_w", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfncvt_x_f_wMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfncvt_x_f_w<float8_t>;
template class Vfncvt_x_f_w<float16_t>;
template class Vfncvt_x_f_w<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_f_xu_w(['\n                            auto fd = ui_to_nf<et>(Vs2_vwu[i]);\n                            Vd_vu[i + offset] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfncvt_f_xu_wMicro<ElemType>::Vfncvt_f_xu_wMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfncvt_f_xu_w_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfncvt_f_xu_wMicro<float8_t>;
template class Vfncvt_f_xu_wMicro<float16_t>;
template class Vfncvt_f_xu_wMicro<float32_t>;
;



template<typename ElemType>
Vfncvt_f_xu_w<ElemType>::Vfncvt_f_xu_w(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfncvt_f_xu_w", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfncvt_f_xu_wMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfncvt_f_xu_w<float8_t>;
template class Vfncvt_f_xu_w<float16_t>;
template class Vfncvt_f_xu_w<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_f_x_w(['\n                            auto fd = i_to_nf<et>(Vs2_vwu[i]);\n                            Vd_vu[i + offset] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfncvt_f_x_wMicro<ElemType>::Vfncvt_f_x_wMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfncvt_f_x_w_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfncvt_f_x_wMicro<float8_t>;
template class Vfncvt_f_x_wMicro<float16_t>;
template class Vfncvt_f_x_wMicro<float32_t>;
;



template<typename ElemType>
Vfncvt_f_x_w<ElemType>::Vfncvt_f_x_w(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfncvt_f_x_w", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfncvt_f_x_wMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfncvt_f_x_w<float8_t>;
template class Vfncvt_f_x_w<float16_t>;
template class Vfncvt_f_x_w<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_f_f_w(['\n                            auto fd = f_to_nf<et>(ftype<ewt>(Vs2_vwu[i]));\n                            Vd_vu[i + offset] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfncvt_f_f_wMicro<ElemType>::Vfncvt_f_f_wMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfncvt_f_f_w_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfncvt_f_f_wMicro<float8_t>;
template class Vfncvt_f_f_wMicro<float16_t>;
template class Vfncvt_f_f_wMicro<float32_t>;
;



template<typename ElemType>
Vfncvt_f_f_w<ElemType>::Vfncvt_f_f_w(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfncvt_f_f_w", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfncvt_f_f_wMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfncvt_f_f_w<float8_t>;
template class Vfncvt_f_f_w<float16_t>;
template class Vfncvt_f_f_w<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_rod_f_f_w(['\n                            softfloat_roundingMode = softfloat_round_odd;\n                            auto fd = f_to_nf<et>(ftype<ewt>(Vs2_vwu[i]));\n                            Vd_vu[i + offset] = fd.v;\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfncvt_rod_f_f_wMicro<ElemType>::Vfncvt_rod_f_f_wMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfncvt_rod_f_f_w_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfncvt_rod_f_f_wMicro<float8_t>;
template class Vfncvt_rod_f_f_wMicro<float16_t>;
template class Vfncvt_rod_f_f_wMicro<float32_t>;
;



template<typename ElemType>
Vfncvt_rod_f_f_w<ElemType>::Vfncvt_rod_f_f_w(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfncvt_rod_f_f_w", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfncvt_rod_f_f_wMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfncvt_rod_f_f_w<float8_t>;
template class Vfncvt_rod_f_f_w<float16_t>;
template class Vfncvt_rod_f_f_w<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_rtz_xu_f_w(['\n                            Vd_vu[i + offset] = f_to_nui<vu>(\n                                ftype<ewt>(Vs2_vwu[i]),\n                                softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfncvt_rtz_xu_f_wMicro<ElemType>::Vfncvt_rtz_xu_f_wMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfncvt_rtz_xu_f_w_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfncvt_rtz_xu_f_wMicro<float8_t>;
template class Vfncvt_rtz_xu_f_wMicro<float16_t>;
template class Vfncvt_rtz_xu_f_wMicro<float32_t>;
;



template<typename ElemType>
Vfncvt_rtz_xu_f_w<ElemType>::Vfncvt_rtz_xu_f_w(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfncvt_rtz_xu_f_w", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfncvt_rtz_xu_f_wMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfncvt_rtz_xu_f_w<float8_t>;
template class Vfncvt_rtz_xu_f_w<float16_t>;
template class Vfncvt_rtz_xu_f_w<float32_t>;
;


// VectorFloatNarrowingCvtFormat::vfncvt_rtz_x_f_w(['\n                            Vd_vu[i + offset] = f_to_ni<vu>(\n                                ftype<ewt>(Vs2_vwu[i]),\n                                softfloat_round_minMag);\n                        ', 'OPFVV', 'SimdFloatCvtOp'],{})

template<typename ElemType>
Vfncvt_rtz_x_f_wMicro<ElemType>::Vfncvt_rtz_x_f_wMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfncvt_rtz_x_f_w_micro", _machInst,
                     SimdFloatCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfncvt_rtz_x_f_wMicro<float8_t>;
template class Vfncvt_rtz_x_f_wMicro<float16_t>;
template class Vfncvt_rtz_x_f_wMicro<float32_t>;
;



template<typename ElemType>
Vfncvt_rtz_x_f_w<ElemType>::Vfncvt_rtz_x_f_w(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfncvt_rtz_x_f_w", _machInst, SimdFloatCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfncvt_rtz_x_f_wMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfncvt_rtz_x_f_w<float8_t>;
template class Vfncvt_rtz_x_f_w<float16_t>;
template class Vfncvt_rtz_x_f_w<float32_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatCvtFormat::vfsqrt_v(['\n                            auto fd = fsqrt<et>(ftype<et>(Vs2_vu[i]));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatSqrtOp'],{})

template<typename ElemType>
Vfsqrt_vMicro<ElemType>::Vfsqrt_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsqrt_v_micro", _machInst,
                     SimdFloatSqrtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsqrt_vMicro<float16_t>;
template class Vfsqrt_vMicro<float32_t>;
template class Vfsqrt_vMicro<float64_t>;
;


template<typename ElemType>
Vfsqrt_v<ElemType>::Vfsqrt_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsqrt_v", _machInst, SimdFloatSqrtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsqrt_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsqrt_v<float16_t>;
template class Vfsqrt_v<float32_t>;
template class Vfsqrt_v<float64_t>;
;


// VectorFloatCvtFormat::vfrsqrt7_v(['\n                            auto fd = frsqrte7<et>(ftype<et>(Vs2_vu[i]));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatSqrtOp'],{})

template<typename ElemType>
Vfrsqrt7_vMicro<ElemType>::Vfrsqrt7_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfrsqrt7_v_micro", _machInst,
                     SimdFloatSqrtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfrsqrt7_vMicro<float16_t>;
template class Vfrsqrt7_vMicro<float32_t>;
template class Vfrsqrt7_vMicro<float64_t>;
;


template<typename ElemType>
Vfrsqrt7_v<ElemType>::Vfrsqrt7_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfrsqrt7_v", _machInst, SimdFloatSqrtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfrsqrt7_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfrsqrt7_v<float16_t>;
template class Vfrsqrt7_v<float32_t>;
template class Vfrsqrt7_v<float64_t>;
;


// VectorFloatCvtFormat::vfrec7_v(['\n                            auto fd = frecip7<et>(ftype<et>(Vs2_vu[i]));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdFloatDivOp'],{})

template<typename ElemType>
Vfrec7_vMicro<ElemType>::Vfrec7_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfrec7_v_micro", _machInst,
                     SimdFloatDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfrec7_vMicro<float16_t>;
template class Vfrec7_vMicro<float32_t>;
template class Vfrec7_vMicro<float64_t>;
;


template<typename ElemType>
Vfrec7_v<ElemType>::Vfrec7_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfrec7_v", _machInst, SimdFloatDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfrec7_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfrec7_v<float16_t>;
template class Vfrec7_v<float32_t>;
template class Vfrec7_v<float64_t>;
;


// VectorFloatCvtFormat::vfclass_v(['\n                            auto fd = fclassify<et>(ftype<et>(Vs2_vu[i]));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVV', 'SimdMiscOp'],{})

template<typename ElemType>
Vfclass_vMicro<ElemType>::Vfclass_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfclass_v_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfclass_vMicro<float16_t>;
template class Vfclass_vMicro<float32_t>;
template class Vfclass_vMicro<float64_t>;
;


template<typename ElemType>
Vfclass_v<ElemType>::Vfclass_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfclass_v", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfclass_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfclass_v<float16_t>;
template class Vfclass_v<float32_t>;
template class Vfclass_v<float64_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatMaskFormat::vmfeq_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            feq<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype<et>(Vs1_vu[i])));\n                    ', 'OPFVV', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmfeq_vvMicro<ElemType>::Vmfeq_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmfeq_vv_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmfeq_vvMicro<float16_t>;
template class Vmfeq_vvMicro<float32_t>;
template class Vmfeq_vvMicro<float64_t>;
;



template<typename ElemType>
Vmfeq_vv<ElemType>::Vmfeq_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmfeq_vv", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmfeq_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmfeq_vv<float16_t>;
template class Vmfeq_vv<float32_t>;
template class Vmfeq_vv<float64_t>;
;


// VectorFloatMaskFormat::vmfle_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            fle<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype<et>(Vs1_vu[i])));\n                    ', 'OPFVV', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmfle_vvMicro<ElemType>::Vmfle_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmfle_vv_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmfle_vvMicro<float16_t>;
template class Vmfle_vvMicro<float32_t>;
template class Vmfle_vvMicro<float64_t>;
;



template<typename ElemType>
Vmfle_vv<ElemType>::Vmfle_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmfle_vv", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmfle_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmfle_vv<float16_t>;
template class Vmfle_vv<float32_t>;
template class Vmfle_vv<float64_t>;
;


// VectorFloatMaskFormat::vmflt_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            flt<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype<et>(Vs1_vu[i])));\n                    ', 'OPFVV', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmflt_vvMicro<ElemType>::Vmflt_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmflt_vv_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmflt_vvMicro<float16_t>;
template class Vmflt_vvMicro<float32_t>;
template class Vmflt_vvMicro<float64_t>;
;



template<typename ElemType>
Vmflt_vv<ElemType>::Vmflt_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmflt_vv", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmflt_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmflt_vv<float16_t>;
template class Vmflt_vv<float32_t>;
template class Vmflt_vv<float64_t>;
;


// VectorFloatMaskFormat::vmfne_vv(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            !feq<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype<et>(Vs1_vu[i])));\n                    ', 'OPFVV', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmfne_vvMicro<ElemType>::Vmfne_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmfne_vv_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmfne_vvMicro<float16_t>;
template class Vmfne_vvMicro<float32_t>;
template class Vmfne_vvMicro<float64_t>;
;



template<typename ElemType>
Vmfne_vv<ElemType>::Vmfne_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmfne_vv", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmfne_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmfne_vv<float16_t>;
template class Vmfne_vv<float32_t>;
template class Vmfne_vv<float64_t>;
;


// VectorFloatFormat::vfdiv_vv(['\n                        auto fd = fdiv<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype<et>(Vs1_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatDivOp'],{})

template<typename ElemType>
Vfdiv_vvMicro<ElemType>::Vfdiv_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfdiv_vv_micro", _machInst,
                     SimdFloatDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfdiv_vvMicro<float16_t>;
template class Vfdiv_vvMicro<float32_t>;
template class Vfdiv_vvMicro<float64_t>;
;


template<typename ElemType>
Vfdiv_vv<ElemType>::Vfdiv_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfdiv_vv", _machInst, SimdFloatDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfdiv_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfdiv_vv<float16_t>;
template class Vfdiv_vv<float32_t>;
template class Vfdiv_vv<float64_t>;
;


// VectorFloatFormat::vfmul_vv(['\n                        auto fd = fmul<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype<et>(Vs1_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultOp'],{})

template<typename ElemType>
Vfmul_vvMicro<ElemType>::Vfmul_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmul_vv_micro", _machInst,
                     SimdFloatMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmul_vvMicro<float16_t>;
template class Vfmul_vvMicro<float32_t>;
template class Vfmul_vvMicro<float64_t>;
;


template<typename ElemType>
Vfmul_vv<ElemType>::Vfmul_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmul_vv", _machInst, SimdFloatMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmul_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmul_vv<float16_t>;
template class Vfmul_vv<float32_t>;
template class Vfmul_vv<float64_t>;
;


// VectorFloatFormat::vfmadd_vv(['\n                        auto fd = fmadd<et>(ftype<et>(Vs3_vu[i]),\n                                            ftype<et>(Vs1_vu[i]),\n                                            ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfmadd_vvMicro<ElemType>::Vfmadd_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmadd_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmadd_vvMicro<float16_t>;
template class Vfmadd_vvMicro<float32_t>;
template class Vfmadd_vvMicro<float64_t>;
;


template<typename ElemType>
Vfmadd_vv<ElemType>::Vfmadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmadd_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmadd_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmadd_vv<float16_t>;
template class Vfmadd_vv<float32_t>;
template class Vfmadd_vv<float64_t>;
;


// VectorFloatFormat::vfnmadd_vv(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3_vu[i])),\n                                            ftype<et>(Vs1_vu[i]),\n                                            fneg(ftype<et>(Vs2_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfnmadd_vvMicro<ElemType>::Vfnmadd_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfnmadd_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfnmadd_vvMicro<float16_t>;
template class Vfnmadd_vvMicro<float32_t>;
template class Vfnmadd_vvMicro<float64_t>;
;


template<typename ElemType>
Vfnmadd_vv<ElemType>::Vfnmadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfnmadd_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfnmadd_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfnmadd_vv<float16_t>;
template class Vfnmadd_vv<float32_t>;
template class Vfnmadd_vv<float64_t>;
;


// VectorFloatFormat::vfmsub_vv(['\n                        auto fd = fmadd<et>(ftype<et>(Vs3_vu[i]),\n                                            ftype<et>(Vs1_vu[i]),\n                                            fneg(ftype<et>(Vs2_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfmsub_vvMicro<ElemType>::Vfmsub_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmsub_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmsub_vvMicro<float16_t>;
template class Vfmsub_vvMicro<float32_t>;
template class Vfmsub_vvMicro<float64_t>;
;


template<typename ElemType>
Vfmsub_vv<ElemType>::Vfmsub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmsub_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmsub_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmsub_vv<float16_t>;
template class Vfmsub_vv<float32_t>;
template class Vfmsub_vv<float64_t>;
;


// VectorFloatFormat::vfnmsub_vv(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3_vu[i])),\n                                            ftype<et>(Vs1_vu[i]),\n                                            ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfnmsub_vvMicro<ElemType>::Vfnmsub_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfnmsub_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfnmsub_vvMicro<float16_t>;
template class Vfnmsub_vvMicro<float32_t>;
template class Vfnmsub_vvMicro<float64_t>;
;


template<typename ElemType>
Vfnmsub_vv<ElemType>::Vfnmsub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfnmsub_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfnmsub_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfnmsub_vv<float16_t>;
template class Vfnmsub_vv<float32_t>;
template class Vfnmsub_vv<float64_t>;
;


// VectorFloatFormat::vfmacc_vv(['\n                        auto fd = fmadd<et>(ftype<et>(Vs1_vu[i]),\n                                            ftype<et>(Vs2_vu[i]),\n                                            ftype<et>(Vs3_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfmacc_vvMicro<ElemType>::Vfmacc_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmacc_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmacc_vvMicro<float16_t>;
template class Vfmacc_vvMicro<float32_t>;
template class Vfmacc_vvMicro<float64_t>;
;


template<typename ElemType>
Vfmacc_vv<ElemType>::Vfmacc_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmacc_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmacc_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmacc_vv<float16_t>;
template class Vfmacc_vv<float32_t>;
template class Vfmacc_vv<float64_t>;
;


// VectorFloatFormat::vfnmacc_vv(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs1_vu[i])),\n                                            ftype<et>(Vs2_vu[i]),\n                                            fneg(ftype<et>(Vs3_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfnmacc_vvMicro<ElemType>::Vfnmacc_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfnmacc_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfnmacc_vvMicro<float16_t>;
template class Vfnmacc_vvMicro<float32_t>;
template class Vfnmacc_vvMicro<float64_t>;
;


template<typename ElemType>
Vfnmacc_vv<ElemType>::Vfnmacc_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfnmacc_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfnmacc_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfnmacc_vv<float16_t>;
template class Vfnmacc_vv<float32_t>;
template class Vfnmacc_vv<float64_t>;
;


// VectorFloatFormat::vfmsac_vv(['\n                        auto fd = fmadd<et>(ftype<et>(Vs1_vu[i]),\n                                            ftype<et>(Vs2_vu[i]),\n                                            fneg(ftype<et>(Vs3_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfmsac_vvMicro<ElemType>::Vfmsac_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmsac_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmsac_vvMicro<float16_t>;
template class Vfmsac_vvMicro<float32_t>;
template class Vfmsac_vvMicro<float64_t>;
;


template<typename ElemType>
Vfmsac_vv<ElemType>::Vfmsac_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmsac_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmsac_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmsac_vv<float16_t>;
template class Vfmsac_vv<float32_t>;
template class Vfmsac_vv<float64_t>;
;


// VectorFloatFormat::vfnmsac_vv(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs1_vu[i])),\n                                            ftype<et>(Vs2_vu[i]),\n                                            ftype<et>(Vs3_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfnmsac_vvMicro<ElemType>::Vfnmsac_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfnmsac_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfnmsac_vvMicro<float16_t>;
template class Vfnmsac_vvMicro<float32_t>;
template class Vfnmsac_vvMicro<float64_t>;
;


template<typename ElemType>
Vfnmsac_vv<ElemType>::Vfnmsac_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfnmsac_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfnmsac_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfnmsac_vv<float16_t>;
template class Vfnmsac_vv<float32_t>;
template class Vfnmsac_vv<float64_t>;
;


// VectorReduceFloatWideningFormat::vfwredusum_vs((['\n                        Vd_vwu[0] = reduce_loop(\n                            [](const vwu& src1, const vu& src2) {\n                                return fadd<ewt>(\n                                    ftype<ewt>(src1),\n                                    f_to_wf<et>(ftype<et>(src2))\n                                );\n                            }, Vs1_vwu, Vs2_vu);\n                    ', 'OPFVV', 'SimdFloatReduceAddOp'], {}))


template<typename ElemType>
Vfwredusum_vsMicro<ElemType>::Vfwredusum_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vfwredusum_vs_micro", _machInst,
                 SimdFloatReduceAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwredusum_vsMicro<float16_t>;
template class Vfwredusum_vsMicro<float32_t>;
;



template<typename ElemType>
Vfwredusum_vs<ElemType>::Vfwredusum_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwredusum_vs", _machInst, SimdFloatReduceAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwredusum_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwredusum_vs<float16_t>;
template class Vfwredusum_vs<float32_t>;
;


// VectorReduceFloatWideningFormat::vfwredosum_vs((['\n                        Vd_vwu[0] = reduce_loop(\n                            [](const vwu& src1, const vu& src2) {\n                                return fadd<ewt>(\n                                    ftype<ewt>(src1),\n                                    f_to_wf<et>(ftype<et>(src2))\n                                );\n                            }, Vs1_vwu, Vs2_vu);\n                    ', 'OPFVV', 'SimdFloatReduceAddOp'], {}))


template<typename ElemType>
Vfwredosum_vsMicro<ElemType>::Vfwredosum_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vfwredosum_vs_micro", _machInst,
                 SimdFloatReduceAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwredosum_vsMicro<float16_t>;
template class Vfwredosum_vsMicro<float32_t>;
;



template<typename ElemType>
Vfwredosum_vs<ElemType>::Vfwredosum_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwredosum_vs", _machInst, SimdFloatReduceAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwredosum_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwredosum_vs<float16_t>;
template class Vfwredosum_vs<float32_t>;
;


// VectorFloatWideningFormat::vfwadd_vv(['\n                        auto fd = fadd<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatAddOp'],{})


template<typename ElemType>
Vfwadd_vvMicro<ElemType>::Vfwadd_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwadd_vv_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwadd_vvMicro<float16_t>;
template class Vfwadd_vvMicro<float32_t>;
;



template<typename ElemType>
Vfwadd_vv<ElemType>::Vfwadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwadd_vv", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwadd_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwadd_vv<float16_t>;
template class Vfwadd_vv<float32_t>;
;


// VectorFloatWideningFormat::vfwsub_vv(['\n                        auto fd = fsub<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatAddOp'],{})


template<typename ElemType>
Vfwsub_vvMicro<ElemType>::Vfwsub_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwsub_vv_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwsub_vvMicro<float16_t>;
template class Vfwsub_vvMicro<float32_t>;
;



template<typename ElemType>
Vfwsub_vv<ElemType>::Vfwsub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwsub_vv", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwsub_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwsub_vv<float16_t>;
template class Vfwsub_vv<float32_t>;
;


// VectorFloatWideningFormat::vfwadd_wv(['\n                        auto fd = fadd<ewt>(\n                            ftype<ewt>(Vs2_vwu[i]),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatAddOp'],{})


template<typename ElemType>
Vfwadd_wvMicro<ElemType>::Vfwadd_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwadd_wv_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwadd_wvMicro<float16_t>;
template class Vfwadd_wvMicro<float32_t>;
;



template<typename ElemType>
Vfwadd_wv<ElemType>::Vfwadd_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwadd_wv", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwadd_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwadd_wv<float16_t>;
template class Vfwadd_wv<float32_t>;
;


// VectorFloatWideningFormat::vfwsub_wv(['\n                        auto fd = fsub<ewt>(\n                            ftype<ewt>(Vs2_vwu[i]),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatAddOp'],{})


template<typename ElemType>
Vfwsub_wvMicro<ElemType>::Vfwsub_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwsub_wv_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwsub_wvMicro<float16_t>;
template class Vfwsub_wvMicro<float32_t>;
;



template<typename ElemType>
Vfwsub_wv<ElemType>::Vfwsub_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwsub_wv", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwsub_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwsub_wv<float16_t>;
template class Vfwsub_wv<float32_t>;
;


// VectorFloatWideningFormat::vfwmul_vv(['\n                        auto fd = fmul<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype<et>(Vs1_vu[i + offset])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultOp'],{})


template<typename ElemType>
Vfwmul_vvMicro<ElemType>::Vfwmul_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwmul_vv_micro", _machInst,
                     SimdFloatMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwmul_vvMicro<float16_t>;
template class Vfwmul_vvMicro<float32_t>;
;



template<typename ElemType>
Vfwmul_vv<ElemType>::Vfwmul_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwmul_vv", _machInst, SimdFloatMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwmul_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwmul_vv<float16_t>;
template class Vfwmul_vv<float32_t>;
;


// VectorFloatWideningFormat::vfwmacc_vv(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(ftype<et>(Vs1_vu[i + offset])),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            ftype<ewt>(Vs3_vwu[i]));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template<typename ElemType>
Vfwmacc_vvMicro<ElemType>::Vfwmacc_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwmacc_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwmacc_vvMicro<float16_t>;
template class Vfwmacc_vvMicro<float32_t>;
;



template<typename ElemType>
Vfwmacc_vv<ElemType>::Vfwmacc_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwmacc_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwmacc_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwmacc_vv<float16_t>;
template class Vfwmacc_vv<float32_t>;
;


// VectorFloatWideningFormat::vfwnmacc_vv(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(fneg(ftype<et>(Vs1_vu[i + offset]))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fneg(ftype<ewt>(Vs3_vwu[i])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template<typename ElemType>
Vfwnmacc_vvMicro<ElemType>::Vfwnmacc_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwnmacc_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwnmacc_vvMicro<float16_t>;
template class Vfwnmacc_vvMicro<float32_t>;
;



template<typename ElemType>
Vfwnmacc_vv<ElemType>::Vfwnmacc_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwnmacc_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwnmacc_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwnmacc_vv<float16_t>;
template class Vfwnmacc_vv<float32_t>;
;


// VectorFloatWideningFormat::vfwmsac_vv(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(ftype<et>(Vs1_vu[i + offset])),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fneg(ftype<ewt>(Vs3_vwu[i])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template<typename ElemType>
Vfwmsac_vvMicro<ElemType>::Vfwmsac_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwmsac_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwmsac_vvMicro<float16_t>;
template class Vfwmsac_vvMicro<float32_t>;
;



template<typename ElemType>
Vfwmsac_vv<ElemType>::Vfwmsac_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwmsac_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwmsac_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwmsac_vv<float16_t>;
template class Vfwmsac_vv<float32_t>;
;


// VectorFloatWideningFormat::vfwnmsac_vv(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(fneg(ftype<et>(Vs1_vu[i + offset]))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            ftype<ewt>(Vs3_vwu[i]));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVV', 'SimdFloatMultAccOp'],{})


template<typename ElemType>
Vfwnmsac_vvMicro<ElemType>::Vfwnmsac_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwnmsac_vv_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwnmsac_vvMicro<float16_t>;
template class Vfwnmsac_vvMicro<float32_t>;
;



template<typename ElemType>
Vfwnmsac_vv<ElemType>::Vfwnmsac_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwnmsac_vv", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwnmsac_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwnmsac_vv<float16_t>;
template class Vfwnmsac_vv<float32_t>;
;


// Unknown::unknown(([], {}))

// VectorReduceIntFormat::vredsum_vs(['\n                        Vd_vi[0] =\n                            reduce_loop(std::plus<vi>(), Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceAddOp'],{})


template<typename ElemType>
Vredsum_vsMicro<ElemType>::Vredsum_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vredsum_vs_micro", _machInst,
                 SimdReduceAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vredsum_vsMicro<uint8_t>;
template class Vredsum_vsMicro<uint16_t>;
template class Vredsum_vsMicro<uint32_t>;
template class Vredsum_vsMicro<uint64_t>;
;



template<typename ElemType>
Vredsum_vs<ElemType>::Vredsum_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vredsum_vs", _machInst, SimdReduceAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vredsum_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vredsum_vs<uint8_t>;
template class Vredsum_vs<uint16_t>;
template class Vredsum_vs<uint32_t>;
template class Vredsum_vs<uint64_t>;
;


// VectorReduceIntFormat::vredand_vs(['\n                        Vd_vi[0] =\n                            reduce_loop(std::bit_and<vi>(), Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceAluOp'],{})


template<typename ElemType>
Vredand_vsMicro<ElemType>::Vredand_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vredand_vs_micro", _machInst,
                 SimdReduceAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vredand_vsMicro<uint8_t>;
template class Vredand_vsMicro<uint16_t>;
template class Vredand_vsMicro<uint32_t>;
template class Vredand_vsMicro<uint64_t>;
;



template<typename ElemType>
Vredand_vs<ElemType>::Vredand_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vredand_vs", _machInst, SimdReduceAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vredand_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vredand_vs<uint8_t>;
template class Vredand_vs<uint16_t>;
template class Vredand_vs<uint32_t>;
template class Vredand_vs<uint64_t>;
;


// VectorReduceIntFormat::vredor_vs(['\n                        Vd_vi[0] =\n                            reduce_loop(std::bit_or<vi>(), Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceAluOp'],{})


template<typename ElemType>
Vredor_vsMicro<ElemType>::Vredor_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vredor_vs_micro", _machInst,
                 SimdReduceAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vredor_vsMicro<uint8_t>;
template class Vredor_vsMicro<uint16_t>;
template class Vredor_vsMicro<uint32_t>;
template class Vredor_vsMicro<uint64_t>;
;



template<typename ElemType>
Vredor_vs<ElemType>::Vredor_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vredor_vs", _machInst, SimdReduceAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vredor_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vredor_vs<uint8_t>;
template class Vredor_vs<uint16_t>;
template class Vredor_vs<uint32_t>;
template class Vredor_vs<uint64_t>;
;


// VectorReduceIntFormat::vredxor_vs(['\n                        Vd_vi[0] =\n                            reduce_loop(std::bit_xor<vi>(), Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceAluOp'],{})


template<typename ElemType>
Vredxor_vsMicro<ElemType>::Vredxor_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vredxor_vs_micro", _machInst,
                 SimdReduceAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vredxor_vsMicro<uint8_t>;
template class Vredxor_vsMicro<uint16_t>;
template class Vredxor_vsMicro<uint32_t>;
template class Vredxor_vsMicro<uint64_t>;
;



template<typename ElemType>
Vredxor_vs<ElemType>::Vredxor_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vredxor_vs", _machInst, SimdReduceAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vredxor_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vredxor_vs<uint8_t>;
template class Vredxor_vs<uint16_t>;
template class Vredxor_vs<uint32_t>;
template class Vredxor_vs<uint64_t>;
;


// VectorReduceIntFormat::vredminu_vs(['\n                        Vd_vu[0] =\n                            reduce_loop([](const vu& src1, const vu& src2) {\n                                return std::min<vu>(src1, src2);\n                            }, Vs1_vu, Vs2_vu);\n                    ', 'OPMVV', 'SimdReduceCmpOp'],{})


template<typename ElemType>
Vredminu_vsMicro<ElemType>::Vredminu_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vredminu_vs_micro", _machInst,
                 SimdReduceCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vredminu_vsMicro<uint8_t>;
template class Vredminu_vsMicro<uint16_t>;
template class Vredminu_vsMicro<uint32_t>;
template class Vredminu_vsMicro<uint64_t>;
;



template<typename ElemType>
Vredminu_vs<ElemType>::Vredminu_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vredminu_vs", _machInst, SimdReduceCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vredminu_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vredminu_vs<uint8_t>;
template class Vredminu_vs<uint16_t>;
template class Vredminu_vs<uint32_t>;
template class Vredminu_vs<uint64_t>;
;


// VectorReduceIntFormat::vredmin_vs(['\n                        Vd_vi[0] =\n                            reduce_loop([](const vi& src1, const vi& src2) {\n                                return std::min<vi>(src1, src2);\n                            }, Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceCmpOp'],{})


template<typename ElemType>
Vredmin_vsMicro<ElemType>::Vredmin_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vredmin_vs_micro", _machInst,
                 SimdReduceCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vredmin_vsMicro<uint8_t>;
template class Vredmin_vsMicro<uint16_t>;
template class Vredmin_vsMicro<uint32_t>;
template class Vredmin_vsMicro<uint64_t>;
;



template<typename ElemType>
Vredmin_vs<ElemType>::Vredmin_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vredmin_vs", _machInst, SimdReduceCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vredmin_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vredmin_vs<uint8_t>;
template class Vredmin_vs<uint16_t>;
template class Vredmin_vs<uint32_t>;
template class Vredmin_vs<uint64_t>;
;


// VectorReduceIntFormat::vredmaxu_vs(['\n                        Vd_vu[0] =\n                            reduce_loop([](const vu& src1, const vu& src2) {\n                                return std::max<vu>(src1, src2);\n                            }, Vs1_vu, Vs2_vu);\n                    ', 'OPMVV', 'SimdReduceCmpOp'],{})


template<typename ElemType>
Vredmaxu_vsMicro<ElemType>::Vredmaxu_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vredmaxu_vs_micro", _machInst,
                 SimdReduceCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vredmaxu_vsMicro<uint8_t>;
template class Vredmaxu_vsMicro<uint16_t>;
template class Vredmaxu_vsMicro<uint32_t>;
template class Vredmaxu_vsMicro<uint64_t>;
;



template<typename ElemType>
Vredmaxu_vs<ElemType>::Vredmaxu_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vredmaxu_vs", _machInst, SimdReduceCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vredmaxu_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vredmaxu_vs<uint8_t>;
template class Vredmaxu_vs<uint16_t>;
template class Vredmaxu_vs<uint32_t>;
template class Vredmaxu_vs<uint64_t>;
;


// VectorReduceIntFormat::vredmax_vs(['\n                        Vd_vi[0] =\n                            reduce_loop([](const vi& src1, const vi& src2) {\n                                return std::max<vi>(src1, src2);\n                            }, Vs1_vi, Vs2_vi);\n                    ', 'OPMVV', 'SimdReduceCmpOp'],{})


template<typename ElemType>
Vredmax_vsMicro<ElemType>::Vredmax_vsMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vredmax_vs_micro", _machInst,
                 SimdReduceCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vredmax_vsMicro<uint8_t>;
template class Vredmax_vsMicro<uint16_t>;
template class Vredmax_vsMicro<uint32_t>;
template class Vredmax_vsMicro<uint64_t>;
;



template<typename ElemType>
Vredmax_vs<ElemType>::Vredmax_vs(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vredmax_vs", _machInst, SimdReduceCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vredmax_vsMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vredmax_vs<uint8_t>;
template class Vredmax_vs<uint16_t>;
template class Vredmax_vs<uint32_t>;
template class Vredmax_vs<uint64_t>;
;


// VectorIntFormat::vaaddu_vv(['\n                        __uint128_t res = (__uint128_t)Vs2_vu[i] + Vs1_vu[i];\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vu[i] = res >> 1;\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vaaddu_vvMicro<ElemType>::Vaaddu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vaaddu_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vaaddu_vvMicro<uint8_t>;
template class Vaaddu_vvMicro<uint16_t>;
template class Vaaddu_vvMicro<uint32_t>;
template class Vaaddu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vaaddu_vv<ElemType>::Vaaddu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vaaddu_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vaaddu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vaaddu_vv<uint8_t>;
template class Vaaddu_vv<uint16_t>;
template class Vaaddu_vv<uint32_t>;
template class Vaaddu_vv<uint64_t>;
;


// VectorIntFormat::vaadd_vv(['\n                        __uint128_t res = (__uint128_t)Vs2_vi[i] + Vs1_vi[i];\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vi[i] = res >> 1;\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vaadd_vvMicro<ElemType>::Vaadd_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vaadd_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vaadd_vvMicro<uint8_t>;
template class Vaadd_vvMicro<uint16_t>;
template class Vaadd_vvMicro<uint32_t>;
template class Vaadd_vvMicro<uint64_t>;
;



template<typename ElemType>
Vaadd_vv<ElemType>::Vaadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vaadd_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vaadd_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vaadd_vv<uint8_t>;
template class Vaadd_vv<uint16_t>;
template class Vaadd_vv<uint32_t>;
template class Vaadd_vv<uint64_t>;
;


// VectorIntFormat::vasubu_vv(['\n                        __uint128_t res = (__uint128_t)Vs2_vu[i] - Vs1_vu[i];\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vu[i] = res >> 1;\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vasubu_vvMicro<ElemType>::Vasubu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vasubu_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vasubu_vvMicro<uint8_t>;
template class Vasubu_vvMicro<uint16_t>;
template class Vasubu_vvMicro<uint32_t>;
template class Vasubu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vasubu_vv<ElemType>::Vasubu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vasubu_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vasubu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vasubu_vv<uint8_t>;
template class Vasubu_vv<uint16_t>;
template class Vasubu_vv<uint32_t>;
template class Vasubu_vv<uint64_t>;
;


// VectorIntFormat::vasub_vv(['\n                        __uint128_t res = (__uint128_t)Vs2_vi[i] - Vs1_vi[i];\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vi[i] = res >> 1;\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vasub_vvMicro<ElemType>::Vasub_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vasub_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vasub_vvMicro<uint8_t>;
template class Vasub_vvMicro<uint16_t>;
template class Vasub_vvMicro<uint32_t>;
template class Vasub_vvMicro<uint64_t>;
;



template<typename ElemType>
Vasub_vv<ElemType>::Vasub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vasub_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vasub_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vasub_vv<uint8_t>;
template class Vasub_vv<uint16_t>;
template class Vasub_vv<uint32_t>;
template class Vasub_vv<uint64_t>;
;


// VectorNonSplitFormat::vmv_x_s((['\n                            Rd_ud = Vs2_vi[0];\n                        ', 'OPMVV', 'SimdMiscOp'], {}))


template<typename ElemType>
Vmv_x_s<ElemType>::Vmv_x_s(ExtMachInst _machInst)
    : VectorNonSplitInst("vmv_x_s", _machInst, SimdMiscOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    ;
}

template class Vmv_x_s<uint8_t>;
template class Vmv_x_s<uint16_t>;
template class Vmv_x_s<uint32_t>;
template class Vmv_x_s<uint64_t>;
;


// Unknown::unknown(([], {}))

// Vector1Vs1RdMaskFormat::vcpop_m((['\n                        uint64_t popcount = 0;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if(this->vm){\n                                popcount += vs2_lsb;\n                            }else{\n                                bool do_mask = elem_mask(v0, i);\n                                popcount += (vs2_lsb && do_mask);\n                            }\n                        }\n                        Rd_vu = popcount;\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Vcpop_m<ElemType>::Vcpop_m(ExtMachInst _machInst)
    : VectorNonSplitInst("vcpop_m", _machInst, SimdAluOp)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vcpop_m<uint8_t>;
;


// Vector1Vs1RdMaskFormat::vfirst_m((['\n                        int64_t pos = -1;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            if(this->vm == 0){\n                                if(elem_mask(v0, i)==0){\n                                    continue;\n                                }\n                            }\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if (vs2_lsb) {\n                                pos = i;\n                                break;\n                            }\n                        }\n                        Rd_vu = pos;\n                    ', 'OPMVV', 'SimdMiscOp'], {}))


template<typename ElemType>
Vfirst_m<ElemType>::Vfirst_m(ExtMachInst _machInst)
    : VectorNonSplitInst("vfirst_m", _machInst, SimdMiscOp)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfirst_m<uint8_t>;
;


// Unknown::unknown(([], {}))

// VectorIntExtFormat::vzext_vf8(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vu[i] = Vs2_vextu[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template<typename ElemType>
Vzext_vf8Micro<ElemType>::Vzext_vf8Micro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vzext_vf8_micro", _machInst,
                     SimdExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 8]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vzext_vf8Micro<uint8_t>;
template class Vzext_vf8Micro<uint16_t>;
template class Vzext_vf8Micro<uint32_t>;
template class Vzext_vf8Micro<uint64_t>;
;



template<typename ElemType>
Vzext_vf8<ElemType>::Vzext_vf8(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vzext_vf8", _machInst, SimdExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vzext_vf8Micro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vzext_vf8<uint8_t>;
template class Vzext_vf8<uint16_t>;
template class Vzext_vf8<uint32_t>;
template class Vzext_vf8<uint64_t>;
;


// VectorIntExtFormat::vsext_vf8(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vi[i] = Vs2_vext[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template<typename ElemType>
Vsext_vf8Micro<ElemType>::Vsext_vf8Micro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsext_vf8_micro", _machInst,
                     SimdExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 8]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsext_vf8Micro<uint8_t>;
template class Vsext_vf8Micro<uint16_t>;
template class Vsext_vf8Micro<uint32_t>;
template class Vsext_vf8Micro<uint64_t>;
;



template<typename ElemType>
Vsext_vf8<ElemType>::Vsext_vf8(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsext_vf8", _machInst, SimdExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsext_vf8Micro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsext_vf8<uint8_t>;
template class Vsext_vf8<uint16_t>;
template class Vsext_vf8<uint32_t>;
template class Vsext_vf8<uint64_t>;
;


// VectorIntExtFormat::vzext_vf4(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vu[i] = Vs2_vextu[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template<typename ElemType>
Vzext_vf4Micro<ElemType>::Vzext_vf4Micro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vzext_vf4_micro", _machInst,
                     SimdExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 4]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vzext_vf4Micro<uint8_t>;
template class Vzext_vf4Micro<uint16_t>;
template class Vzext_vf4Micro<uint32_t>;
template class Vzext_vf4Micro<uint64_t>;
;



template<typename ElemType>
Vzext_vf4<ElemType>::Vzext_vf4(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vzext_vf4", _machInst, SimdExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vzext_vf4Micro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vzext_vf4<uint8_t>;
template class Vzext_vf4<uint16_t>;
template class Vzext_vf4<uint32_t>;
template class Vzext_vf4<uint64_t>;
;


// VectorIntExtFormat::vsext_vf4(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vi[i] = Vs2_vext[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template<typename ElemType>
Vsext_vf4Micro<ElemType>::Vsext_vf4Micro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsext_vf4_micro", _machInst,
                     SimdExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 4]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsext_vf4Micro<uint8_t>;
template class Vsext_vf4Micro<uint16_t>;
template class Vsext_vf4Micro<uint32_t>;
template class Vsext_vf4Micro<uint64_t>;
;



template<typename ElemType>
Vsext_vf4<ElemType>::Vsext_vf4(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsext_vf4", _machInst, SimdExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsext_vf4Micro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsext_vf4<uint8_t>;
template class Vsext_vf4<uint16_t>;
template class Vsext_vf4<uint32_t>;
template class Vsext_vf4<uint64_t>;
;


// VectorIntExtFormat::vzext_vf2(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vu[i] = Vs2_vextu[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template<typename ElemType>
Vzext_vf2Micro<ElemType>::Vzext_vf2Micro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vzext_vf2_micro", _machInst,
                     SimdExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vzext_vf2Micro<uint8_t>;
template class Vzext_vf2Micro<uint16_t>;
template class Vzext_vf2Micro<uint32_t>;
template class Vzext_vf2Micro<uint64_t>;
;



template<typename ElemType>
Vzext_vf2<ElemType>::Vzext_vf2(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vzext_vf2", _machInst, SimdExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vzext_vf2Micro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vzext_vf2<uint8_t>;
template class Vzext_vf2<uint16_t>;
template class Vzext_vf2<uint32_t>;
template class Vzext_vf2<uint64_t>;
;


// VectorIntExtFormat::vsext_vf2(['\n                            auto offset = (vlen / SEW) * index;\n\n                            Vd_vi[i] = Vs2_vext[i + offset];\n                        ', 'OPMVV', 'SimdExtOp'],{})


template<typename ElemType>
Vsext_vf2Micro<ElemType>::Vsext_vf2Micro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsext_vf2_micro", _machInst,
                     SimdExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsext_vf2Micro<uint8_t>;
template class Vsext_vf2Micro<uint16_t>;
template class Vsext_vf2Micro<uint32_t>;
template class Vsext_vf2Micro<uint64_t>;
;



template<typename ElemType>
Vsext_vf2<ElemType>::Vsext_vf2(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsext_vf2", _machInst, SimdExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsext_vf2Micro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsext_vf2<uint8_t>;
template class Vsext_vf2<uint16_t>;
template class Vsext_vf2<uint32_t>;
template class Vsext_vf2<uint64_t>;
;


// Unknown::unknown(([], {}))

// Vector1Vs1VdMaskFormat::vmsbf_m((['\n                        bool has_one = false;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if (this->vm || elem_mask(v0, i)){\n                                uint64_t res = 0;\n                                if (!has_one && !vs2_lsb) {\n                                    res = 1;\n                                } else if (!has_one && vs2_lsb) {\n                                    has_one = true;\n                                }\n                                Vd_ub[i/8] = ASSIGN_VD_BIT(i, res);\n                            }\n                        }\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Vmsbf_m<ElemType>::Vmsbf_m(ExtMachInst _machInst)
    : VectorNonSplitInst("vmsbf_m", _machInst, SimdAluOp)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
    if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsbf_m<uint8_t>;
;


// Vector1Vs1VdMaskFormat::vmsof_m((['\n                        bool has_one = false;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if (this->vm || elem_mask(v0, i)){\n                                uint64_t res = 0;\n                                if (!has_one && vs2_lsb) {\n                                    has_one = true;\n                                    res = 1;\n                                }\n                                Vd_ub[i/8] = ASSIGN_VD_BIT(i, res);\n                            }\n                        }\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Vmsof_m<ElemType>::Vmsof_m(ExtMachInst _machInst)
    : VectorNonSplitInst("vmsof_m", _machInst, SimdAluOp)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
    if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsof_m<uint8_t>;
;


// Vector1Vs1VdMaskFormat::vmsif_m((['\n                        bool has_one = false;\n                        for (uint32_t i = 0; i < (uint32_t)machInst.vl; i++) {\n                            bool vs2_lsb = elem_mask(Vs2_vu, i);\n                            if (this->vm || elem_mask(v0, i)){\n                                uint64_t res = 0;\n                                if (!has_one && !vs2_lsb) {\n                                    res = 1;\n                                } else if (!has_one && vs2_lsb) {\n                                    has_one = true;\n                                    res = 1;\n                                }\n                                Vd_ub[i/8] = ASSIGN_VD_BIT(i, res);\n                            }\n                        }\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Vmsif_m<ElemType>::Vmsif_m(ExtMachInst _machInst)
    : VectorNonSplitInst("vmsif_m", _machInst, SimdAluOp)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
    if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsif_m<uint8_t>;
;


// ViotaFormat::viota_m((['\n                        if (this->vm || elem_mask(v0, ei)) {\n                            Vd_vu[i] = *cnt;\n                            if (elem_mask(Vs2_vu, ei)) {\n                                *cnt = *cnt+1;\n                            }\n                        }\n                    ', 'OPMVV', 'SimdAluOp'], {}))


template<typename ElemType>
Viota_mMicro<ElemType>::Viota_mMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, int* cnt)
    : VectorArithMicroInst("viota_m_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->cnt = cnt;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Viota_mMicro<uint8_t>;
template class Viota_mMicro<uint16_t>;
template class Viota_mMicro<uint32_t>;
template class Viota_mMicro<uint64_t>;
;



template<typename ElemType>
Viota_m<ElemType>::Viota_m(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("viota_m", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);

    StaticInstPtr microop;

    // Allow one empty micro op to hold IsLastMicroop flag
    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Viota_mMicro<ElemType>(_machInst, micro_vl, i,
            &cnt);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Viota_m<uint8_t>;
template class Viota_m<uint16_t>;
template class Viota_m<uint32_t>;
template class Viota_m<uint64_t>;
;


// VectorIntFormat::vid_v((['\n                        Vd_vu[i] = ei;\n                    ', 'OPMVV', 'SimdMiscOp'], {}))


template<typename ElemType>
Vid_vMicro<ElemType>::Vid_vMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vid_v_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vid_vMicro<uint8_t>;
template class Vid_vMicro<uint16_t>;
template class Vid_vMicro<uint32_t>;
template class Vid_vMicro<uint64_t>;
;



template<typename ElemType>
Vid_v<ElemType>::Vid_v(ExtMachInst _machInst, uint32_t _vlen)
    : VectorVMUNARY0MacroInst("vid_v", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vid_vMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vid_v<uint8_t>;
template class Vid_v<uint16_t>;
template class Vid_v<uint32_t>;
template class Vid_v<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorMaskFormat::vmandn_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) & !elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Vmandn_mm<ElemType>::Vmandn_mm(ExtMachInst _machInst)
    : VectorNonSplitInst("vmandn_mm", _machInst, SimdAluOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
}

template class Vmandn_mm<uint8_t>;
;


// VectorMaskFormat::vmand_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) & elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Vmand_mm<ElemType>::Vmand_mm(ExtMachInst _machInst)
    : VectorNonSplitInst("vmand_mm", _machInst, SimdAluOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
}

template class Vmand_mm<uint8_t>;
;


// VectorMaskFormat::vmor_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) | elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Vmor_mm<ElemType>::Vmor_mm(ExtMachInst _machInst)
    : VectorNonSplitInst("vmor_mm", _machInst, SimdAluOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
}

template class Vmor_mm<uint8_t>;
;


// VectorMaskFormat::vmxor_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) ^ elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Vmxor_mm<ElemType>::Vmxor_mm(ExtMachInst _machInst)
    : VectorNonSplitInst("vmxor_mm", _machInst, SimdAluOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
}

template class Vmxor_mm<uint8_t>;
;


// VectorMaskFormat::vmorn_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            elem_mask(Vs2_vu, i) | !elem_mask(Vs1_vu, i));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Vmorn_mm<ElemType>::Vmorn_mm(ExtMachInst _machInst)
    : VectorNonSplitInst("vmorn_mm", _machInst, SimdAluOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
}

template class Vmorn_mm<uint8_t>;
;


// VectorMaskFormat::vmnand_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            !(elem_mask(Vs2_vu, i) & elem_mask(Vs1_vu, i)));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Vmnand_mm<ElemType>::Vmnand_mm(ExtMachInst _machInst)
    : VectorNonSplitInst("vmnand_mm", _machInst, SimdAluOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
}

template class Vmnand_mm<uint8_t>;
;


// VectorMaskFormat::vmnor_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            !(elem_mask(Vs2_vu, i) | elem_mask(Vs1_vu, i)));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Vmnor_mm<ElemType>::Vmnor_mm(ExtMachInst _machInst)
    : VectorNonSplitInst("vmnor_mm", _machInst, SimdAluOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
}

template class Vmnor_mm<uint8_t>;
;


// VectorMaskFormat::vmxnor_mm(['\n                        Vd_ub[i/8] = ASSIGN_VD_BIT(i,\n                            !(elem_mask(Vs2_vu, i) ^ elem_mask(Vs1_vu, i)));\n                    ', 'OPMVV', 'SimdAluOp'],{})


template<typename ElemType>
Vmxnor_mm<ElemType>::Vmxnor_mm(ExtMachInst _machInst)
    : VectorNonSplitInst("vmxnor_mm", _machInst, SimdAluOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2]);
;
}

template class Vmxnor_mm<uint8_t>;
;


// VectorIntFormat::vdivu_vv(['\n                        Vd_vu[i] = divu<vu>(Vs2_vu[i], Vs1_vu[i]);\n                    ', 'OPMVV', 'SimdDivOp'],{})


template<typename ElemType>
Vdivu_vvMicro<ElemType>::Vdivu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vdivu_vv_micro", _machInst,
                     SimdDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vdivu_vvMicro<uint8_t>;
template class Vdivu_vvMicro<uint16_t>;
template class Vdivu_vvMicro<uint32_t>;
template class Vdivu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vdivu_vv<ElemType>::Vdivu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vdivu_vv", _machInst, SimdDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vdivu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vdivu_vv<uint8_t>;
template class Vdivu_vv<uint16_t>;
template class Vdivu_vv<uint32_t>;
template class Vdivu_vv<uint64_t>;
;


// VectorIntFormat::vdiv_vv(['\n                        Vd_vi[i] = div<vi>(Vs2_vi[i], Vs1_vi[i]);\n                    ', 'OPMVV', 'SimdDivOp'],{})


template<typename ElemType>
Vdiv_vvMicro<ElemType>::Vdiv_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vdiv_vv_micro", _machInst,
                     SimdDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vdiv_vvMicro<uint8_t>;
template class Vdiv_vvMicro<uint16_t>;
template class Vdiv_vvMicro<uint32_t>;
template class Vdiv_vvMicro<uint64_t>;
;



template<typename ElemType>
Vdiv_vv<ElemType>::Vdiv_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vdiv_vv", _machInst, SimdDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vdiv_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vdiv_vv<uint8_t>;
template class Vdiv_vv<uint16_t>;
template class Vdiv_vv<uint32_t>;
template class Vdiv_vv<uint64_t>;
;


// VectorIntFormat::vremu_vv(['\n                        Vd_vu[i] = remu<vu>(Vs2_vu[i], Vs1_vu[i]);\n                    ', 'OPMVV', 'SimdDivOp'],{})


template<typename ElemType>
Vremu_vvMicro<ElemType>::Vremu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vremu_vv_micro", _machInst,
                     SimdDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vremu_vvMicro<uint8_t>;
template class Vremu_vvMicro<uint16_t>;
template class Vremu_vvMicro<uint32_t>;
template class Vremu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vremu_vv<ElemType>::Vremu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vremu_vv", _machInst, SimdDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vremu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vremu_vv<uint8_t>;
template class Vremu_vv<uint16_t>;
template class Vremu_vv<uint32_t>;
template class Vremu_vv<uint64_t>;
;


// VectorIntFormat::vrem_vv(['\n                        Vd_vi[i] = rem<vi>(Vs2_vi[i], Vs1_vi[i]);\n                    ', 'OPMVV', 'SimdDivOp'],{})


template<typename ElemType>
Vrem_vvMicro<ElemType>::Vrem_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vrem_vv_micro", _machInst,
                     SimdDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vrem_vvMicro<uint8_t>;
template class Vrem_vvMicro<uint16_t>;
template class Vrem_vvMicro<uint32_t>;
template class Vrem_vvMicro<uint64_t>;
;



template<typename ElemType>
Vrem_vv<ElemType>::Vrem_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vrem_vv", _machInst, SimdDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vrem_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vrem_vv<uint8_t>;
template class Vrem_vv<uint16_t>;
template class Vrem_vv<uint32_t>;
template class Vrem_vv<uint64_t>;
;


// VectorIntFormat::vmulhu_vv(['\n                        Vd_vu[i] = mulhu<vu>(Vs2_vu[i], Vs1_vu[i]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template<typename ElemType>
Vmulhu_vvMicro<ElemType>::Vmulhu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmulhu_vv_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmulhu_vvMicro<uint8_t>;
template class Vmulhu_vvMicro<uint16_t>;
template class Vmulhu_vvMicro<uint32_t>;
template class Vmulhu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmulhu_vv<ElemType>::Vmulhu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmulhu_vv", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmulhu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmulhu_vv<uint8_t>;
template class Vmulhu_vv<uint16_t>;
template class Vmulhu_vv<uint32_t>;
template class Vmulhu_vv<uint64_t>;
;


// VectorIntFormat::vmul_vv(['\n                        Vd_vi[i] = Vs2_vi[i] * Vs1_vi[i];\n                    ', 'OPMVV', 'SimdMultOp'],{})


template<typename ElemType>
Vmul_vvMicro<ElemType>::Vmul_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmul_vv_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmul_vvMicro<uint8_t>;
template class Vmul_vvMicro<uint16_t>;
template class Vmul_vvMicro<uint32_t>;
template class Vmul_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmul_vv<ElemType>::Vmul_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmul_vv", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmul_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmul_vv<uint8_t>;
template class Vmul_vv<uint16_t>;
template class Vmul_vv<uint32_t>;
template class Vmul_vv<uint64_t>;
;


// VectorIntFormat::vmulhsu_vv(['\n                        Vd_vi[i] = mulhsu<vi>(Vs2_vi[i], Vs1_vu[i]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template<typename ElemType>
Vmulhsu_vvMicro<ElemType>::Vmulhsu_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmulhsu_vv_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmulhsu_vvMicro<uint8_t>;
template class Vmulhsu_vvMicro<uint16_t>;
template class Vmulhsu_vvMicro<uint32_t>;
template class Vmulhsu_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmulhsu_vv<ElemType>::Vmulhsu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmulhsu_vv", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmulhsu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmulhsu_vv<uint8_t>;
template class Vmulhsu_vv<uint16_t>;
template class Vmulhsu_vv<uint32_t>;
template class Vmulhsu_vv<uint64_t>;
;


// VectorIntFormat::vmulh_vv(['\n                        Vd_vi[i] = mulh<vi>(Vs2_vi[i], Vs1_vi[i]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template<typename ElemType>
Vmulh_vvMicro<ElemType>::Vmulh_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmulh_vv_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmulh_vvMicro<uint8_t>;
template class Vmulh_vvMicro<uint16_t>;
template class Vmulh_vvMicro<uint32_t>;
template class Vmulh_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmulh_vv<ElemType>::Vmulh_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmulh_vv", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmulh_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmulh_vv<uint8_t>;
template class Vmulh_vv<uint16_t>;
template class Vmulh_vv<uint32_t>;
template class Vmulh_vv<uint64_t>;
;


// VectorIntFormat::vmadd_vv(['\n                        Vd_vi[i] = Vs3_vi[i] * Vs1_vi[i] + Vs2_vi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template<typename ElemType>
Vmadd_vvMicro<ElemType>::Vmadd_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmadd_vv_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmadd_vvMicro<uint8_t>;
template class Vmadd_vvMicro<uint16_t>;
template class Vmadd_vvMicro<uint32_t>;
template class Vmadd_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmadd_vv<ElemType>::Vmadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmadd_vv", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmadd_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmadd_vv<uint8_t>;
template class Vmadd_vv<uint16_t>;
template class Vmadd_vv<uint32_t>;
template class Vmadd_vv<uint64_t>;
;


// VectorIntFormat::vnmsub_vv(['\n                        Vd_vi[i] = -(Vs3_vi[i] * Vs1_vi[i]) + Vs2_vi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template<typename ElemType>
Vnmsub_vvMicro<ElemType>::Vnmsub_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnmsub_vv_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnmsub_vvMicro<uint8_t>;
template class Vnmsub_vvMicro<uint16_t>;
template class Vnmsub_vvMicro<uint32_t>;
template class Vnmsub_vvMicro<uint64_t>;
;



template<typename ElemType>
Vnmsub_vv<ElemType>::Vnmsub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnmsub_vv", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnmsub_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnmsub_vv<uint8_t>;
template class Vnmsub_vv<uint16_t>;
template class Vnmsub_vv<uint32_t>;
template class Vnmsub_vv<uint64_t>;
;


// VectorIntFormat::vmacc_vv(['\n                        Vd_vi[i] = Vs2_vi[i] * Vs1_vi[i] + Vs3_vi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template<typename ElemType>
Vmacc_vvMicro<ElemType>::Vmacc_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmacc_vv_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmacc_vvMicro<uint8_t>;
template class Vmacc_vvMicro<uint16_t>;
template class Vmacc_vvMicro<uint32_t>;
template class Vmacc_vvMicro<uint64_t>;
;



template<typename ElemType>
Vmacc_vv<ElemType>::Vmacc_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmacc_vv", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmacc_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmacc_vv<uint8_t>;
template class Vmacc_vv<uint16_t>;
template class Vmacc_vv<uint32_t>;
template class Vmacc_vv<uint64_t>;
;


// VectorIntFormat::vnmsac_vv(['\n                        Vd_vi[i] = -(Vs2_vi[i] * Vs1_vi[i]) + Vs3_vi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template<typename ElemType>
Vnmsac_vvMicro<ElemType>::Vnmsac_vvMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnmsac_vv_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnmsac_vvMicro<uint8_t>;
template class Vnmsac_vvMicro<uint16_t>;
template class Vnmsac_vvMicro<uint32_t>;
template class Vnmsac_vvMicro<uint64_t>;
;



template<typename ElemType>
Vnmsac_vv<ElemType>::Vnmsac_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnmsac_vv", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnmsac_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnmsac_vv<uint8_t>;
template class Vnmsac_vv<uint16_t>;
template class Vnmsac_vv<uint32_t>;
template class Vnmsac_vv<uint64_t>;
;


// VectorIntWideningFormat::vwaddu_vv(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset])\n                                + vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vwaddu_vvMicro<ElemType>::Vwaddu_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwaddu_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwaddu_vvMicro<uint8_t>;
template class Vwaddu_vvMicro<uint16_t>;
template class Vwaddu_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwaddu_vv<ElemType>::Vwaddu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwaddu_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwaddu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwaddu_vv<uint8_t>;
template class Vwaddu_vv<uint16_t>;
template class Vwaddu_vv<uint32_t>;
;


// VectorIntWideningFormat::vwadd_vv(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset])\n                                + vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vwadd_vvMicro<ElemType>::Vwadd_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwadd_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwadd_vvMicro<uint8_t>;
template class Vwadd_vvMicro<uint16_t>;
template class Vwadd_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwadd_vv<ElemType>::Vwadd_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwadd_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwadd_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwadd_vv<uint8_t>;
template class Vwadd_vv<uint16_t>;
template class Vwadd_vv<uint32_t>;
;


// VectorIntWideningFormat::vwsubu_vv(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset])\n                                - vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vwsubu_vvMicro<ElemType>::Vwsubu_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwsubu_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwsubu_vvMicro<uint8_t>;
template class Vwsubu_vvMicro<uint16_t>;
template class Vwsubu_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwsubu_vv<ElemType>::Vwsubu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwsubu_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwsubu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwsubu_vv<uint8_t>;
template class Vwsubu_vv<uint16_t>;
template class Vwsubu_vv<uint32_t>;
;


// VectorIntWideningFormat::vwsub_vv(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset])\n                                - vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vwsub_vvMicro<ElemType>::Vwsub_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwsub_vv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwsub_vvMicro<uint8_t>;
template class Vwsub_vvMicro<uint16_t>;
template class Vwsub_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwsub_vv<ElemType>::Vwsub_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwsub_vv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwsub_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwsub_vv<uint8_t>;
template class Vwsub_vv<uint16_t>;
template class Vwsub_vv<uint32_t>;
;


// VectorIntWideningFormat::vwaddu_wv(['\n                        Vd_vwu[i] = Vs2_vwu[i] + vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vwaddu_wvMicro<ElemType>::Vwaddu_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwaddu_wv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwaddu_wvMicro<uint8_t>;
template class Vwaddu_wvMicro<uint16_t>;
template class Vwaddu_wvMicro<uint32_t>;
;



template<typename ElemType>
Vwaddu_wv<ElemType>::Vwaddu_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwaddu_wv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwaddu_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwaddu_wv<uint8_t>;
template class Vwaddu_wv<uint16_t>;
template class Vwaddu_wv<uint32_t>;
;


// VectorIntWideningFormat::vwadd_wv(['\n                        Vd_vwi[i] = Vs2_vwi[i] + vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vwadd_wvMicro<ElemType>::Vwadd_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwadd_wv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwadd_wvMicro<uint8_t>;
template class Vwadd_wvMicro<uint16_t>;
template class Vwadd_wvMicro<uint32_t>;
;



template<typename ElemType>
Vwadd_wv<ElemType>::Vwadd_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwadd_wv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwadd_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwadd_wv<uint8_t>;
template class Vwadd_wv<uint16_t>;
template class Vwadd_wv<uint32_t>;
;


// VectorIntWideningFormat::vwsubu_wv(['\n                        Vd_vwu[i] = Vs2_vwu[i] - vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vwsubu_wvMicro<ElemType>::Vwsubu_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwsubu_wv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwsubu_wvMicro<uint8_t>;
template class Vwsubu_wvMicro<uint16_t>;
template class Vwsubu_wvMicro<uint32_t>;
;



template<typename ElemType>
Vwsubu_wv<ElemType>::Vwsubu_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwsubu_wv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwsubu_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwsubu_wv<uint8_t>;
template class Vwsubu_wv<uint16_t>;
template class Vwsubu_wv<uint32_t>;
;


// VectorIntWideningFormat::vwsub_wv(['\n                        Vd_vwi[i] = Vs2_vwi[i] - vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdAddOp'],{})


template<typename ElemType>
Vwsub_wvMicro<ElemType>::Vwsub_wvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwsub_wv_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwsub_wvMicro<uint8_t>;
template class Vwsub_wvMicro<uint16_t>;
template class Vwsub_wvMicro<uint32_t>;
;



template<typename ElemType>
Vwsub_wv<ElemType>::Vwsub_wv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwsub_wv", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwsub_wvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwsub_wv<uint8_t>;
template class Vwsub_wv<uint16_t>;
template class Vwsub_wv<uint32_t>;
;


// VectorIntWideningFormat::vwmulu_vv(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset])\n                                * vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template<typename ElemType>
Vwmulu_vvMicro<ElemType>::Vwmulu_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmulu_vv_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmulu_vvMicro<uint8_t>;
template class Vwmulu_vvMicro<uint16_t>;
template class Vwmulu_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwmulu_vv<ElemType>::Vwmulu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmulu_vv", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmulu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmulu_vv<uint8_t>;
template class Vwmulu_vv<uint16_t>;
template class Vwmulu_vv<uint32_t>;
;


// VectorIntWideningFormat::vwmulsu_vv(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset])\n                                * vwu(Vs1_vu[i + offset]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template<typename ElemType>
Vwmulsu_vvMicro<ElemType>::Vwmulsu_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmulsu_vv_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmulsu_vvMicro<uint8_t>;
template class Vwmulsu_vvMicro<uint16_t>;
template class Vwmulsu_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwmulsu_vv<ElemType>::Vwmulsu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmulsu_vv", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmulsu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmulsu_vv<uint8_t>;
template class Vwmulsu_vv<uint16_t>;
template class Vwmulsu_vv<uint32_t>;
;


// VectorIntWideningFormat::vwmul_vv(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset])\n                                * vwi(Vs1_vi[i + offset]);\n                    ', 'OPMVV', 'SimdMultOp'],{})


template<typename ElemType>
Vwmul_vvMicro<ElemType>::Vwmul_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmul_vv_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmul_vvMicro<uint8_t>;
template class Vwmul_vvMicro<uint16_t>;
template class Vwmul_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwmul_vv<ElemType>::Vwmul_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmul_vv", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmul_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmul_vv<uint8_t>;
template class Vwmul_vv<uint16_t>;
template class Vwmul_vv<uint32_t>;
;


// VectorIntWideningFormat::vwmaccu_vv(['\n                        Vd_vwu[i] = vwu(Vs1_vu[i + offset])\n                                * vwu(Vs2_vu[i + offset])\n                                + Vs3_vwu[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template<typename ElemType>
Vwmaccu_vvMicro<ElemType>::Vwmaccu_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmaccu_vv_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmaccu_vvMicro<uint8_t>;
template class Vwmaccu_vvMicro<uint16_t>;
template class Vwmaccu_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwmaccu_vv<ElemType>::Vwmaccu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmaccu_vv", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmaccu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmaccu_vv<uint8_t>;
template class Vwmaccu_vv<uint16_t>;
template class Vwmaccu_vv<uint32_t>;
;


// VectorIntWideningFormat::vwmacc_vv(['\n                        Vd_vwi[i] = vwi(Vs1_vi[i + offset])\n                                * vwi(Vs2_vi[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template<typename ElemType>
Vwmacc_vvMicro<ElemType>::Vwmacc_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmacc_vv_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmacc_vvMicro<uint8_t>;
template class Vwmacc_vvMicro<uint16_t>;
template class Vwmacc_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwmacc_vv<ElemType>::Vwmacc_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmacc_vv", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmacc_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmacc_vv<uint8_t>;
template class Vwmacc_vv<uint16_t>;
template class Vwmacc_vv<uint32_t>;
;


// VectorIntWideningFormat::vwmaccsu_vv(['\n                        Vd_vwi[i] = vwi(Vs1_vi[i + offset])\n                                * vwu(Vs2_vu[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVV', 'SimdMultAccOp'],{})


template<typename ElemType>
Vwmaccsu_vvMicro<ElemType>::Vwmaccsu_vvMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmaccsu_vv_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs1 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmaccsu_vvMicro<uint8_t>;
template class Vwmaccsu_vvMicro<uint16_t>;
template class Vwmaccsu_vvMicro<uint32_t>;
;



template<typename ElemType>
Vwmaccsu_vv<ElemType>::Vwmaccsu_vv(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmaccsu_vv", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmaccsu_vvMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmaccsu_vv<uint8_t>;
template class Vwmaccsu_vv<uint16_t>;
template class Vwmaccsu_vv<uint32_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vadd_vi(['\n                        Vd_vi[i] = Vs2_vi[i] + (vi)sext<5>(SIMM5);\n                    ', 'OPIVI', 'SimdAddOp'],{})


template<typename ElemType>
Vadd_viMicro<ElemType>::Vadd_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vadd_vi_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vadd_viMicro<uint8_t>;
template class Vadd_viMicro<uint16_t>;
template class Vadd_viMicro<uint32_t>;
template class Vadd_viMicro<uint64_t>;
;



template<typename ElemType>
Vadd_vi<ElemType>::Vadd_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vadd_vi", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vadd_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vadd_vi<uint8_t>;
template class Vadd_vi<uint16_t>;
template class Vadd_vi<uint32_t>;
template class Vadd_vi<uint64_t>;
;


// VectorIntFormat::vrsub_vi(['\n                        Vd_vi[i] = (vi)sext<5>(SIMM5) - Vs2_vi[i];\n                    ', 'OPIVI', 'SimdAddOp'],{})


template<typename ElemType>
Vrsub_viMicro<ElemType>::Vrsub_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vrsub_vi_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vrsub_viMicro<uint8_t>;
template class Vrsub_viMicro<uint16_t>;
template class Vrsub_viMicro<uint32_t>;
template class Vrsub_viMicro<uint64_t>;
;



template<typename ElemType>
Vrsub_vi<ElemType>::Vrsub_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vrsub_vi", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vrsub_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vrsub_vi<uint8_t>;
template class Vrsub_vi<uint16_t>;
template class Vrsub_vi<uint32_t>;
template class Vrsub_vi<uint64_t>;
;


// VectorIntFormat::vand_vi(['\n                        Vd_vi[i] = Vs2_vi[i] & (vi)sext<5>(SIMM5);\n                    ', 'OPIVI', 'SimdAluOp'],{})


template<typename ElemType>
Vand_viMicro<ElemType>::Vand_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vand_vi_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vand_viMicro<uint8_t>;
template class Vand_viMicro<uint16_t>;
template class Vand_viMicro<uint32_t>;
template class Vand_viMicro<uint64_t>;
;



template<typename ElemType>
Vand_vi<ElemType>::Vand_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vand_vi", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vand_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vand_vi<uint8_t>;
template class Vand_vi<uint16_t>;
template class Vand_vi<uint32_t>;
template class Vand_vi<uint64_t>;
;


// VectorIntFormat::vor_vi(['\n                        Vd_vi[i] = Vs2_vi[i] | (vi)sext<5>(SIMM5);\n                    ', 'OPIVI', 'SimdAluOp'],{})


template<typename ElemType>
Vor_viMicro<ElemType>::Vor_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vor_vi_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vor_viMicro<uint8_t>;
template class Vor_viMicro<uint16_t>;
template class Vor_viMicro<uint32_t>;
template class Vor_viMicro<uint64_t>;
;



template<typename ElemType>
Vor_vi<ElemType>::Vor_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vor_vi", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vor_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vor_vi<uint8_t>;
template class Vor_vi<uint16_t>;
template class Vor_vi<uint32_t>;
template class Vor_vi<uint64_t>;
;


// VectorIntFormat::vxor_vi(['\n                        Vd_vi[i] = Vs2_vi[i] ^ (vi)sext<5>(SIMM5);\n                    ', 'OPIVI', 'SimdAluOp'],{})


template<typename ElemType>
Vxor_viMicro<ElemType>::Vxor_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vxor_vi_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vxor_viMicro<uint8_t>;
template class Vxor_viMicro<uint16_t>;
template class Vxor_viMicro<uint32_t>;
template class Vxor_viMicro<uint64_t>;
;



template<typename ElemType>
Vxor_vi<ElemType>::Vxor_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vxor_vi", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vxor_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vxor_vi<uint8_t>;
template class Vxor_vi<uint16_t>;
template class Vxor_vi<uint32_t>;
template class Vxor_vi<uint64_t>;
;


// VectorGatherFormat::vrgather_vi((['\n                    for (uint32_t i = 0; i < microVl; i++) {\n                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;\n                        uint64_t zextImm = rvZext(SIMM5);\n                        if (this->vm || elem_mask(v0, ei)) {\n                            const uint64_t idx = zextImm - vs2_elems * vs2_idx;\n                            if (zextImm >= vlmax)\n                                Vd_vu[i] = 0;\n                            else if (idx < vs2_elems)\n                                Vd_vu[i] = Vs2_vu[idx];\n                        }\n                    }\n                ', 'OPIVI', 'SimdMiscOp'], {}))


template<typename ElemType, typename IndexType>
Vrgather_viMicro<ElemType, IndexType>::Vrgather_viMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vrgather_vi_micro", _machInst,
                 SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    [[maybe_unused]] constexpr uint32_t vd_eewb = sizeof(ElemType);
    [[maybe_unused]] constexpr uint32_t vs2_eewb = sizeof(ElemType);
    [[maybe_unused]] constexpr uint32_t vs1_eewb = sizeof(IndexType);
    constexpr uint32_t vs1_split_num = (vd_eewb + vs1_eewb - 1) / vs1_eewb;
    constexpr uint32_t vd_split_num = (vs1_eewb + vd_eewb - 1) / vd_eewb;
    const int8_t lmul = vtype_vlmul(vtype);
    const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    [[maybe_unused]] const uint32_t vs2_idx = _microIdx % vs2_vregs;
    [[maybe_unused]] const uint32_t vs1_idx =
        _microIdx / vs2_vregs / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_idx =
        _microIdx / vs2_vregs / vd_split_num;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vd_idx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2_idx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + vd_idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vrgather_viMicro<uint8_t, uint8_t>;
template class Vrgather_viMicro<uint16_t, uint16_t>;
template class Vrgather_viMicro<uint32_t, uint32_t>;
template class Vrgather_viMicro<uint64_t, uint64_t>;
;



template<typename ElemType, typename IndexType>
Vrgather_vi<ElemType, IndexType>::Vrgather_vi(ExtMachInst _machInst,
    uint32_t _vlen)
    : VectorArithMacroInst("vrgather_vi", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    constexpr uint32_t vd_eewb = sizeof(ElemType);
    constexpr uint32_t vs2_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_eewb = sizeof(IndexType);
    const int8_t lmul = vtype_vlmul(vtype);
    const int8_t vs1_emul = lmul + __builtin_ctz(vs1_eewb)
                                 - __builtin_ctz(vs2_eewb);
    const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    const uint8_t vs1_vregs = vs1_emul < 0 ? 1 : 1 << vs1_emul;
    const uint8_t vd_vregs = vs2_vregs;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs1_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    uint32_t vd_vlmax = vlenb / vd_eewb;
    uint32_t vs1_vlmax = vlenb / vs1_eewb;
    for (uint32_t i = 0; i < ceil((float) this->vl / vd_vlmax); i++) {
        uint32_t pinvd_micro_vl = (vd_vlmax*(i+1) <= remaining_vl)
                                  ? vd_vlmax : remaining_vl;
        uint8_t num_vd_pins = ceil((float) pinvd_micro_vl/vs1_vlmax)*vs2_vregs;
        microop = new VPinVdMicroInst(machInst, i, num_vd_pins);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        remaining_vl -= pinvd_micro_vl;
    }

    remaining_vl = this->vl;
    for (uint32_t i = 0; i < std::max(vs1_vregs, vd_vregs) && micro_vl > 0;
            i++) {
        for (uint8_t j = 0; j < vs2_vregs; j++) {
            microop = new Vrgather_viMicro<ElemType, IndexType>(
                _machInst, micro_vl, i * vs2_vregs + j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vrgather_vi<uint8_t, uint8_t>;
template class Vrgather_vi<uint16_t, uint16_t>;
template class Vrgather_vi<uint32_t, uint32_t>;
template class Vrgather_vi<uint64_t, uint64_t>;
;


// VectorSlideUpFormat::vslideup_vi((['\n                    const int offset = (int)(uint64_t)(SIMM5);\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vdIdx - vs2Idx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int elemOffset = vdOffset + vdIdx * microVlmax;\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            if (this->vm || elem_mask(v0, i + elemOffset)) {\n                                Vd_vu[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                            }\n                        }\n                    }\n                ', 'OPIVI', 'SimdMiscOp'], {}))


template<typename ElemType>
Vslideup_viMicro<ElemType>::Vslideup_viMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx, uint32_t _vdIdx,
        uint32_t _vs2Idx)
    : VectorSlideMicroInst("vslideup_vi_micro", _machInst, SimdMiscOp, _microVl,
        _microIdx, _vdIdx, _vs2Idx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vdIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2Idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vslideup_viMicro<uint8_t>;
template class Vslideup_viMicro<uint16_t>;
template class Vslideup_viMicro<uint32_t>;
template class Vslideup_viMicro<uint64_t>;
;



template<typename ElemType>
Vslideup_vi<ElemType>::Vslideup_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorSlideMacroInst("vslideup_vi", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; i < ceil((float) this->vl/micro_vlmax); i++) {
        microop = new VPinVdMicroInst(machInst, i, i+1, true);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    // Todo static filter out useless uop
    int micro_idx = 0;
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        for (int j = 0; j <= i; ++j) {
            microop = new Vslideup_viMicro<ElemType>(
                _machInst, micro_vl, micro_idx++, i, j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vslideup_vi<uint8_t>;
template class Vslideup_vi<uint16_t>;
template class Vslideup_vi<uint32_t>;
template class Vslideup_vi<uint64_t>;
;


// VectorSlideDownFormat::vslidedown_vi((['\n                    const int offset = (int)(uint64_t)(SIMM5);\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vs2Idx - vdIdx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    const int numVs2s = vtype_regs_per_group(vtype);\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const bool needZeroTail = numVs2s == vs2Idx + 1;\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int elemIdxBase = vdIdx * microVlmax;\n                        vreg_t resVreg;\n                        auto res = resVreg.as<vu>();\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            res[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                        }\n                        if (needZeroTail) {\n                            for (int i = upperBound + vdOffset;\n                                i < microVlmax; i++) {\n                                res[i] = 0;\n                            }\n                        }\n                        for (int i = vdOffset; i < microVl ; i++) {\n                            if (vm || elem_mask(v0, i + elemIdxBase)) {\n                                Vd_vu[i] = res[i];\n                            }\n                        }\n                    }\n                ', 'OPIVI', 'SimdMiscOp'], {}))


template<typename ElemType>
Vslidedown_viMicro<ElemType>::Vslidedown_viMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx, uint32_t _vdIdx,
        uint32_t _vs2Idx)
    : VectorSlideMicroInst("vslidedown_vi_micro", _machInst, SimdMiscOp, _microVl,
        _microIdx, _vdIdx, _vs2Idx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vdIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2Idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vslidedown_viMicro<uint8_t>;
template class Vslidedown_viMicro<uint16_t>;
template class Vslidedown_viMicro<uint32_t>;
template class Vslidedown_viMicro<uint64_t>;
;



template<typename ElemType>
Vslidedown_vi<ElemType>::Vslidedown_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorSlideMacroInst("vslidedown_vi", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; i < ceil((float) this->vl / micro_vlmax); i++) {
        microop = new VPinVdMicroInst(machInst, i, num_microops-i, false);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    // Todo static filter out useless uop
    int micro_idx = 0;
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        for (int j = i; j < num_microops; ++j) {
            microop = new Vslidedown_viMicro<ElemType>(
                _machInst, micro_vl, micro_idx++, i, j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vslidedown_vi<uint8_t>;
template class Vslidedown_vi<uint16_t>;
template class Vslidedown_vi<uint32_t>;
template class Vslidedown_vi<uint64_t>;
;


// VectorIntFormat::vadc_vim(['\n                            Vd_vi[i] = Vs2_vi[i] +\n                                (vi)sext<5>(SIMM5) + elem_mask(v0, ei);\n                        ', 'OPIVI', 'SimdAddOp'],{})


template<typename ElemType>
Vadc_vimMicro<ElemType>::Vadc_vimMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vadc_vim_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vadc_vimMicro<uint8_t>;
template class Vadc_vimMicro<uint16_t>;
template class Vadc_vimMicro<uint32_t>;
template class Vadc_vimMicro<uint64_t>;
;



template<typename ElemType>
Vadc_vim<ElemType>::Vadc_vim(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vadc_vim", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vadc_vimMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vadc_vim<uint8_t>;
template class Vadc_vim<uint16_t>;
template class Vadc_vim<uint32_t>;
template class Vadc_vim<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vmerge_vim(['\n                            Vd_vi[i] = elem_mask(v0, ei)\n                                    ? (vi)sext<5>(SIMM5)\n                                    : Vs2_vi[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


template<typename ElemType>
Vmerge_vimMicro<ElemType>::Vmerge_vimMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmerge_vim_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmerge_vimMicro<uint8_t>;
template class Vmerge_vimMicro<uint16_t>;
template class Vmerge_vimMicro<uint32_t>;
template class Vmerge_vimMicro<uint64_t>;
;



template<typename ElemType>
Vmerge_vim<ElemType>::Vmerge_vim(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmerge_vim", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmerge_vimMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmerge_vim<uint8_t>;
template class Vmerge_vim<uint16_t>;
template class Vmerge_vim<uint32_t>;
template class Vmerge_vim<uint64_t>;
;


// VectorIntFormat::vmv_v_i(['\n                            Vd_vi[i] = (vi)sext<5>(SIMM5);\n                        ', 'OPIVI', 'SimdMiscOp'],{})


template<typename ElemType>
Vmv_v_iMicro<ElemType>::Vmv_v_iMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmv_v_i_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        ;
}

template class Vmv_v_iMicro<uint8_t>;
template class Vmv_v_iMicro<uint16_t>;
template class Vmv_v_iMicro<uint32_t>;
template class Vmv_v_iMicro<uint64_t>;
;



template<typename ElemType>
Vmv_v_i<ElemType>::Vmv_v_i(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmv_v_i", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmv_v_iMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmv_v_i<uint8_t>;
template class Vmv_v_i<uint16_t>;
template class Vmv_v_i<uint32_t>;
template class Vmv_v_i<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntVxsatFormat::vsaddu_vi(['\n                        Vd_vu[i] = sat_addu<vu>(Vs2_vu[i], (vu)sext<5>(SIMM5),\n                            vxsatptr);\n                    ', 'OPIVI', 'SimdAddOp'],{})


template<typename ElemType>
Vsaddu_viMicro<ElemType>::Vsaddu_viMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vsaddu_vi_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsaddu_viMicro<uint8_t>;
template class Vsaddu_viMicro<uint16_t>;
template class Vsaddu_viMicro<uint32_t>;
template class Vsaddu_viMicro<uint64_t>;
;



template<typename ElemType>
Vsaddu_vi<ElemType>::Vsaddu_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsaddu_vi", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsaddu_viMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsaddu_vi<uint8_t>;
template class Vsaddu_vi<uint16_t>;
template class Vsaddu_vi<uint32_t>;
template class Vsaddu_vi<uint64_t>;
;


// VectorIntVxsatFormat::vsadd_vi(['\n                        Vd_vi[i] = sat_add<vi>(Vs2_vi[i], (vi)sext<5>(SIMM5),\n                            vxsatptr);\n                    ', 'OPIVI', 'SimdAddOp'],{})


template<typename ElemType>
Vsadd_viMicro<ElemType>::Vsadd_viMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vsadd_vi_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsadd_viMicro<uint8_t>;
template class Vsadd_viMicro<uint16_t>;
template class Vsadd_viMicro<uint32_t>;
template class Vsadd_viMicro<uint64_t>;
;



template<typename ElemType>
Vsadd_vi<ElemType>::Vsadd_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsadd_vi", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsadd_viMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsadd_vi<uint8_t>;
template class Vsadd_vi<uint16_t>;
template class Vsadd_vi<uint32_t>;
template class Vsadd_vi<uint64_t>;
;


// VectorIntFormat::vsll_vi(['\n                        Vd_vu[i] = Vs2_vu[i] << ((vu)SIMM5 & (sew - 1) & 0x1f);\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template<typename ElemType>
Vsll_viMicro<ElemType>::Vsll_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsll_vi_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsll_viMicro<uint8_t>;
template class Vsll_viMicro<uint16_t>;
template class Vsll_viMicro<uint32_t>;
template class Vsll_viMicro<uint64_t>;
;



template<typename ElemType>
Vsll_vi<ElemType>::Vsll_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsll_vi", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsll_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsll_vi<uint8_t>;
template class Vsll_vi<uint16_t>;
template class Vsll_vi<uint32_t>;
template class Vsll_vi<uint64_t>;
;


// VectorIntFormat::vsrl_vi(['\n                        Vd_vu[i] = Vs2_vu[i] >> ((vu)SIMM5 & (sew - 1) & 0x1f);\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template<typename ElemType>
Vsrl_viMicro<ElemType>::Vsrl_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsrl_vi_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsrl_viMicro<uint8_t>;
template class Vsrl_viMicro<uint16_t>;
template class Vsrl_viMicro<uint32_t>;
template class Vsrl_viMicro<uint64_t>;
;



template<typename ElemType>
Vsrl_vi<ElemType>::Vsrl_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsrl_vi", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsrl_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsrl_vi<uint8_t>;
template class Vsrl_vi<uint16_t>;
template class Vsrl_vi<uint32_t>;
template class Vsrl_vi<uint64_t>;
;


// VectorIntFormat::vssrl_vi(['\n                        int sh = SIMM5 & (vtype_SEW(vtype) - 1);\n                        __uint128_t res = Vs2_vu[i];\n\n                        res = int_rounding<__uint128_t>(\n                            res, 0 /* TODO */, sh) >> sh;\n\n                        Vd_vu[i] = res;\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template<typename ElemType>
Vssrl_viMicro<ElemType>::Vssrl_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vssrl_vi_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssrl_viMicro<uint8_t>;
template class Vssrl_viMicro<uint16_t>;
template class Vssrl_viMicro<uint32_t>;
template class Vssrl_viMicro<uint64_t>;
;



template<typename ElemType>
Vssrl_vi<ElemType>::Vssrl_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssrl_vi", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssrl_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssrl_vi<uint8_t>;
template class Vssrl_vi<uint16_t>;
template class Vssrl_vi<uint32_t>;
template class Vssrl_vi<uint64_t>;
;


// VectorIntFormat::vsra_vi(['\n                        Vd_vi[i] = Vs2_vi[i] >> ((vu)SIMM5 & (sew - 1) & 0x1f);\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template<typename ElemType>
Vsra_viMicro<ElemType>::Vsra_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsra_vi_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsra_viMicro<uint8_t>;
template class Vsra_viMicro<uint16_t>;
template class Vsra_viMicro<uint32_t>;
template class Vsra_viMicro<uint64_t>;
;



template<typename ElemType>
Vsra_vi<ElemType>::Vsra_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsra_vi", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsra_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsra_vi<uint8_t>;
template class Vsra_vi<uint16_t>;
template class Vsra_vi<uint32_t>;
template class Vsra_vi<uint64_t>;
;


// VectorIntFormat::vssra_vi(['\n                        int sh = SIMM5 & (sew - 1);\n                        __int128_t val = Vs2_vi[i];\n\n                        val = int_rounding<__int128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vi[i] = val >> sh;\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template<typename ElemType>
Vssra_viMicro<ElemType>::Vssra_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vssra_vi_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssra_viMicro<uint8_t>;
template class Vssra_viMicro<uint16_t>;
template class Vssra_viMicro<uint32_t>;
template class Vssra_viMicro<uint64_t>;
;



template<typename ElemType>
Vssra_vi<ElemType>::Vssra_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssra_vi", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssra_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssra_vi<uint8_t>;
template class Vssra_vi<uint16_t>;
template class Vssra_vi<uint32_t>;
template class Vssra_vi<uint64_t>;
;


// VMvWholeFormat::vmv1r_v(['\n                            Vd_ud[i] = Vs2_ud[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


Vmv1r_v::Vmv1r_v(ExtMachInst _machInst)
    : VMvWholeMacroInst("vmv1r_v", _machInst, SimdMiscOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = _machInst.simm3 + 1;
    StaticInstPtr microop;

    for (int i = 0; i < num_microops; ++i) {
        microop = new Vmv1r_vMicro(_machInst, 0, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}



Vmv1r_vMicro::Vmv1r_vMicro(ExtMachInst _machInst,
                               uint32_t _microVl, uint32_t _microIdx)
    : VMvWholeMicroInst("vmv1r_v_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
}


// VMvWholeFormat::vmv2r_v(['\n                            Vd_ud[i] = Vs2_ud[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


Vmv2r_v::Vmv2r_v(ExtMachInst _machInst)
    : VMvWholeMacroInst("vmv2r_v", _machInst, SimdMiscOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = _machInst.simm3 + 1;
    StaticInstPtr microop;

    for (int i = 0; i < num_microops; ++i) {
        microop = new Vmv2r_vMicro(_machInst, 0, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}



Vmv2r_vMicro::Vmv2r_vMicro(ExtMachInst _machInst,
                               uint32_t _microVl, uint32_t _microIdx)
    : VMvWholeMicroInst("vmv2r_v_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
}


// VMvWholeFormat::vmv4r_v(['\n                            Vd_ud[i] = Vs2_ud[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


Vmv4r_v::Vmv4r_v(ExtMachInst _machInst)
    : VMvWholeMacroInst("vmv4r_v", _machInst, SimdMiscOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = _machInst.simm3 + 1;
    StaticInstPtr microop;

    for (int i = 0; i < num_microops; ++i) {
        microop = new Vmv4r_vMicro(_machInst, 0, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}



Vmv4r_vMicro::Vmv4r_vMicro(ExtMachInst _machInst,
                               uint32_t _microVl, uint32_t _microIdx)
    : VMvWholeMicroInst("vmv4r_v_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
}


// VMvWholeFormat::vmv8r_v(['\n                            Vd_ud[i] = Vs2_ud[i];\n                        ', 'OPIVI', 'SimdMiscOp'],{})


Vmv8r_v::Vmv8r_v(ExtMachInst _machInst)
    : VMvWholeMacroInst("vmv8r_v", _machInst, SimdMiscOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = _machInst.simm3 + 1;
    StaticInstPtr microop;

    for (int i = 0; i < num_microops; ++i) {
        microop = new Vmv8r_vMicro(_machInst, 0, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}



Vmv8r_vMicro::Vmv8r_vMicro(ExtMachInst _machInst,
                               uint32_t _microVl, uint32_t _microIdx)
    : VMvWholeMicroInst("vmv8r_v_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
    _numTypedDestRegs[VecRegClass]++;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
}


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmadc_vim(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vi[i], (vi)sext<5>(SIMM5),\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVI', 'SimdAddOp'],{})


template<typename ElemType>
Vmadc_vimMicro<ElemType>::Vmadc_vimMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmadc_vim_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmadc_vimMicro<uint8_t>;
template class Vmadc_vimMicro<uint16_t>;
template class Vmadc_vimMicro<uint32_t>;
template class Vmadc_vimMicro<uint64_t>;
;



template<typename ElemType>
Vmadc_vim<ElemType>::Vmadc_vim(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmadc_vim", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmadc_vimMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmadc_vim<uint8_t>;
template class Vmadc_vim<uint16_t>;
template class Vmadc_vim<uint32_t>;
template class Vmadc_vim<uint64_t>;
;


// VectorIntMaskFormat::vmadc_vi(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vi[i], (vi)sext<5>(SIMM5)));\n                        ', 'OPIVI', 'SimdAddOp'],{})


template<typename ElemType>
Vmadc_viMicro<ElemType>::Vmadc_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmadc_vi_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
;
}

template class Vmadc_viMicro<uint8_t>;
template class Vmadc_viMicro<uint16_t>;
template class Vmadc_viMicro<uint32_t>;
template class Vmadc_viMicro<uint64_t>;
;



template<typename ElemType>
Vmadc_vi<ElemType>::Vmadc_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmadc_vi", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmadc_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmadc_vi<uint8_t>;
template class Vmadc_vi<uint16_t>;
template class Vmadc_vi<uint32_t>;
template class Vmadc_vi<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmseq_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] == (vi)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template<typename ElemType>
Vmseq_viMicro<ElemType>::Vmseq_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmseq_vi_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmseq_viMicro<uint8_t>;
template class Vmseq_viMicro<uint16_t>;
template class Vmseq_viMicro<uint32_t>;
template class Vmseq_viMicro<uint64_t>;
;



template<typename ElemType>
Vmseq_vi<ElemType>::Vmseq_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmseq_vi", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmseq_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmseq_vi<uint8_t>;
template class Vmseq_vi<uint16_t>;
template class Vmseq_vi<uint32_t>;
template class Vmseq_vi<uint64_t>;
;


// VectorIntMaskFormat::vmsne_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] != (vi)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsne_viMicro<ElemType>::Vmsne_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsne_vi_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsne_viMicro<uint8_t>;
template class Vmsne_viMicro<uint16_t>;
template class Vmsne_viMicro<uint32_t>;
template class Vmsne_viMicro<uint64_t>;
;



template<typename ElemType>
Vmsne_vi<ElemType>::Vmsne_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsne_vi", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsne_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsne_vi<uint8_t>;
template class Vmsne_vi<uint16_t>;
template class Vmsne_vi<uint32_t>;
template class Vmsne_vi<uint64_t>;
;


// VectorIntMaskFormat::vmsleu_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] <= (vu)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsleu_viMicro<ElemType>::Vmsleu_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsleu_vi_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsleu_viMicro<uint8_t>;
template class Vmsleu_viMicro<uint16_t>;
template class Vmsleu_viMicro<uint32_t>;
template class Vmsleu_viMicro<uint64_t>;
;



template<typename ElemType>
Vmsleu_vi<ElemType>::Vmsleu_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsleu_vi", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsleu_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsleu_vi<uint8_t>;
template class Vmsleu_vi<uint16_t>;
template class Vmsleu_vi<uint32_t>;
template class Vmsleu_vi<uint64_t>;
;


// VectorIntMaskFormat::vmsle_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] <= (vi)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsle_viMicro<ElemType>::Vmsle_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsle_vi_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsle_viMicro<uint8_t>;
template class Vmsle_viMicro<uint16_t>;
template class Vmsle_viMicro<uint32_t>;
template class Vmsle_viMicro<uint64_t>;
;



template<typename ElemType>
Vmsle_vi<ElemType>::Vmsle_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsle_vi", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsle_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsle_vi<uint8_t>;
template class Vmsle_vi<uint16_t>;
template class Vmsle_vi<uint32_t>;
template class Vmsle_vi<uint64_t>;
;


// VectorIntMaskFormat::vmsgtu_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] > (vu)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsgtu_viMicro<ElemType>::Vmsgtu_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsgtu_vi_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsgtu_viMicro<uint8_t>;
template class Vmsgtu_viMicro<uint16_t>;
template class Vmsgtu_viMicro<uint32_t>;
template class Vmsgtu_viMicro<uint64_t>;
;



template<typename ElemType>
Vmsgtu_vi<ElemType>::Vmsgtu_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsgtu_vi", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsgtu_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsgtu_vi<uint8_t>;
template class Vmsgtu_vi<uint16_t>;
template class Vmsgtu_vi<uint32_t>;
template class Vmsgtu_vi<uint64_t>;
;


// VectorIntMaskFormat::vmsgt_vi(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] > (vi)sext<5>(SIMM5)));\n                    ', 'OPIVI', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsgt_viMicro<ElemType>::Vmsgt_viMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsgt_vi_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsgt_viMicro<uint8_t>;
template class Vmsgt_viMicro<uint16_t>;
template class Vmsgt_viMicro<uint32_t>;
template class Vmsgt_viMicro<uint64_t>;
;



template<typename ElemType>
Vmsgt_vi<ElemType>::Vmsgt_vi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsgt_vi", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsgt_viMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsgt_vi<uint8_t>;
template class Vmsgt_vi<uint16_t>;
template class Vmsgt_vi<uint32_t>;
template class Vmsgt_vi<uint64_t>;
;


// VectorIntNarrowingFormat::vnsrl_wi(['\n                        Vd_vu[i + offset] = (vu)(Vs2_vwu[i] >>\n                                            ((vwu)SIMM5 & (sew * 2 - 1)));\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template<typename ElemType>
Vnsrl_wiMicro<ElemType>::Vnsrl_wiMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnsrl_wi_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnsrl_wiMicro<uint8_t>;
template class Vnsrl_wiMicro<uint16_t>;
template class Vnsrl_wiMicro<uint32_t>;
;



template<typename ElemType>
Vnsrl_wi<ElemType>::Vnsrl_wi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnsrl_wi", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnsrl_wiMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnsrl_wi<uint8_t>;
template class Vnsrl_wi<uint16_t>;
template class Vnsrl_wi<uint32_t>;
;


// VectorIntNarrowingFormat::vnsra_wi(['\n                        Vd_vi[i + offset] = (vi)(Vs2_vwi[i] >>\n                                            ((vwu)SIMM5 & (sew * 2 - 1)));\n                    ', 'OPIVI', 'SimdShiftOp'],{})


template<typename ElemType>
Vnsra_wiMicro<ElemType>::Vnsra_wiMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnsra_wi_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnsra_wiMicro<uint8_t>;
template class Vnsra_wiMicro<uint16_t>;
template class Vnsra_wiMicro<uint32_t>;
;



template<typename ElemType>
Vnsra_wi<ElemType>::Vnsra_wi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnsra_wi", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnsra_wiMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnsra_wi<uint8_t>;
template class Vnsra_wi<uint16_t>;
template class Vnsra_wi<uint32_t>;
;


// VectorIntNarrowingFormat::vnclipu_wi(['\n                        vu max = std::numeric_limits<vu>::max();\n                        uint64_t sign_mask =\n                            std::numeric_limits<uint64_t>::max() << sew;\n                        __uint128_t res = Vs2_vwu[i];\n                        unsigned shift = VS1 & ((sew * 2) - 1);\n\n                        res = int_rounding<__uint128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res & sign_mask) {\n                            // TODO: vxsat\n                            res = max;\n                        }\n\n                        Vd_vu[i + offset] = (vu)res;\n                    ', 'OPIVI', 'SimdCvtOp'],{})


template<typename ElemType>
Vnclipu_wiMicro<ElemType>::Vnclipu_wiMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnclipu_wi_micro", _machInst,
                     SimdCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnclipu_wiMicro<uint8_t>;
template class Vnclipu_wiMicro<uint16_t>;
template class Vnclipu_wiMicro<uint32_t>;
;



template<typename ElemType>
Vnclipu_wi<ElemType>::Vnclipu_wi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnclipu_wi", _machInst, SimdCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnclipu_wiMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnclipu_wi<uint8_t>;
template class Vnclipu_wi<uint16_t>;
template class Vnclipu_wi<uint32_t>;
;


// VectorIntNarrowingFormat::vnclip_wi(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        __int128_t res = Vs2_vwi[i];\n                        unsigned shift = VS1 & ((sew * 2) - 1);\n\n                        res = int_rounding<__int128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res < min) {\n                            res = min;\n                            // TODO: vxsat\n                        } else if (res > max) {\n                            res = max;\n                            // TODO: vxsat\n                        }\n\n                        Vd_vi[i + offset] = (vi)res;\n                    ', 'OPIVI', 'SimdCvtOp'],{})


template<typename ElemType>
Vnclip_wiMicro<ElemType>::Vnclip_wiMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnclip_wi_micro", _machInst,
                     SimdCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnclip_wiMicro<uint8_t>;
template class Vnclip_wiMicro<uint16_t>;
template class Vnclip_wiMicro<uint32_t>;
;



template<typename ElemType>
Vnclip_wi<ElemType>::Vnclip_wi(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnclip_wi", _machInst, SimdCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnclip_wiMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnclip_wi<uint8_t>;
template class Vnclip_wi<uint16_t>;
template class Vnclip_wi<uint32_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vadd_vx(['\n                        Vd_vu[i] = Vs2_vu[i] + Rs1_vu;\n                    ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vadd_vxMicro<ElemType>::Vadd_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vadd_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vadd_vxMicro<uint8_t>;
template class Vadd_vxMicro<uint16_t>;
template class Vadd_vxMicro<uint32_t>;
template class Vadd_vxMicro<uint64_t>;
;



template<typename ElemType>
Vadd_vx<ElemType>::Vadd_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vadd_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vadd_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vadd_vx<uint8_t>;
template class Vadd_vx<uint16_t>;
template class Vadd_vx<uint32_t>;
template class Vadd_vx<uint64_t>;
;


// VectorIntFormat::vsub_vx(['\n                        Vd_vu[i] = Vs2_vu[i] - Rs1_vu;\n                    ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vsub_vxMicro<ElemType>::Vsub_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsub_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsub_vxMicro<uint8_t>;
template class Vsub_vxMicro<uint16_t>;
template class Vsub_vxMicro<uint32_t>;
template class Vsub_vxMicro<uint64_t>;
;



template<typename ElemType>
Vsub_vx<ElemType>::Vsub_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsub_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsub_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsub_vx<uint8_t>;
template class Vsub_vx<uint16_t>;
template class Vsub_vx<uint32_t>;
template class Vsub_vx<uint64_t>;
;


// VectorIntFormat::vrsub_vx(['\n                        Vd_vu[i] = Rs1_vu - Vs2_vu[i];\n                    ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vrsub_vxMicro<ElemType>::Vrsub_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vrsub_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vrsub_vxMicro<uint8_t>;
template class Vrsub_vxMicro<uint16_t>;
template class Vrsub_vxMicro<uint32_t>;
template class Vrsub_vxMicro<uint64_t>;
;



template<typename ElemType>
Vrsub_vx<ElemType>::Vrsub_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vrsub_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vrsub_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vrsub_vx<uint8_t>;
template class Vrsub_vx<uint16_t>;
template class Vrsub_vx<uint32_t>;
template class Vrsub_vx<uint64_t>;
;


// VectorIntFormat::vminu_vx(['\n                        Vd_vu[i] = std::min(Vs2_vu[i], Rs1_vu);\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vminu_vxMicro<ElemType>::Vminu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vminu_vx_micro", _machInst,
                     SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vminu_vxMicro<uint8_t>;
template class Vminu_vxMicro<uint16_t>;
template class Vminu_vxMicro<uint32_t>;
template class Vminu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vminu_vx<ElemType>::Vminu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vminu_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vminu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vminu_vx<uint8_t>;
template class Vminu_vx<uint16_t>;
template class Vminu_vx<uint32_t>;
template class Vminu_vx<uint64_t>;
;


// VectorIntFormat::vmin_vx(['\n                        Vd_vi[i] = std::min(Vs2_vi[i], Rs1_vi);\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmin_vxMicro<ElemType>::Vmin_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmin_vx_micro", _machInst,
                     SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmin_vxMicro<uint8_t>;
template class Vmin_vxMicro<uint16_t>;
template class Vmin_vxMicro<uint32_t>;
template class Vmin_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmin_vx<ElemType>::Vmin_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmin_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmin_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmin_vx<uint8_t>;
template class Vmin_vx<uint16_t>;
template class Vmin_vx<uint32_t>;
template class Vmin_vx<uint64_t>;
;


// VectorIntFormat::vmaxu_vx(['\n                        Vd_vu[i] = std::max(Vs2_vu[i], Rs1_vu);\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmaxu_vxMicro<ElemType>::Vmaxu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmaxu_vx_micro", _machInst,
                     SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmaxu_vxMicro<uint8_t>;
template class Vmaxu_vxMicro<uint16_t>;
template class Vmaxu_vxMicro<uint32_t>;
template class Vmaxu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmaxu_vx<ElemType>::Vmaxu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmaxu_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmaxu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmaxu_vx<uint8_t>;
template class Vmaxu_vx<uint16_t>;
template class Vmaxu_vx<uint32_t>;
template class Vmaxu_vx<uint64_t>;
;


// VectorIntFormat::vmax_vx(['\n                        Vd_vi[i] = std::max(Vs2_vi[i], Rs1_vi);\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmax_vxMicro<ElemType>::Vmax_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmax_vx_micro", _machInst,
                     SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmax_vxMicro<uint8_t>;
template class Vmax_vxMicro<uint16_t>;
template class Vmax_vxMicro<uint32_t>;
template class Vmax_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmax_vx<ElemType>::Vmax_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmax_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmax_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmax_vx<uint8_t>;
template class Vmax_vx<uint16_t>;
template class Vmax_vx<uint32_t>;
template class Vmax_vx<uint64_t>;
;


// VectorIntFormat::vand_vx(['\n                        Vd_vu[i] = Vs2_vu[i] & Rs1_vu;\n                    ', 'OPIVX', 'SimdAluOp'],{})


template<typename ElemType>
Vand_vxMicro<ElemType>::Vand_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vand_vx_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vand_vxMicro<uint8_t>;
template class Vand_vxMicro<uint16_t>;
template class Vand_vxMicro<uint32_t>;
template class Vand_vxMicro<uint64_t>;
;



template<typename ElemType>
Vand_vx<ElemType>::Vand_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vand_vx", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vand_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vand_vx<uint8_t>;
template class Vand_vx<uint16_t>;
template class Vand_vx<uint32_t>;
template class Vand_vx<uint64_t>;
;


// VectorIntFormat::vor_vx(['\n                        Vd_vu[i] = Vs2_vu[i] | Rs1_vu;\n                    ', 'OPIVX', 'SimdAluOp'],{})


template<typename ElemType>
Vor_vxMicro<ElemType>::Vor_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vor_vx_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vor_vxMicro<uint8_t>;
template class Vor_vxMicro<uint16_t>;
template class Vor_vxMicro<uint32_t>;
template class Vor_vxMicro<uint64_t>;
;



template<typename ElemType>
Vor_vx<ElemType>::Vor_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vor_vx", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vor_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vor_vx<uint8_t>;
template class Vor_vx<uint16_t>;
template class Vor_vx<uint32_t>;
template class Vor_vx<uint64_t>;
;


// VectorIntFormat::vxor_vx(['\n                        Vd_vu[i] = Vs2_vu[i] ^ Rs1_vu;\n                    ', 'OPIVX', 'SimdAluOp'],{})


template<typename ElemType>
Vxor_vxMicro<ElemType>::Vxor_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vxor_vx_micro", _machInst,
                     SimdAluOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vxor_vxMicro<uint8_t>;
template class Vxor_vxMicro<uint16_t>;
template class Vxor_vxMicro<uint32_t>;
template class Vxor_vxMicro<uint64_t>;
;



template<typename ElemType>
Vxor_vx<ElemType>::Vxor_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vxor_vx", _machInst, SimdAluOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vxor_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vxor_vx<uint8_t>;
template class Vxor_vx<uint16_t>;
template class Vxor_vx<uint32_t>;
template class Vxor_vx<uint64_t>;
;


// VectorSlideUpFormat::vslideup_vx((['\n                    const int offset = (int)Rs1_vu;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vdIdx - vs2Idx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int elemOffset = vdOffset + vdIdx * microVlmax;\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            if (this->vm || elem_mask(v0, i + elemOffset)) {\n                                Vd_vu[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                            }\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Vslideup_vxMicro<ElemType>::Vslideup_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx, uint32_t _vdIdx,
        uint32_t _vs2Idx)
    : VectorSlideMicroInst("vslideup_vx_micro", _machInst, SimdMiscOp, _microVl,
        _microIdx, _vdIdx, _vs2Idx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vdIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2Idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vslideup_vxMicro<uint8_t>;
template class Vslideup_vxMicro<uint16_t>;
template class Vslideup_vxMicro<uint32_t>;
template class Vslideup_vxMicro<uint64_t>;
;



template<typename ElemType>
Vslideup_vx<ElemType>::Vslideup_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorSlideMacroInst("vslideup_vx", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; i < ceil((float) this->vl/micro_vlmax); i++) {
        microop = new VPinVdMicroInst(machInst, i, i+1, true);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    // Todo static filter out useless uop
    int micro_idx = 0;
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        for (int j = 0; j <= i; ++j) {
            microop = new Vslideup_vxMicro<ElemType>(
                _machInst, micro_vl, micro_idx++, i, j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vslideup_vx<uint8_t>;
template class Vslideup_vx<uint16_t>;
template class Vslideup_vx<uint32_t>;
template class Vslideup_vx<uint64_t>;
;


// VectorSlideDownFormat::vslidedown_vx((['\n                    const int offset = (int)Rs1_vu;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vs2Idx - vdIdx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    const int numVs2s = vtype_regs_per_group(vtype);\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const bool needZeroTail = numVs2s == vs2Idx + 1;\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int elemIdxBase = vdIdx * microVlmax;\n                        vreg_t resVreg;\n                        auto res = resVreg.as<vu>();\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            res[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                        }\n                        if (needZeroTail) {\n                            for (int i = upperBound + vdOffset;\n                                i < microVlmax; i++) {\n                                res[i] = 0;\n                            }\n                        }\n                        for (int i = vdOffset; i < microVl ; i++) {\n                            if (vm || elem_mask(v0, i + elemIdxBase)) {\n                                Vd_vu[i] = res[i];\n                            }\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Vslidedown_vxMicro<ElemType>::Vslidedown_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx, uint32_t _vdIdx,
        uint32_t _vs2Idx)
    : VectorSlideMicroInst("vslidedown_vx_micro", _machInst, SimdMiscOp, _microVl,
        _microIdx, _vdIdx, _vs2Idx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vdIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2Idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vslidedown_vxMicro<uint8_t>;
template class Vslidedown_vxMicro<uint16_t>;
template class Vslidedown_vxMicro<uint32_t>;
template class Vslidedown_vxMicro<uint64_t>;
;



template<typename ElemType>
Vslidedown_vx<ElemType>::Vslidedown_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorSlideMacroInst("vslidedown_vx", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; i < ceil((float) this->vl / micro_vlmax); i++) {
        microop = new VPinVdMicroInst(machInst, i, num_microops-i, false);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    // Todo static filter out useless uop
    int micro_idx = 0;
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        for (int j = i; j < num_microops; ++j) {
            microop = new Vslidedown_vxMicro<ElemType>(
                _machInst, micro_vl, micro_idx++, i, j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vslidedown_vx<uint8_t>;
template class Vslidedown_vx<uint16_t>;
template class Vslidedown_vx<uint32_t>;
template class Vslidedown_vx<uint64_t>;
;


// VectorGatherFormat::vrgather_vx((['\n                    for (uint32_t i = 0; i < microVl; i++) {\n                        uint32_t ei = i + vs1_idx * vs1_elems + vs1_bias;\n                        uint64_t zextRs1 = rvZext(Rs1);\n                        if (this->vm || elem_mask(v0, ei)) {\n                            const uint64_t idx = zextRs1 - vs2_elems * vs2_idx;\n                            if (zextRs1 >= vlmax)\n                                Vd_vu[i] = 0;\n                            else if (idx < vs2_elems)\n                                Vd_vu[i] = Vs2_vu[idx];\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType, typename IndexType>
Vrgather_vxMicro<ElemType, IndexType>::Vrgather_vxMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vrgather_vx_micro", _machInst,
                 SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    [[maybe_unused]] constexpr uint32_t vd_eewb = sizeof(ElemType);
    [[maybe_unused]] constexpr uint32_t vs2_eewb = sizeof(ElemType);
    [[maybe_unused]] constexpr uint32_t vs1_eewb = sizeof(IndexType);
    constexpr uint32_t vs1_split_num = (vd_eewb + vs1_eewb - 1) / vs1_eewb;
    constexpr uint32_t vd_split_num = (vs1_eewb + vd_eewb - 1) / vd_eewb;
    const int8_t lmul = vtype_vlmul(vtype);
    const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    [[maybe_unused]] const uint32_t vs2_idx = _microIdx % vs2_vregs;
    [[maybe_unused]] const uint32_t vs1_idx =
        _microIdx / vs2_vregs / vs1_split_num;
    [[maybe_unused]] const uint32_t vd_idx =
        _microIdx / vs2_vregs / vd_split_num;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vd_idx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2_idx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[VecMemInternalReg0 + vd_idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vrgather_vxMicro<uint8_t, uint8_t>;
template class Vrgather_vxMicro<uint16_t, uint16_t>;
template class Vrgather_vxMicro<uint32_t, uint32_t>;
template class Vrgather_vxMicro<uint64_t, uint64_t>;
;



template<typename ElemType, typename IndexType>
Vrgather_vx<ElemType, IndexType>::Vrgather_vx(ExtMachInst _machInst,
    uint32_t _vlen)
    : VectorArithMacroInst("vrgather_vx", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    constexpr uint32_t vd_eewb = sizeof(ElemType);
    constexpr uint32_t vs2_eewb = sizeof(ElemType);
    constexpr uint32_t vs1_eewb = sizeof(IndexType);
    const int8_t lmul = vtype_vlmul(vtype);
    const int8_t vs1_emul = lmul + __builtin_ctz(vs1_eewb)
                                 - __builtin_ctz(vs2_eewb);
    const uint8_t vs2_vregs = lmul < 0 ? 1 : 1 << lmul;
    const uint8_t vs1_vregs = vs1_emul < 0 ? 1 : 1 << vs1_emul;
    const uint8_t vd_vregs = vs2_vregs;
    uint32_t vlenb = vlen >> 3;
    const int32_t micro_vlmax = vlenb / std::max(vd_eewb, vs1_eewb);
    int32_t remaining_vl = this->vl;
    int32_t micro_vl = std::min(remaining_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    uint32_t vd_vlmax = vlenb / vd_eewb;
    uint32_t vs1_vlmax = vlenb / vs1_eewb;
    for (uint32_t i = 0; i < ceil((float) this->vl / vd_vlmax); i++) {
        uint32_t pinvd_micro_vl = (vd_vlmax*(i+1) <= remaining_vl)
                                  ? vd_vlmax : remaining_vl;
        uint8_t num_vd_pins = ceil((float) pinvd_micro_vl/vs1_vlmax)*vs2_vregs;
        microop = new VPinVdMicroInst(machInst, i, num_vd_pins);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);

        remaining_vl -= pinvd_micro_vl;
    }

    remaining_vl = this->vl;
    for (uint32_t i = 0; i < std::max(vs1_vregs, vd_vregs) && micro_vl > 0;
            i++) {
        for (uint8_t j = 0; j < vs2_vregs; j++) {
            microop = new Vrgather_vxMicro<ElemType, IndexType>(
                _machInst, micro_vl, i * vs2_vregs + j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(remaining_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vrgather_vx<uint8_t, uint8_t>;
template class Vrgather_vx<uint16_t, uint16_t>;
template class Vrgather_vx<uint32_t, uint32_t>;
template class Vrgather_vx<uint64_t, uint64_t>;
;


// VectorIntFormat::vadc_vxm(['\n                            Vd_vi[i] = Vs2_vi[i] + Rs1_vi + elem_mask(v0, ei);\n                        ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vadc_vxmMicro<ElemType>::Vadc_vxmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vadc_vxm_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vadc_vxmMicro<uint8_t>;
template class Vadc_vxmMicro<uint16_t>;
template class Vadc_vxmMicro<uint32_t>;
template class Vadc_vxmMicro<uint64_t>;
;



template<typename ElemType>
Vadc_vxm<ElemType>::Vadc_vxm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vadc_vxm", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vadc_vxmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vadc_vxm<uint8_t>;
template class Vadc_vxm<uint16_t>;
template class Vadc_vxm<uint32_t>;
template class Vadc_vxm<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vsbc_vxm(['\n                            Vd_vi[i] = Vs2_vi[i] - Rs1_vi - elem_mask(v0, ei);\n                        ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vsbc_vxmMicro<ElemType>::Vsbc_vxmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsbc_vxm_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsbc_vxmMicro<uint8_t>;
template class Vsbc_vxmMicro<uint16_t>;
template class Vsbc_vxmMicro<uint32_t>;
template class Vsbc_vxmMicro<uint64_t>;
;



template<typename ElemType>
Vsbc_vxm<ElemType>::Vsbc_vxm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsbc_vxm", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsbc_vxmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsbc_vxm<uint8_t>;
template class Vsbc_vxm<uint16_t>;
template class Vsbc_vxm<uint32_t>;
template class Vsbc_vxm<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vmerge_vxm(['\n                            Vd_vu[i] = elem_mask(v0, ei) ? Rs1_vu : Vs2_vu[i];\n                        ', 'OPIVX', 'SimdMiscOp'],{})


template<typename ElemType>
Vmerge_vxmMicro<ElemType>::Vmerge_vxmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmerge_vxm_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmerge_vxmMicro<uint8_t>;
template class Vmerge_vxmMicro<uint16_t>;
template class Vmerge_vxmMicro<uint32_t>;
template class Vmerge_vxmMicro<uint64_t>;
;



template<typename ElemType>
Vmerge_vxm<ElemType>::Vmerge_vxm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmerge_vxm", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmerge_vxmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmerge_vxm<uint8_t>;
template class Vmerge_vxm<uint16_t>;
template class Vmerge_vxm<uint32_t>;
template class Vmerge_vxm<uint64_t>;
;


// VectorIntFormat::vmv_v_x(['\n                                Vd_vu[i] = Rs1_vu;\n                            ', 'OPIVX', 'SimdMiscOp'],{})


template<typename ElemType>
Vmv_v_xMicro<ElemType>::Vmv_v_xMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmv_v_x_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        ;
}

template class Vmv_v_xMicro<uint8_t>;
template class Vmv_v_xMicro<uint16_t>;
template class Vmv_v_xMicro<uint32_t>;
template class Vmv_v_xMicro<uint64_t>;
;



template<typename ElemType>
Vmv_v_x<ElemType>::Vmv_v_x(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmv_v_x", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmv_v_xMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmv_v_x<uint8_t>;
template class Vmv_v_x<uint16_t>;
template class Vmv_v_x<uint32_t>;
template class Vmv_v_x<uint64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorIntVxsatFormat::vsaddu_vx(['\n                        Vd_vu[i] = sat_addu<vu>(Vs2_vu[i], Rs1_vu,\n                            vxsatptr);\n                    ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vsaddu_vxMicro<ElemType>::Vsaddu_vxMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vsaddu_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsaddu_vxMicro<uint8_t>;
template class Vsaddu_vxMicro<uint16_t>;
template class Vsaddu_vxMicro<uint32_t>;
template class Vsaddu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vsaddu_vx<ElemType>::Vsaddu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsaddu_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsaddu_vxMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsaddu_vx<uint8_t>;
template class Vsaddu_vx<uint16_t>;
template class Vsaddu_vx<uint32_t>;
template class Vsaddu_vx<uint64_t>;
;


// VectorIntVxsatFormat::vsadd_vx(['\n                        Vd_vu[i] = sat_add<vi>(Vs2_vu[i], Rs1_vu,\n                            vxsatptr);\n                    ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vsadd_vxMicro<ElemType>::Vsadd_vxMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vsadd_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsadd_vxMicro<uint8_t>;
template class Vsadd_vxMicro<uint16_t>;
template class Vsadd_vxMicro<uint32_t>;
template class Vsadd_vxMicro<uint64_t>;
;



template<typename ElemType>
Vsadd_vx<ElemType>::Vsadd_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsadd_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsadd_vxMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsadd_vx<uint8_t>;
template class Vsadd_vx<uint16_t>;
template class Vsadd_vx<uint32_t>;
template class Vsadd_vx<uint64_t>;
;


// VectorIntVxsatFormat::vssubu_vx(['\n                        Vd_vu[i] = sat_subu<vu>(Vs2_vu[i], Rs1_vu,\n                            vxsatptr);\n                    ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vssubu_vxMicro<ElemType>::Vssubu_vxMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vssubu_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssubu_vxMicro<uint8_t>;
template class Vssubu_vxMicro<uint16_t>;
template class Vssubu_vxMicro<uint32_t>;
template class Vssubu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vssubu_vx<ElemType>::Vssubu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssubu_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssubu_vxMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssubu_vx<uint8_t>;
template class Vssubu_vx<uint16_t>;
template class Vssubu_vx<uint32_t>;
template class Vssubu_vx<uint64_t>;
;


// VectorIntVxsatFormat::vssub_vx(['\n                        Vd_vu[i] = sat_sub<vi>(Vs2_vu[i], Rs1_vu,\n                            vxsatptr);\n                    ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vssub_vxMicro<ElemType>::Vssub_vxMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vssub_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssub_vxMicro<uint8_t>;
template class Vssub_vxMicro<uint16_t>;
template class Vssub_vxMicro<uint32_t>;
template class Vssub_vxMicro<uint64_t>;
;



template<typename ElemType>
Vssub_vx<ElemType>::Vssub_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssub_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssub_vxMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssub_vx<uint8_t>;
template class Vssub_vx<uint16_t>;
template class Vssub_vx<uint32_t>;
template class Vssub_vx<uint64_t>;
;


// VectorIntVxsatFormat::vsmul_vx(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        bool overflow = Rs1_vi == Vs2_vi[i] && Rs1_vi == min;\n                        __int128_t result =\n                            (__int128_t)Rs1_vi * (__int128_t)Vs2_vi[i];\n                        result = int_rounding<__uint128_t>(\n                            result, 0 /* TODO */, sew - 1);\n                        result = result >> (sew - 1);\n                        if (overflow) {\n                            result = max;\n                            *vxsatptr = true;\n                        }\n\n                        Vd_vi[i] = (vi)result;\n                    ', 'OPIVX', 'SimdMultOp'],{})


template<typename ElemType>
Vsmul_vxMicro<ElemType>::Vsmul_vxMicro(ExtMachInst _machInst,
    uint32_t _microVl, uint32_t _microIdx, bool* vxsatptr)
    : VectorArithMicroInst("vsmul_vx_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    this->vxsatptr = vxsatptr;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsmul_vxMicro<uint8_t>;
template class Vsmul_vxMicro<uint16_t>;
template class Vsmul_vxMicro<uint32_t>;
template class Vsmul_vxMicro<uint64_t>;
;



template<typename ElemType>
Vsmul_vx<ElemType>::Vsmul_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsmul_vx", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsmul_vxMicro<ElemType>(_machInst,
            micro_vl, i, &vxsat);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    microop = new VxsatMicroInst(&vxsat, _machInst);
    microop->setFlag(StaticInst::IsSerializeAfter);
    microop->setFlag(StaticInst::IsNonSpeculative);
    this->microops.push_back(microop);
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsmul_vx<uint8_t>;
template class Vsmul_vx<uint16_t>;
template class Vsmul_vx<uint32_t>;
template class Vsmul_vx<uint64_t>;
;


// VectorIntFormat::vsll_vx(['\n                        Vd_vu[i] = Vs2_vu[i] << (Rs1_vu & (sew - 1));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template<typename ElemType>
Vsll_vxMicro<ElemType>::Vsll_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsll_vx_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsll_vxMicro<uint8_t>;
template class Vsll_vxMicro<uint16_t>;
template class Vsll_vxMicro<uint32_t>;
template class Vsll_vxMicro<uint64_t>;
;



template<typename ElemType>
Vsll_vx<ElemType>::Vsll_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsll_vx", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsll_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsll_vx<uint8_t>;
template class Vsll_vx<uint16_t>;
template class Vsll_vx<uint32_t>;
template class Vsll_vx<uint64_t>;
;


// VectorIntFormat::vsrl_vx(['\n                        Vd_vu[i] = Vs2_vu[i] >> (Rs1_vu & (sew - 1));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template<typename ElemType>
Vsrl_vxMicro<ElemType>::Vsrl_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsrl_vx_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsrl_vxMicro<uint8_t>;
template class Vsrl_vxMicro<uint16_t>;
template class Vsrl_vxMicro<uint32_t>;
template class Vsrl_vxMicro<uint64_t>;
;



template<typename ElemType>
Vsrl_vx<ElemType>::Vsrl_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsrl_vx", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsrl_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsrl_vx<uint8_t>;
template class Vsrl_vx<uint16_t>;
template class Vsrl_vx<uint32_t>;
template class Vsrl_vx<uint64_t>;
;


// VectorIntFormat::vsra_vx(['\n                        Vd_vi[i] = Vs2_vi[i] >> (Rs1_vu & (sew - 1));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template<typename ElemType>
Vsra_vxMicro<ElemType>::Vsra_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vsra_vx_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vsra_vxMicro<uint8_t>;
template class Vsra_vxMicro<uint16_t>;
template class Vsra_vxMicro<uint32_t>;
template class Vsra_vxMicro<uint64_t>;
;



template<typename ElemType>
Vsra_vx<ElemType>::Vsra_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vsra_vx", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vsra_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vsra_vx<uint8_t>;
template class Vsra_vx<uint16_t>;
template class Vsra_vx<uint32_t>;
template class Vsra_vx<uint64_t>;
;


// VectorIntFormat::vssrl_vx(['\n                        int sh = Rs1_vu & (sew - 1);\n                        __uint128_t val = Vs2_vu[i];\n\n                        val = int_rounding<__uint128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vu[i] = val >> sh;\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template<typename ElemType>
Vssrl_vxMicro<ElemType>::Vssrl_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vssrl_vx_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssrl_vxMicro<uint8_t>;
template class Vssrl_vxMicro<uint16_t>;
template class Vssrl_vxMicro<uint32_t>;
template class Vssrl_vxMicro<uint64_t>;
;



template<typename ElemType>
Vssrl_vx<ElemType>::Vssrl_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssrl_vx", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssrl_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssrl_vx<uint8_t>;
template class Vssrl_vx<uint16_t>;
template class Vssrl_vx<uint32_t>;
template class Vssrl_vx<uint64_t>;
;


// VectorIntFormat::vssra_vx(['\n                        int sh = Rs1_vu & (sew - 1);\n                        __int128_t val = Vs2_vi[i];\n\n                        val = int_rounding<__int128_t>(val,\n                            xc->readMiscReg(MISCREG_VXRM), sh);\n                        Vd_vi[i] = val >> sh;\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template<typename ElemType>
Vssra_vxMicro<ElemType>::Vssra_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vssra_vx_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vssra_vxMicro<uint8_t>;
template class Vssra_vxMicro<uint16_t>;
template class Vssra_vxMicro<uint32_t>;
template class Vssra_vxMicro<uint64_t>;
;



template<typename ElemType>
Vssra_vx<ElemType>::Vssra_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vssra_vx", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vssra_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vssra_vx<uint8_t>;
template class Vssra_vx<uint16_t>;
template class Vssra_vx<uint32_t>;
template class Vssra_vx<uint64_t>;
;


// VectorIntNarrowingFormat::vnsrl_wx(['\n                        Vd_vu[i + offset] = (vu)(Vs2_vwu[i] >>\n                                            ((vwu)Rs1_vu & (sew * 2 - 1)));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template<typename ElemType>
Vnsrl_wxMicro<ElemType>::Vnsrl_wxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnsrl_wx_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnsrl_wxMicro<uint8_t>;
template class Vnsrl_wxMicro<uint16_t>;
template class Vnsrl_wxMicro<uint32_t>;
;



template<typename ElemType>
Vnsrl_wx<ElemType>::Vnsrl_wx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnsrl_wx", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnsrl_wxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnsrl_wx<uint8_t>;
template class Vnsrl_wx<uint16_t>;
template class Vnsrl_wx<uint32_t>;
;


// VectorIntNarrowingFormat::vnsra_wx(['\n                        Vd_vi[i + offset] = (vi)(Vs2_vwi[i] >>\n                                            ((vwu)Rs1_vu & (sew * 2 - 1)));\n                    ', 'OPIVX', 'SimdShiftOp'],{})


template<typename ElemType>
Vnsra_wxMicro<ElemType>::Vnsra_wxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnsra_wx_micro", _machInst,
                     SimdShiftOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnsra_wxMicro<uint8_t>;
template class Vnsra_wxMicro<uint16_t>;
template class Vnsra_wxMicro<uint32_t>;
;



template<typename ElemType>
Vnsra_wx<ElemType>::Vnsra_wx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnsra_wx", _machInst, SimdShiftOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnsra_wxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnsra_wx<uint8_t>;
template class Vnsra_wx<uint16_t>;
template class Vnsra_wx<uint32_t>;
;


// VectorIntNarrowingFormat::vnclipu_wx(['\n                        vu max = std::numeric_limits<vu>::max();\n                        uint64_t sign_mask =\n                            std::numeric_limits<uint64_t>::max() << sew;\n                        __uint128_t res = Vs2_vwu[i];\n                        unsigned shift = Rs1_vu & ((sew * 2) - 1);\n\n                        res = int_rounding<__uint128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res & sign_mask) {\n                            // TODO: vxsat\n                            res = max;\n                        }\n\n                        Vd_vu[i + offset] = (vu)res;\n                    ', 'OPIVX', 'SimdCvtOp'],{})


template<typename ElemType>
Vnclipu_wxMicro<ElemType>::Vnclipu_wxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnclipu_wx_micro", _machInst,
                     SimdCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnclipu_wxMicro<uint8_t>;
template class Vnclipu_wxMicro<uint16_t>;
template class Vnclipu_wxMicro<uint32_t>;
;



template<typename ElemType>
Vnclipu_wx<ElemType>::Vnclipu_wx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnclipu_wx", _machInst, SimdCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnclipu_wxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnclipu_wx<uint8_t>;
template class Vnclipu_wx<uint16_t>;
template class Vnclipu_wx<uint32_t>;
;


// VectorIntNarrowingFormat::vnclip_wx(['\n                        vi max = std::numeric_limits<vi>::max();\n                        vi min = std::numeric_limits<vi>::min();\n                        __int128_t res = Vs2_vwi[i];\n                        unsigned shift = Rs1_vi & ((sew * 2) - 1);\n\n                        res = int_rounding<__int128_t>(\n                            res, 0 /* TODO */, shift) >> shift;\n\n                        if (res < min) {\n                            res = min;\n                            // TODO: vxsat\n                        } else if (res > max) {\n                            res = max;\n                            // TODO: vxsat\n                        }\n\n                        Vd_vi[i + offset] = (vi)res;\n                    ', 'OPIVX', 'SimdCvtOp'],{})


template<typename ElemType>
Vnclip_wxMicro<ElemType>::Vnclip_wxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnclip_wx_micro", _machInst,
                     SimdCvtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx / 2]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnclip_wxMicro<uint8_t>;
template class Vnclip_wxMicro<uint16_t>;
template class Vnclip_wxMicro<uint32_t>;
;



template<typename ElemType>
Vnclip_wx<ElemType>::Vnclip_wx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnclip_wx", _machInst, SimdCvtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnclip_wxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnclip_wx<uint8_t>;
template class Vnclip_wx<uint16_t>;
template class Vnclip_wx<uint32_t>;
;


// VectorIntMaskFormat::vmadc_vxm(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vi[i], Rs1_vi,\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vmadc_vxmMicro<ElemType>::Vmadc_vxmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmadc_vxm_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmadc_vxmMicro<uint8_t>;
template class Vmadc_vxmMicro<uint16_t>;
template class Vmadc_vxmMicro<uint32_t>;
template class Vmadc_vxmMicro<uint64_t>;
;



template<typename ElemType>
Vmadc_vxm<ElemType>::Vmadc_vxm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmadc_vxm", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmadc_vxmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmadc_vxm<uint8_t>;
template class Vmadc_vxm<uint16_t>;
template class Vmadc_vxm<uint32_t>;
template class Vmadc_vxm<uint64_t>;
;


// VectorIntMaskFormat::vmadc_vx(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                carry_out(Vs2_vi[i], Rs1_vi));\n                        ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vmadc_vxMicro<ElemType>::Vmadc_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmadc_vx_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
;
}

template class Vmadc_vxMicro<uint8_t>;
template class Vmadc_vxMicro<uint16_t>;
template class Vmadc_vxMicro<uint32_t>;
template class Vmadc_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmadc_vx<ElemType>::Vmadc_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmadc_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmadc_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmadc_vx<uint8_t>;
template class Vmadc_vx<uint16_t>;
template class Vmadc_vx<uint32_t>;
template class Vmadc_vx<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmsbc_vxm(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                borrow_out(Vs2_vi[i], Rs1_vi,\n                                    elem_mask(v0, ei)));\n                        ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vmsbc_vxmMicro<ElemType>::Vmsbc_vxmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsbc_vxm_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsbc_vxmMicro<uint8_t>;
template class Vmsbc_vxmMicro<uint16_t>;
template class Vmsbc_vxmMicro<uint32_t>;
template class Vmsbc_vxmMicro<uint64_t>;
;



template<typename ElemType>
Vmsbc_vxm<ElemType>::Vmsbc_vxm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsbc_vxm", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsbc_vxmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsbc_vxm<uint8_t>;
template class Vmsbc_vxm<uint16_t>;
template class Vmsbc_vxm<uint32_t>;
template class Vmsbc_vxm<uint64_t>;
;


// VectorIntMaskFormat::vmsbc_vx(['\n                            Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                                borrow_out(Vs2_vi[i], Rs1_vi));\n                        ', 'OPIVX', 'SimdAddOp'],{})


template<typename ElemType>
Vmsbc_vxMicro<ElemType>::Vmsbc_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsbc_vx_micro", _machInst,
                 SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
;
}

template class Vmsbc_vxMicro<uint8_t>;
template class Vmsbc_vxMicro<uint16_t>;
template class Vmsbc_vxMicro<uint32_t>;
template class Vmsbc_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmsbc_vx<ElemType>::Vmsbc_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsbc_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsbc_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsbc_vx<uint8_t>;
template class Vmsbc_vx<uint16_t>;
template class Vmsbc_vx<uint32_t>;
template class Vmsbc_vx<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorIntMaskFormat::vmseq_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] == Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmseq_vxMicro<ElemType>::Vmseq_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmseq_vx_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmseq_vxMicro<uint8_t>;
template class Vmseq_vxMicro<uint16_t>;
template class Vmseq_vxMicro<uint32_t>;
template class Vmseq_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmseq_vx<ElemType>::Vmseq_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmseq_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmseq_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmseq_vx<uint8_t>;
template class Vmseq_vx<uint16_t>;
template class Vmseq_vx<uint32_t>;
template class Vmseq_vx<uint64_t>;
;


// VectorIntMaskFormat::vmsne_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] != Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsne_vxMicro<ElemType>::Vmsne_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsne_vx_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsne_vxMicro<uint8_t>;
template class Vmsne_vxMicro<uint16_t>;
template class Vmsne_vxMicro<uint32_t>;
template class Vmsne_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmsne_vx<ElemType>::Vmsne_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsne_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsne_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsne_vx<uint8_t>;
template class Vmsne_vx<uint16_t>;
template class Vmsne_vx<uint32_t>;
template class Vmsne_vx<uint64_t>;
;


// VectorIntMaskFormat::vmsltu_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] < Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsltu_vxMicro<ElemType>::Vmsltu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsltu_vx_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsltu_vxMicro<uint8_t>;
template class Vmsltu_vxMicro<uint16_t>;
template class Vmsltu_vxMicro<uint32_t>;
template class Vmsltu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmsltu_vx<ElemType>::Vmsltu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsltu_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsltu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsltu_vx<uint8_t>;
template class Vmsltu_vx<uint16_t>;
template class Vmsltu_vx<uint32_t>;
template class Vmsltu_vx<uint64_t>;
;


// VectorIntMaskFormat::vmslt_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] < Rs1_vi));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmslt_vxMicro<ElemType>::Vmslt_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmslt_vx_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmslt_vxMicro<uint8_t>;
template class Vmslt_vxMicro<uint16_t>;
template class Vmslt_vxMicro<uint32_t>;
template class Vmslt_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmslt_vx<ElemType>::Vmslt_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmslt_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmslt_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmslt_vx<uint8_t>;
template class Vmslt_vx<uint16_t>;
template class Vmslt_vx<uint32_t>;
template class Vmslt_vx<uint64_t>;
;


// VectorIntMaskFormat::vmsleu_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] <= Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsleu_vxMicro<ElemType>::Vmsleu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsleu_vx_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsleu_vxMicro<uint8_t>;
template class Vmsleu_vxMicro<uint16_t>;
template class Vmsleu_vxMicro<uint32_t>;
template class Vmsleu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmsleu_vx<ElemType>::Vmsleu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsleu_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsleu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsleu_vx<uint8_t>;
template class Vmsleu_vx<uint16_t>;
template class Vmsleu_vx<uint32_t>;
template class Vmsleu_vx<uint64_t>;
;


// VectorIntMaskFormat::vmsle_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] <= Rs1_vi));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsle_vxMicro<ElemType>::Vmsle_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsle_vx_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsle_vxMicro<uint8_t>;
template class Vmsle_vxMicro<uint16_t>;
template class Vmsle_vxMicro<uint32_t>;
template class Vmsle_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmsle_vx<ElemType>::Vmsle_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsle_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsle_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsle_vx<uint8_t>;
template class Vmsle_vx<uint16_t>;
template class Vmsle_vx<uint32_t>;
template class Vmsle_vx<uint64_t>;
;


// VectorIntMaskFormat::vmsgtu_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vu[i] > Rs1_vu));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsgtu_vxMicro<ElemType>::Vmsgtu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsgtu_vx_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsgtu_vxMicro<uint8_t>;
template class Vmsgtu_vxMicro<uint16_t>;
template class Vmsgtu_vxMicro<uint32_t>;
template class Vmsgtu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmsgtu_vx<ElemType>::Vmsgtu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsgtu_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsgtu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsgtu_vx<uint8_t>;
template class Vmsgtu_vx<uint16_t>;
template class Vmsgtu_vx<uint32_t>;
template class Vmsgtu_vx<uint64_t>;
;


// VectorIntMaskFormat::vmsgt_vx(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            (Vs2_vi[i] > Rs1_vi));\n                    ', 'OPIVX', 'SimdCmpOp'],{})


template<typename ElemType>
Vmsgt_vxMicro<ElemType>::Vmsgt_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmsgt_vx_micro", _machInst,
                 SimdCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmsgt_vxMicro<uint8_t>;
template class Vmsgt_vxMicro<uint16_t>;
template class Vmsgt_vxMicro<uint32_t>;
template class Vmsgt_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmsgt_vx<ElemType>::Vmsgt_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmsgt_vx", _machInst, SimdCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmsgt_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmsgt_vx<uint8_t>;
template class Vmsgt_vx<uint16_t>;
template class Vmsgt_vx<uint32_t>;
template class Vmsgt_vx<uint64_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatFormat::vfadd_vf(['\n                        auto fd = fadd<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})

template<typename ElemType>
Vfadd_vfMicro<ElemType>::Vfadd_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfadd_vf_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfadd_vfMicro<float16_t>;
template class Vfadd_vfMicro<float32_t>;
template class Vfadd_vfMicro<float64_t>;
;


template<typename ElemType>
Vfadd_vf<ElemType>::Vfadd_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfadd_vf", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfadd_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfadd_vf<float16_t>;
template class Vfadd_vf<float32_t>;
template class Vfadd_vf<float64_t>;
;


// VectorFloatFormat::vfsub_vf(['\n                        auto fd = fsub<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})

template<typename ElemType>
Vfsub_vfMicro<ElemType>::Vfsub_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsub_vf_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsub_vfMicro<float16_t>;
template class Vfsub_vfMicro<float32_t>;
template class Vfsub_vfMicro<float64_t>;
;


template<typename ElemType>
Vfsub_vf<ElemType>::Vfsub_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsub_vf", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsub_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsub_vf<float16_t>;
template class Vfsub_vf<float32_t>;
template class Vfsub_vf<float64_t>;
;


// VectorFloatFormat::vfmin_vf(['\n                        auto fd = fmin<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})

template<typename ElemType>
Vfmin_vfMicro<ElemType>::Vfmin_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmin_vf_micro", _machInst,
                     SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmin_vfMicro<float16_t>;
template class Vfmin_vfMicro<float32_t>;
template class Vfmin_vfMicro<float64_t>;
;


template<typename ElemType>
Vfmin_vf<ElemType>::Vfmin_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmin_vf", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmin_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmin_vf<float16_t>;
template class Vfmin_vf<float32_t>;
template class Vfmin_vf<float64_t>;
;


// VectorFloatFormat::vfmax_vf(['\n                        auto fd = fmax<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                            Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})

template<typename ElemType>
Vfmax_vfMicro<ElemType>::Vfmax_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmax_vf_micro", _machInst,
                     SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmax_vfMicro<float16_t>;
template class Vfmax_vfMicro<float32_t>;
template class Vfmax_vfMicro<float64_t>;
;


template<typename ElemType>
Vfmax_vf<ElemType>::Vfmax_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmax_vf", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmax_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmax_vf<float16_t>;
template class Vfmax_vf<float32_t>;
template class Vfmax_vf<float64_t>;
;


// VectorFloatFormat::vfsgnj_vf(['\n                        Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                             ftype_freg<et>(freg(Fs1_bits)),\n                                             false, false).v;\n                    ', 'OPFVF', 'SimdFloatExtOp'],{})

template<typename ElemType>
Vfsgnj_vfMicro<ElemType>::Vfsgnj_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsgnj_vf_micro", _machInst,
                     SimdFloatExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsgnj_vfMicro<float16_t>;
template class Vfsgnj_vfMicro<float32_t>;
template class Vfsgnj_vfMicro<float64_t>;
;


template<typename ElemType>
Vfsgnj_vf<ElemType>::Vfsgnj_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsgnj_vf", _machInst, SimdFloatExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsgnj_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsgnj_vf<float16_t>;
template class Vfsgnj_vf<float32_t>;
template class Vfsgnj_vf<float64_t>;
;


// VectorFloatFormat::vfsgnjn_vf(['\n                        Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                             ftype_freg<et>(freg(Fs1_bits)),\n                                             true, false).v;\n                    ', 'OPFVF', 'SimdFloatExtOp'],{})

template<typename ElemType>
Vfsgnjn_vfMicro<ElemType>::Vfsgnjn_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsgnjn_vf_micro", _machInst,
                     SimdFloatExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsgnjn_vfMicro<float16_t>;
template class Vfsgnjn_vfMicro<float32_t>;
template class Vfsgnjn_vfMicro<float64_t>;
;


template<typename ElemType>
Vfsgnjn_vf<ElemType>::Vfsgnjn_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsgnjn_vf", _machInst, SimdFloatExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsgnjn_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsgnjn_vf<float16_t>;
template class Vfsgnjn_vf<float32_t>;
template class Vfsgnjn_vf<float64_t>;
;


// VectorFloatFormat::vfsgnjx_vf(['\n                        Vd_vu[i] = fsgnj<et>(ftype<et>(Vs2_vu[i]),\n                                             ftype_freg<et>(freg(Fs1_bits)),\n                                             false, true).v;\n                    ', 'OPFVF', 'SimdFloatExtOp'],{})

template<typename ElemType>
Vfsgnjx_vfMicro<ElemType>::Vfsgnjx_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfsgnjx_vf_micro", _machInst,
                     SimdFloatExtOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfsgnjx_vfMicro<float16_t>;
template class Vfsgnjx_vfMicro<float32_t>;
template class Vfsgnjx_vfMicro<float64_t>;
;


template<typename ElemType>
Vfsgnjx_vf<ElemType>::Vfsgnjx_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfsgnjx_vf", _machInst, SimdFloatExtOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfsgnjx_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfsgnjx_vf<float16_t>;
template class Vfsgnjx_vf<float32_t>;
template class Vfsgnjx_vf<float64_t>;
;


// VectorFloatSlideUpFormat::vfslide1up_vf((['\n                    const int offset = 1;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vdIdx - vs2Idx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int elemOffset = vdOffset + vdIdx * microVlmax;\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            if (this->vm || elem_mask(v0, i + elemOffset)) {\n                                Vd_vu[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                            }\n                        }\n                        // TODO: dirty code\n                        if (vdIdx == 0 && vs2Idx == 0 &&\n                                (this->vm || elem_mask(v0, 0))) {\n                            tmp_d0.as<vu>()[0] = Rs1_vu;\n                        }\n                    }\n                ', 'OPFVF', 'SimdMiscOp'], {}))


template<typename ElemType>
Vfslide1up_vfMicro<ElemType>::Vfslide1up_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx, uint32_t _vdIdx,
        uint32_t _vs2Idx)
    : VectorSlideMicroInst("vfslide1up_vf_micro", _machInst, SimdMiscOp, _microVl,
        _microIdx, _vdIdx, _vs2Idx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vdIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2Idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfslide1up_vfMicro<float16_t>;
template class Vfslide1up_vfMicro<float32_t>;
template class Vfslide1up_vfMicro<float64_t>;
;



template<typename ElemType>
Vfslide1up_vf<ElemType>::Vfslide1up_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorSlideMacroInst("vfslide1up_vf", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; i < ceil((float) this->vl/micro_vlmax); i++) {
        microop = new VPinVdMicroInst(machInst, i, i+1, true);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    // Todo static filter out useless uop
    int micro_idx = 0;
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        for (int j = 0; j <= i; ++j) {
            microop = new Vfslide1up_vfMicro<ElemType>(
                _machInst, micro_vl, micro_idx++, i, j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfslide1up_vf<float16_t>;
template class Vfslide1up_vf<float32_t>;
template class Vfslide1up_vf<float64_t>;
;


// VectorFloatSlideDownFormat::vfslide1down_vf((['\n                    const int offset = 1;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vs2Idx - vdIdx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    const int numVs2s = vtype_regs_per_group(vtype);\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const bool needZeroTail = numVs2s == vs2Idx + 1;\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int elemIdxBase = vdIdx * microVlmax;\n                        vreg_t resVreg;\n                        auto res = resVreg.as<vu>();\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            res[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                        }\n                        if (needZeroTail) {\n                            for (int i = upperBound + vdOffset;\n                                i < microVlmax; i++) {\n                                res[i] = 0;\n                            }\n                        }\n                        for (int i = vdOffset; i < microVl ; i++) {\n                            if (vm || elem_mask(v0, i + elemIdxBase)) {\n                                Vd_vu[i] = (i + elemIdxBase != machInst.vl - 1)\n                                    ? res[i]\n                                    : Rs1_vu;\n                            }\n                        }\n                    }\n                ', 'OPFVF', 'SimdMiscOp'], {}))


template<typename ElemType>
Vfslide1down_vfMicro<ElemType>::Vfslide1down_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx, uint32_t _vdIdx,
        uint32_t _vs2Idx)
    : VectorSlideMicroInst("vfslide1down_vf_micro", _machInst, SimdMiscOp, _microVl,
        _microIdx, _vdIdx, _vs2Idx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vdIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2Idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfslide1down_vfMicro<float16_t>;
template class Vfslide1down_vfMicro<float32_t>;
template class Vfslide1down_vfMicro<float64_t>;
;



template<typename ElemType>
Vfslide1down_vf<ElemType>::Vfslide1down_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorSlideMacroInst("vfslide1down_vf", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; i < ceil((float) this->vl / micro_vlmax); i++) {
        microop = new VPinVdMicroInst(machInst, i, num_microops-i, false);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    // Todo static filter out useless uop
    int micro_idx = 0;
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        for (int j = i; j < num_microops; ++j) {
            microop = new Vfslide1down_vfMicro<ElemType>(
                _machInst, micro_vl, micro_idx++, i, j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfslide1down_vf<float16_t>;
template class Vfslide1down_vf<float32_t>;
template class Vfslide1down_vf<float64_t>;
;


// VectorNonSplitFormat::vfmv_s_f((['\n                            if (this->vl) {\n                                auto fd = ftype_freg<et>(freg(Fs1_bits));\n                                Vd_vu[0] = fd.v;\n                            }\n                        ', 'OPFVV', 'SimdMiscOp'], {}))


template<typename ElemType>
Vfmv_s_f<ElemType>::Vfmv_s_f(ExtMachInst _machInst)
    : VectorNonSplitInst("vfmv_s_f", _machInst, SimdMiscOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    ;
}

template class Vfmv_s_f<float16_t>;
template class Vfmv_s_f<float32_t>;
template class Vfmv_s_f<float64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorFloatFormat::vfmerge_vfm(['\n                            Vd_vu[i] = elem_mask(v0, ei)\n                                    ? ftype_freg<et>(freg(Fs1_bits)).v\n                                    : Vs2_vu[i];\n                        ', 'OPFVF', 'SimdMiscOp'],{})

template<typename ElemType>
Vfmerge_vfmMicro<ElemType>::Vfmerge_vfmMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmerge_vfm_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmerge_vfmMicro<float16_t>;
template class Vfmerge_vfmMicro<float32_t>;
template class Vfmerge_vfmMicro<float64_t>;
;


template<typename ElemType>
Vfmerge_vfm<ElemType>::Vfmerge_vfm(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmerge_vfm", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmerge_vfmMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmerge_vfm<float16_t>;
template class Vfmerge_vfm<float32_t>;
template class Vfmerge_vfm<float64_t>;
;


// VectorFloatFormat::vfmv_v_f(['\n                            auto fd = ftype_freg<et>(freg(Fs1_bits));\n                            Vd_vu[i] = fd.v;\n                        ', 'OPFVF', 'SimdMiscOp'],{})

template<typename ElemType>
Vfmv_v_fMicro<ElemType>::Vfmv_v_fMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmv_v_f_micro", _machInst,
                     SimdMiscOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        ;
}

template class Vfmv_v_fMicro<float16_t>;
template class Vfmv_v_fMicro<float32_t>;
template class Vfmv_v_fMicro<float64_t>;
;


template<typename ElemType>
Vfmv_v_f<ElemType>::Vfmv_v_f(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmv_v_f", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmv_v_fMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmv_v_f<float16_t>;
template class Vfmv_v_f<float32_t>;
template class Vfmv_v_f<float64_t>;
;


// Unknown::unknown(([], {}))

// VectorFloatMaskFormat::vmfeq_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            feq<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype_freg<et>(freg(Fs1_bits))));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmfeq_vfMicro<ElemType>::Vmfeq_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmfeq_vf_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmfeq_vfMicro<float16_t>;
template class Vmfeq_vfMicro<float32_t>;
template class Vmfeq_vfMicro<float64_t>;
;



template<typename ElemType>
Vmfeq_vf<ElemType>::Vmfeq_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmfeq_vf", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmfeq_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmfeq_vf<float16_t>;
template class Vmfeq_vf<float32_t>;
template class Vmfeq_vf<float64_t>;
;


// VectorFloatMaskFormat::vmfle_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            fle<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype_freg<et>(freg(Fs1_bits))));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmfle_vfMicro<ElemType>::Vmfle_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmfle_vf_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmfle_vfMicro<float16_t>;
template class Vmfle_vfMicro<float32_t>;
template class Vmfle_vfMicro<float64_t>;
;



template<typename ElemType>
Vmfle_vf<ElemType>::Vmfle_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmfle_vf", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmfle_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmfle_vf<float16_t>;
template class Vmfle_vf<float32_t>;
template class Vmfle_vf<float64_t>;
;


// VectorFloatMaskFormat::vmflt_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            flt<et>(ftype<et>(Vs2_vu[i]),\n                                    ftype_freg<et>(freg(Fs1_bits))));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmflt_vfMicro<ElemType>::Vmflt_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmflt_vf_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmflt_vfMicro<float16_t>;
template class Vmflt_vfMicro<float32_t>;
template class Vmflt_vfMicro<float64_t>;
;



template<typename ElemType>
Vmflt_vf<ElemType>::Vmflt_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmflt_vf", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmflt_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmflt_vf<float16_t>;
template class Vmflt_vf<float32_t>;
template class Vmflt_vf<float64_t>;
;


// VectorFloatMaskFormat::vmfne_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            !feq<et>(ftype<et>(Vs2_vu[i]),\n                                     ftype_freg<et>(freg(Fs1_bits))));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmfne_vfMicro<ElemType>::Vmfne_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmfne_vf_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmfne_vfMicro<float16_t>;
template class Vmfne_vfMicro<float32_t>;
template class Vmfne_vfMicro<float64_t>;
;



template<typename ElemType>
Vmfne_vf<ElemType>::Vmfne_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmfne_vf", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmfne_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmfne_vf<float16_t>;
template class Vmfne_vf<float32_t>;
template class Vmfne_vf<float64_t>;
;


// VectorFloatMaskFormat::vmfgt_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            flt<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                    ftype<et>(Vs2_vu[i])));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmfgt_vfMicro<ElemType>::Vmfgt_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmfgt_vf_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmfgt_vfMicro<float16_t>;
template class Vmfgt_vfMicro<float32_t>;
template class Vmfgt_vfMicro<float64_t>;
;



template<typename ElemType>
Vmfgt_vf<ElemType>::Vmfgt_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmfgt_vf", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmfgt_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmfgt_vf<float16_t>;
template class Vmfgt_vf<float32_t>;
template class Vmfgt_vf<float64_t>;
;


// VectorFloatMaskFormat::vmfge_vf(['\n                        Vd_ub[(i + offset)/8] = ASSIGN_VD_BIT(i + offset,\n                            fle<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                    ftype<et>(Vs2_vu[i])));\n                    ', 'OPFVF', 'SimdFloatCmpOp'],{})


template<typename ElemType>
Vmfge_vfMicro<ElemType>::Vmfge_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
: VectorArithMicroInst("vmfge_vf_micro", _machInst,
                 SimdFloatCmpOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[VecMemInternalReg0 + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmfge_vfMicro<float16_t>;
template class Vmfge_vfMicro<float32_t>;
template class Vmfge_vfMicro<float64_t>;
;



template<typename ElemType>
Vmfge_vf<ElemType>::Vmfge_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmfge_vf", _machInst, SimdFloatCmpOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    for (int i = 0; i < num_microops && micro_vl >= 0; ++i) {
        microop = new Vmfge_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    microop = new VMaskMergeMicroInst(_machInst, _machInst.vd,
        this->microops.size(), _vlen, sizeof(ElemType));
    this->microops.push_back(microop);

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmfge_vf<float16_t>;
template class Vmfge_vf<float32_t>;
template class Vmfge_vf<float64_t>;
;


// VectorFloatFormat::vfdiv_vf(['\n                        auto fd = fdiv<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatDivOp'],{})

template<typename ElemType>
Vfdiv_vfMicro<ElemType>::Vfdiv_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfdiv_vf_micro", _machInst,
                     SimdFloatDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfdiv_vfMicro<float16_t>;
template class Vfdiv_vfMicro<float32_t>;
template class Vfdiv_vfMicro<float64_t>;
;


template<typename ElemType>
Vfdiv_vf<ElemType>::Vfdiv_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfdiv_vf", _machInst, SimdFloatDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfdiv_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfdiv_vf<float16_t>;
template class Vfdiv_vf<float32_t>;
template class Vfdiv_vf<float64_t>;
;


// VectorFloatFormat::vfrdiv_vf(['\n                        auto fd = fdiv<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                           ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatDivOp'],{})

template<typename ElemType>
Vfrdiv_vfMicro<ElemType>::Vfrdiv_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfrdiv_vf_micro", _machInst,
                     SimdFloatDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfrdiv_vfMicro<float16_t>;
template class Vfrdiv_vfMicro<float32_t>;
template class Vfrdiv_vfMicro<float64_t>;
;


template<typename ElemType>
Vfrdiv_vf<ElemType>::Vfrdiv_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfrdiv_vf", _machInst, SimdFloatDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfrdiv_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfrdiv_vf<float16_t>;
template class Vfrdiv_vf<float32_t>;
template class Vfrdiv_vf<float64_t>;
;


// VectorFloatFormat::vfmul_vf(['\n                        auto fd = fmul<et>(ftype<et>(Vs2_vu[i]),\n                                           ftype_freg<et>(freg(Fs1_bits)));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultOp'],{})

template<typename ElemType>
Vfmul_vfMicro<ElemType>::Vfmul_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmul_vf_micro", _machInst,
                     SimdFloatMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmul_vfMicro<float16_t>;
template class Vfmul_vfMicro<float32_t>;
template class Vfmul_vfMicro<float64_t>;
;


template<typename ElemType>
Vfmul_vf<ElemType>::Vfmul_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmul_vf", _machInst, SimdFloatMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmul_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmul_vf<float16_t>;
template class Vfmul_vf<float32_t>;
template class Vfmul_vf<float64_t>;
;


// VectorFloatFormat::vfrsub_vf(['\n                        auto fd = fsub<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                           ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})

template<typename ElemType>
Vfrsub_vfMicro<ElemType>::Vfrsub_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfrsub_vf_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfrsub_vfMicro<float16_t>;
template class Vfrsub_vfMicro<float32_t>;
template class Vfrsub_vfMicro<float64_t>;
;


template<typename ElemType>
Vfrsub_vf<ElemType>::Vfrsub_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfrsub_vf", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfrsub_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfrsub_vf<float16_t>;
template class Vfrsub_vf<float32_t>;
template class Vfrsub_vf<float64_t>;
;


// VectorFloatFormat::vfmadd_vf(['\n                        auto fd = fmadd<et>(ftype<et>(Vs3_vu[i]),\n                                            ftype_freg<et>(freg(Fs1_bits)),\n                                            ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfmadd_vfMicro<ElemType>::Vfmadd_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmadd_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmadd_vfMicro<float16_t>;
template class Vfmadd_vfMicro<float32_t>;
template class Vfmadd_vfMicro<float64_t>;
;


template<typename ElemType>
Vfmadd_vf<ElemType>::Vfmadd_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmadd_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmadd_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmadd_vf<float16_t>;
template class Vfmadd_vf<float32_t>;
template class Vfmadd_vf<float64_t>;
;


// VectorFloatFormat::vfnmadd_vf(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3_vu[i])),\n                                            ftype_freg<et>(freg(Fs1_bits)),\n                                            fneg(ftype<et>(Vs2_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfnmadd_vfMicro<ElemType>::Vfnmadd_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfnmadd_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfnmadd_vfMicro<float16_t>;
template class Vfnmadd_vfMicro<float32_t>;
template class Vfnmadd_vfMicro<float64_t>;
;


template<typename ElemType>
Vfnmadd_vf<ElemType>::Vfnmadd_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfnmadd_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfnmadd_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfnmadd_vf<float16_t>;
template class Vfnmadd_vf<float32_t>;
template class Vfnmadd_vf<float64_t>;
;


// VectorFloatFormat::vfmsub_vf(['\n                        auto fd = fmadd<et>(ftype<et>(Vs3_vu[i]),\n                                            ftype_freg<et>(freg(Fs1_bits)),\n                                            fneg(ftype<et>(Vs2_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfmsub_vfMicro<ElemType>::Vfmsub_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmsub_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmsub_vfMicro<float16_t>;
template class Vfmsub_vfMicro<float32_t>;
template class Vfmsub_vfMicro<float64_t>;
;


template<typename ElemType>
Vfmsub_vf<ElemType>::Vfmsub_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmsub_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmsub_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmsub_vf<float16_t>;
template class Vfmsub_vf<float32_t>;
template class Vfmsub_vf<float64_t>;
;


// VectorFloatFormat::vfnmsub_vf(['\n                        auto fd = fmadd<et>(fneg(ftype<et>(Vs3_vu[i])),\n                                            ftype_freg<et>(freg(Fs1_bits)),\n                                            ftype<et>(Vs2_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfnmsub_vfMicro<ElemType>::Vfnmsub_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfnmsub_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfnmsub_vfMicro<float16_t>;
template class Vfnmsub_vfMicro<float32_t>;
template class Vfnmsub_vfMicro<float64_t>;
;


template<typename ElemType>
Vfnmsub_vf<ElemType>::Vfnmsub_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfnmsub_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfnmsub_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfnmsub_vf<float16_t>;
template class Vfnmsub_vf<float32_t>;
template class Vfnmsub_vf<float64_t>;
;


// VectorFloatFormat::vfmacc_vf(['\n                        auto fd = fmadd<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                            ftype<et>(Vs2_vu[i]),\n                                            ftype<et>(Vs3_vu[i]));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfmacc_vfMicro<ElemType>::Vfmacc_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmacc_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmacc_vfMicro<float16_t>;
template class Vfmacc_vfMicro<float32_t>;
template class Vfmacc_vfMicro<float64_t>;
;


template<typename ElemType>
Vfmacc_vf<ElemType>::Vfmacc_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmacc_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmacc_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmacc_vf<float16_t>;
template class Vfmacc_vf<float32_t>;
template class Vfmacc_vf<float64_t>;
;


// VectorFloatFormat::vfnmacc_vf(['\n                        auto fd = fmadd<et>(\n                            fneg(ftype_freg<et>(freg(Fs1_bits))),\n                            ftype<et>(Vs2_vu[i]),\n                            fneg(ftype<et>(Vs3_vu[i]))\n                        );\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfnmacc_vfMicro<ElemType>::Vfnmacc_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfnmacc_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfnmacc_vfMicro<float16_t>;
template class Vfnmacc_vfMicro<float32_t>;
template class Vfnmacc_vfMicro<float64_t>;
;


template<typename ElemType>
Vfnmacc_vf<ElemType>::Vfnmacc_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfnmacc_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfnmacc_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfnmacc_vf<float16_t>;
template class Vfnmacc_vf<float32_t>;
template class Vfnmacc_vf<float64_t>;
;


// VectorFloatFormat::vfmsac_vf(['\n                        auto fd = fmadd<et>(ftype_freg<et>(freg(Fs1_bits)),\n                                            ftype<et>(Vs2_vu[i]),\n                                            fneg(ftype<et>(Vs3_vu[i])));\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfmsac_vfMicro<ElemType>::Vfmsac_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfmsac_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfmsac_vfMicro<float16_t>;
template class Vfmsac_vfMicro<float32_t>;
template class Vfmsac_vfMicro<float64_t>;
;


template<typename ElemType>
Vfmsac_vf<ElemType>::Vfmsac_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfmsac_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfmsac_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfmsac_vf<float16_t>;
template class Vfmsac_vf<float32_t>;
template class Vfmsac_vf<float64_t>;
;


// VectorFloatFormat::vfnmsac_vf(['\n                        auto fd = fmadd<et>(\n                            fneg(ftype_freg<et>(freg(Fs1_bits))),\n                            ftype<et>(Vs2_vu[i]),\n                            ftype<et>(Vs3_vu[i])\n                        );\n                        Vd_vu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})

template<typename ElemType>
Vfnmsac_vfMicro<ElemType>::Vfnmsac_vfMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfnmsac_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfnmsac_vfMicro<float16_t>;
template class Vfnmsac_vfMicro<float32_t>;
template class Vfnmsac_vfMicro<float64_t>;
;


template<typename ElemType>
Vfnmsac_vf<ElemType>::Vfnmsac_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfnmsac_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfnmsac_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfnmsac_vf<float16_t>;
template class Vfnmsac_vf<float32_t>;
template class Vfnmsac_vf<float64_t>;
;


// VectorFloatWideningFormat::vfwadd_vf(['\n                        auto fd = fadd<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template<typename ElemType>
Vfwadd_vfMicro<ElemType>::Vfwadd_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwadd_vf_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwadd_vfMicro<float16_t>;
template class Vfwadd_vfMicro<float32_t>;
;



template<typename ElemType>
Vfwadd_vf<ElemType>::Vfwadd_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwadd_vf", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwadd_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwadd_vf<float16_t>;
template class Vfwadd_vf<float32_t>;
;


// VectorFloatWideningFormat::vfwsub_vf(['\n                        auto fd = fsub<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template<typename ElemType>
Vfwsub_vfMicro<ElemType>::Vfwsub_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwsub_vf_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwsub_vfMicro<float16_t>;
template class Vfwsub_vfMicro<float32_t>;
;



template<typename ElemType>
Vfwsub_vf<ElemType>::Vfwsub_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwsub_vf", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwsub_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwsub_vf<float16_t>;
template class Vfwsub_vf<float32_t>;
;


// VectorFloatWideningFormat::vfwadd_wf(['\n                        auto fd = fadd<ewt>(\n                            ftype<ewt>(Vs2_vwu[i]),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template<typename ElemType>
Vfwadd_wfMicro<ElemType>::Vfwadd_wfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwadd_wf_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwadd_wfMicro<float16_t>;
template class Vfwadd_wfMicro<float32_t>;
;



template<typename ElemType>
Vfwadd_wf<ElemType>::Vfwadd_wf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwadd_wf", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwadd_wfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwadd_wf<float16_t>;
template class Vfwadd_wf<float32_t>;
;


// VectorFloatWideningFormat::vfwsub_wf(['\n                        auto fd = fsub<ewt>(\n                            ftype<ewt>(Vs2_vwu[i]),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatAddOp'],{})


template<typename ElemType>
Vfwsub_wfMicro<ElemType>::Vfwsub_wfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwsub_wf_micro", _machInst,
                     SimdFloatAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwsub_wfMicro<float16_t>;
template class Vfwsub_wfMicro<float32_t>;
;



template<typename ElemType>
Vfwsub_wf<ElemType>::Vfwsub_wf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwsub_wf", _machInst, SimdFloatAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwsub_wfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwsub_wf<float16_t>;
template class Vfwsub_wf<float32_t>;
;


// VectorFloatWideningFormat::vfwmul_vf(['\n                        auto fd = fmul<ewt>(\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultOp'],{})


template<typename ElemType>
Vfwmul_vfMicro<ElemType>::Vfwmul_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwmul_vf_micro", _machInst,
                     SimdFloatMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwmul_vfMicro<float16_t>;
template class Vfwmul_vfMicro<float32_t>;
;



template<typename ElemType>
Vfwmul_vf<ElemType>::Vfwmul_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwmul_vf", _machInst, SimdFloatMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwmul_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwmul_vf<float16_t>;
template class Vfwmul_vf<float32_t>;
;


// VectorFloatWideningFormat::vfwmacc_vf(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            ftype<ewt>(Vs3_vwu[i]));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template<typename ElemType>
Vfwmacc_vfMicro<ElemType>::Vfwmacc_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwmacc_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwmacc_vfMicro<float16_t>;
template class Vfwmacc_vfMicro<float32_t>;
;



template<typename ElemType>
Vfwmacc_vf<ElemType>::Vfwmacc_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwmacc_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwmacc_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwmacc_vf<float16_t>;
template class Vfwmacc_vf<float32_t>;
;


// VectorFloatWideningFormat::vfwnmacc_vf(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(fneg(ftype_freg<et>(freg(Fs1_bits)))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fneg(ftype<ewt>(Vs3_vwu[i])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template<typename ElemType>
Vfwnmacc_vfMicro<ElemType>::Vfwnmacc_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwnmacc_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwnmacc_vfMicro<float16_t>;
template class Vfwnmacc_vfMicro<float32_t>;
;



template<typename ElemType>
Vfwnmacc_vf<ElemType>::Vfwnmacc_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwnmacc_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwnmacc_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwnmacc_vf<float16_t>;
template class Vfwnmacc_vf<float32_t>;
;


// VectorFloatWideningFormat::vfwmsac_vf(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(ftype_freg<et>(freg(Fs1_bits))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            fneg(ftype<ewt>(Vs3_vwu[i])));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template<typename ElemType>
Vfwmsac_vfMicro<ElemType>::Vfwmsac_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwmsac_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwmsac_vfMicro<float16_t>;
template class Vfwmsac_vfMicro<float32_t>;
;



template<typename ElemType>
Vfwmsac_vf<ElemType>::Vfwmsac_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwmsac_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwmsac_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwmsac_vf<float16_t>;
template class Vfwmsac_vf<float32_t>;
;


// VectorFloatWideningFormat::vfwnmsac_vf(['\n                        auto fd = fmadd<ewt>(\n                            fwiden(fneg(ftype_freg<et>(freg(Fs1_bits)))),\n                            fwiden(ftype<et>(Vs2_vu[i + offset])),\n                            ftype<ewt>(Vs3_vwu[i]));\n                        Vd_vwu[i] = fd.v;\n                    ', 'OPFVF', 'SimdFloatMultAccOp'],{})


template<typename ElemType>
Vfwnmsac_vfMicro<ElemType>::Vfwnmsac_vfMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vfwnmsac_vf_micro", _machInst,
                     SimdFloatMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, floatRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vfwnmsac_vfMicro<float16_t>;
template class Vfwnmsac_vfMicro<float32_t>;
;



template<typename ElemType>
Vfwnmsac_vf<ElemType>::Vfwnmsac_vf(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vfwnmsac_vf", _machInst, SimdFloatMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[FS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsFloating] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vfwnmsac_vfMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vfwnmsac_vf<float16_t>;
template class Vfwnmsac_vf<float32_t>;
;


// Unknown::unknown(([], {}))

// VectorIntFormat::vaaddu_vx(['\n                        __uint128_t res = (__uint128_t)Vs2_vu[i] + Rs1_vu;\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vu[i] = res >> 1;\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vaaddu_vxMicro<ElemType>::Vaaddu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vaaddu_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vaaddu_vxMicro<uint8_t>;
template class Vaaddu_vxMicro<uint16_t>;
template class Vaaddu_vxMicro<uint32_t>;
template class Vaaddu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vaaddu_vx<ElemType>::Vaaddu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vaaddu_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vaaddu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vaaddu_vx<uint8_t>;
template class Vaaddu_vx<uint16_t>;
template class Vaaddu_vx<uint32_t>;
template class Vaaddu_vx<uint64_t>;
;


// VectorIntFormat::vaadd_vx(['\n                        __uint128_t res = (__uint128_t)Vs2_vi[i] + Rs1_vi;\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vi[i] = res >> 1;\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vaadd_vxMicro<ElemType>::Vaadd_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vaadd_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vaadd_vxMicro<uint8_t>;
template class Vaadd_vxMicro<uint16_t>;
template class Vaadd_vxMicro<uint32_t>;
template class Vaadd_vxMicro<uint64_t>;
;



template<typename ElemType>
Vaadd_vx<ElemType>::Vaadd_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vaadd_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vaadd_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vaadd_vx<uint8_t>;
template class Vaadd_vx<uint16_t>;
template class Vaadd_vx<uint32_t>;
template class Vaadd_vx<uint64_t>;
;


// VectorSlideUpFormat::vslide1up_vx((['\n                    const int offset = 1;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vdIdx - vs2Idx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int elemOffset = vdOffset + vdIdx * microVlmax;\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            if (this->vm || elem_mask(v0, i + elemOffset)) {\n                                Vd_vu[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                            }\n                        }\n                        // TODO: dirty code\n                        if (vdIdx == 0 && vs2Idx == 0 &&\n                                (this->vm || elem_mask(v0, 0))) {\n                            tmp_d0.as<vu>()[0] = Rs1_vu;\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Vslide1up_vxMicro<ElemType>::Vslide1up_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx, uint32_t _vdIdx,
        uint32_t _vs2Idx)
    : VectorSlideMicroInst("vslide1up_vx_micro", _machInst, SimdMiscOp, _microVl,
        _microIdx, _vdIdx, _vs2Idx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vdIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2Idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vslide1up_vxMicro<uint8_t>;
template class Vslide1up_vxMicro<uint16_t>;
template class Vslide1up_vxMicro<uint32_t>;
template class Vslide1up_vxMicro<uint64_t>;
;



template<typename ElemType>
Vslide1up_vx<ElemType>::Vslide1up_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorSlideMacroInst("vslide1up_vx", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; i < ceil((float) this->vl/micro_vlmax); i++) {
        microop = new VPinVdMicroInst(machInst, i, i+1, true);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    // Todo static filter out useless uop
    int micro_idx = 0;
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        for (int j = 0; j <= i; ++j) {
            microop = new Vslide1up_vxMicro<ElemType>(
                _machInst, micro_vl, micro_idx++, i, j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vslide1up_vx<uint8_t>;
template class Vslide1up_vx<uint16_t>;
template class Vslide1up_vx<uint32_t>;
template class Vslide1up_vx<uint64_t>;
;


// VectorSlideDownFormat::vslide1down_vx((['\n                    const int offset = 1;\n                    const int microVlmax = vtype_VLMAX(machInst.vtype8,\n                        vlen, true);\n                    const int vregOffset = vs2Idx - vdIdx;\n                    const int offsetInVreg = offset - vregOffset * microVlmax;\n                    const int numVs2s = vtype_regs_per_group(vtype);\n                    if (std::abs(offsetInVreg) < uint32_t(microVlmax)) {\n                        const bool needZeroTail = numVs2s == vs2Idx + 1;\n                        const int upperBound = (offsetInVreg >= 0)\n                            ? microVlmax - offsetInVreg\n                            : microVlmax + offsetInVreg;\n                        const int vdOffset = (offsetInVreg >= 0)\n                            ? 0\n                            : -offsetInVreg;\n                        const int vs2Offset = (offsetInVreg >= 0)\n                            ? offsetInVreg\n                            : 0;\n                        const int elemIdxBase = vdIdx * microVlmax;\n                        vreg_t resVreg;\n                        auto res = resVreg.as<vu>();\n                        for (int i = 0;\n                            i < upperBound && i + vdOffset < microVl;\n                            i++) {\n                            res[i + vdOffset] = Vs2_vu[i + vs2Offset];\n                        }\n                        if (needZeroTail) {\n                            for (int i = upperBound + vdOffset;\n                                i < microVlmax; i++) {\n                                res[i] = 0;\n                            }\n                        }\n                        for (int i = vdOffset; i < microVl ; i++) {\n                            if (vm || elem_mask(v0, i + elemIdxBase)) {\n                                Vd_vu[i] = (i + elemIdxBase != machInst.vl - 1)\n                                    ? res[i]\n                                    : Rs1_vu;\n                            }\n                        }\n                    }\n                ', 'OPIVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Vslide1down_vxMicro<ElemType>::Vslide1down_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx, uint32_t _vdIdx,
        uint32_t _vs2Idx)
    : VectorSlideMicroInst("vslide1down_vx_micro", _machInst, SimdMiscOp, _microVl,
        _microIdx, _vdIdx, _vs2Idx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + vdIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + vs2Idx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vslide1down_vxMicro<uint8_t>;
template class Vslide1down_vxMicro<uint16_t>;
template class Vslide1down_vxMicro<uint32_t>;
template class Vslide1down_vxMicro<uint64_t>;
;



template<typename ElemType>
Vslide1down_vx<ElemType>::Vslide1down_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorSlideMacroInst("vslide1down_vx", _machInst, SimdMiscOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }

    for (uint32_t i = 0; i < ceil((float) this->vl / micro_vlmax); i++) {
        microop = new VPinVdMicroInst(machInst, i, num_microops-i, false);
        microop->setFlag(IsDelayedCommit);
        this->microops.push_back(microop);
    }

    // Todo static filter out useless uop
    int micro_idx = 0;
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        for (int j = i; j < num_microops; ++j) {
            microop = new Vslide1down_vxMicro<ElemType>(
                _machInst, micro_vl, micro_idx++, i, j);
            microop->setDelayedCommit();
            this->microops.push_back(microop);
        }
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }
    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vslide1down_vx<uint8_t>;
template class Vslide1down_vx<uint16_t>;
template class Vslide1down_vx<uint32_t>;
template class Vslide1down_vx<uint64_t>;
;


// VectorNonSplitFormat::vmv_s_x((['\n                            if (this->vl) {\n                                Vd_vu[0] = Rs1_vu;\n                            }\n                        ', 'OPMVX', 'SimdMiscOp'], {}))


template<typename ElemType>
Vmv_s_x<ElemType>::Vmv_s_x(ExtMachInst _machInst)
    : VectorNonSplitInst("vmv_s_x", _machInst, SimdMiscOp)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    ;
}

template class Vmv_s_x<uint8_t>;
template class Vmv_s_x<uint16_t>;
template class Vmv_s_x<uint32_t>;
template class Vmv_s_x<uint64_t>;
;


// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VectorIntFormat::vasubu_vx(['\n                        __uint128_t res = (__uint128_t)Vs2_vu[i] - Rs1_vu;\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vu[i] = res >> 1;\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vasubu_vxMicro<ElemType>::Vasubu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vasubu_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vasubu_vxMicro<uint8_t>;
template class Vasubu_vxMicro<uint16_t>;
template class Vasubu_vxMicro<uint32_t>;
template class Vasubu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vasubu_vx<ElemType>::Vasubu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vasubu_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vasubu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vasubu_vx<uint8_t>;
template class Vasubu_vx<uint16_t>;
template class Vasubu_vx<uint32_t>;
template class Vasubu_vx<uint64_t>;
;


// VectorIntFormat::vasub_vx(['\n                        __uint128_t res = (__uint128_t)Vs2_vi[i] - Rs1_vi;\n                        res = int_rounding<__uint128_t>(res, 0 /* TODO */, 1);\n                        Vd_vi[i] = res >> 1;\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vasub_vxMicro<ElemType>::Vasub_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vasub_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vasub_vxMicro<uint8_t>;
template class Vasub_vxMicro<uint16_t>;
template class Vasub_vxMicro<uint32_t>;
template class Vasub_vxMicro<uint64_t>;
;



template<typename ElemType>
Vasub_vx<ElemType>::Vasub_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vasub_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vasub_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vasub_vx<uint8_t>;
template class Vasub_vx<uint16_t>;
template class Vasub_vx<uint32_t>;
template class Vasub_vx<uint64_t>;
;


// VectorIntFormat::vdivu_vx(['\n                        Vd_vu[i] = divu<vu>(Vs2_vu[i], Rs1_vu);\n                    ', 'OPMVX', 'SimdDivOp'],{})


template<typename ElemType>
Vdivu_vxMicro<ElemType>::Vdivu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vdivu_vx_micro", _machInst,
                     SimdDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vdivu_vxMicro<uint8_t>;
template class Vdivu_vxMicro<uint16_t>;
template class Vdivu_vxMicro<uint32_t>;
template class Vdivu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vdivu_vx<ElemType>::Vdivu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vdivu_vx", _machInst, SimdDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vdivu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vdivu_vx<uint8_t>;
template class Vdivu_vx<uint16_t>;
template class Vdivu_vx<uint32_t>;
template class Vdivu_vx<uint64_t>;
;


// VectorIntFormat::vdiv_vx(['\n                        Vd_vi[i] = div<vi>(Vs2_vi[i], Rs1_vi);\n                    ', 'OPMVX', 'SimdDivOp'],{})


template<typename ElemType>
Vdiv_vxMicro<ElemType>::Vdiv_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vdiv_vx_micro", _machInst,
                     SimdDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vdiv_vxMicro<uint8_t>;
template class Vdiv_vxMicro<uint16_t>;
template class Vdiv_vxMicro<uint32_t>;
template class Vdiv_vxMicro<uint64_t>;
;



template<typename ElemType>
Vdiv_vx<ElemType>::Vdiv_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vdiv_vx", _machInst, SimdDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vdiv_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vdiv_vx<uint8_t>;
template class Vdiv_vx<uint16_t>;
template class Vdiv_vx<uint32_t>;
template class Vdiv_vx<uint64_t>;
;


// VectorIntFormat::vremu_vx(['\n                        Vd_vu[i] = remu<vu>(Vs2_vu[i], Rs1_vu);\n                    ', 'OPMVX', 'SimdDivOp'],{})


template<typename ElemType>
Vremu_vxMicro<ElemType>::Vremu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vremu_vx_micro", _machInst,
                     SimdDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vremu_vxMicro<uint8_t>;
template class Vremu_vxMicro<uint16_t>;
template class Vremu_vxMicro<uint32_t>;
template class Vremu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vremu_vx<ElemType>::Vremu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vremu_vx", _machInst, SimdDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vremu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vremu_vx<uint8_t>;
template class Vremu_vx<uint16_t>;
template class Vremu_vx<uint32_t>;
template class Vremu_vx<uint64_t>;
;


// VectorIntFormat::vrem_vx(['\n                        Vd_vi[i] = rem<vi>(Vs2_vi[i], Rs1_vi);\n                    ', 'OPMVX', 'SimdDivOp'],{})


template<typename ElemType>
Vrem_vxMicro<ElemType>::Vrem_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vrem_vx_micro", _machInst,
                     SimdDivOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vrem_vxMicro<uint8_t>;
template class Vrem_vxMicro<uint16_t>;
template class Vrem_vxMicro<uint32_t>;
template class Vrem_vxMicro<uint64_t>;
;



template<typename ElemType>
Vrem_vx<ElemType>::Vrem_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vrem_vx", _machInst, SimdDivOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vrem_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vrem_vx<uint8_t>;
template class Vrem_vx<uint16_t>;
template class Vrem_vx<uint32_t>;
template class Vrem_vx<uint64_t>;
;


// VectorIntFormat::vmulhu_vx(['\n                        Vd_vu[i] = mulhu<vu>(Vs2_vu[i], Rs1_vu);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template<typename ElemType>
Vmulhu_vxMicro<ElemType>::Vmulhu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmulhu_vx_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmulhu_vxMicro<uint8_t>;
template class Vmulhu_vxMicro<uint16_t>;
template class Vmulhu_vxMicro<uint32_t>;
template class Vmulhu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmulhu_vx<ElemType>::Vmulhu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmulhu_vx", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmulhu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmulhu_vx<uint8_t>;
template class Vmulhu_vx<uint16_t>;
template class Vmulhu_vx<uint32_t>;
template class Vmulhu_vx<uint64_t>;
;


// VectorIntFormat::vmul_vx(['\n                        Vd_vi[i] = Vs2_vi[i] * Rs1_vi;\n                    ', 'OPMVX', 'SimdMultOp'],{})


template<typename ElemType>
Vmul_vxMicro<ElemType>::Vmul_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmul_vx_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmul_vxMicro<uint8_t>;
template class Vmul_vxMicro<uint16_t>;
template class Vmul_vxMicro<uint32_t>;
template class Vmul_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmul_vx<ElemType>::Vmul_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmul_vx", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmul_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmul_vx<uint8_t>;
template class Vmul_vx<uint16_t>;
template class Vmul_vx<uint32_t>;
template class Vmul_vx<uint64_t>;
;


// VectorIntFormat::vmulhsu_vx(['\n                        Vd_vi[i] = mulhsu<vi>(Vs2_vi[i], Rs1_vu);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template<typename ElemType>
Vmulhsu_vxMicro<ElemType>::Vmulhsu_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmulhsu_vx_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmulhsu_vxMicro<uint8_t>;
template class Vmulhsu_vxMicro<uint16_t>;
template class Vmulhsu_vxMicro<uint32_t>;
template class Vmulhsu_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmulhsu_vx<ElemType>::Vmulhsu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmulhsu_vx", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmulhsu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmulhsu_vx<uint8_t>;
template class Vmulhsu_vx<uint16_t>;
template class Vmulhsu_vx<uint32_t>;
template class Vmulhsu_vx<uint64_t>;
;


// VectorIntFormat::vmulh_vx(['\n                        Vd_vi[i] = mulh<vi>(Vs2_vi[i], Rs1_vi);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template<typename ElemType>
Vmulh_vxMicro<ElemType>::Vmulh_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmulh_vx_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmulh_vxMicro<uint8_t>;
template class Vmulh_vxMicro<uint16_t>;
template class Vmulh_vxMicro<uint32_t>;
template class Vmulh_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmulh_vx<ElemType>::Vmulh_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmulh_vx", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmulh_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmulh_vx<uint8_t>;
template class Vmulh_vx<uint16_t>;
template class Vmulh_vx<uint32_t>;
template class Vmulh_vx<uint64_t>;
;


// VectorIntFormat::vmadd_vx(['\n                        Vd_vi[i] = Vs3_vi[i] * Rs1_vi + Vs2_vi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template<typename ElemType>
Vmadd_vxMicro<ElemType>::Vmadd_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmadd_vx_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmadd_vxMicro<uint8_t>;
template class Vmadd_vxMicro<uint16_t>;
template class Vmadd_vxMicro<uint32_t>;
template class Vmadd_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmadd_vx<ElemType>::Vmadd_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmadd_vx", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmadd_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmadd_vx<uint8_t>;
template class Vmadd_vx<uint16_t>;
template class Vmadd_vx<uint32_t>;
template class Vmadd_vx<uint64_t>;
;


// VectorIntFormat::vnmsub_vx(['\n                        Vd_vi[i] = -(Vs3_vi[i] * Rs1_vi) + Vs2_vi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template<typename ElemType>
Vnmsub_vxMicro<ElemType>::Vnmsub_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnmsub_vx_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnmsub_vxMicro<uint8_t>;
template class Vnmsub_vxMicro<uint16_t>;
template class Vnmsub_vxMicro<uint32_t>;
template class Vnmsub_vxMicro<uint64_t>;
;



template<typename ElemType>
Vnmsub_vx<ElemType>::Vnmsub_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnmsub_vx", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnmsub_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnmsub_vx<uint8_t>;
template class Vnmsub_vx<uint16_t>;
template class Vnmsub_vx<uint32_t>;
template class Vnmsub_vx<uint64_t>;
;


// VectorIntFormat::vmacc_vx(['\n                        Vd_vi[i] = Vs2_vi[i] * Rs1_vi + Vs3_vi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template<typename ElemType>
Vmacc_vxMicro<ElemType>::Vmacc_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vmacc_vx_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vmacc_vxMicro<uint8_t>;
template class Vmacc_vxMicro<uint16_t>;
template class Vmacc_vxMicro<uint32_t>;
template class Vmacc_vxMicro<uint64_t>;
;



template<typename ElemType>
Vmacc_vx<ElemType>::Vmacc_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vmacc_vx", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vmacc_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vmacc_vx<uint8_t>;
template class Vmacc_vx<uint16_t>;
template class Vmacc_vx<uint32_t>;
template class Vmacc_vx<uint64_t>;
;


// VectorIntFormat::vnmsac_vx(['\n                        Vd_vi[i] = -(Vs2_vi[i] * Rs1_vi) + Vs3_vi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template<typename ElemType>
Vnmsac_vxMicro<ElemType>::Vnmsac_vxMicro(ExtMachInst _machInst,
                                         uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vnmsac_vx_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vnmsac_vxMicro<uint8_t>;
template class Vnmsac_vxMicro<uint16_t>;
template class Vnmsac_vxMicro<uint32_t>;
template class Vnmsac_vxMicro<uint64_t>;
;



template<typename ElemType>
Vnmsac_vx<ElemType>::Vnmsac_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vnmsac_vx", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const uint32_t num_microops = vtype_regs_per_group(vtype);
    int32_t tmp_vl = this->vl;
    const int32_t micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vnmsac_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vnmsac_vx<uint8_t>;
template class Vnmsac_vx<uint16_t>;
template class Vnmsac_vx<uint32_t>;
template class Vnmsac_vx<uint64_t>;
;


// VectorIntWideningFormat::vwaddu_vx(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset]) + vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vwaddu_vxMicro<ElemType>::Vwaddu_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwaddu_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwaddu_vxMicro<uint8_t>;
template class Vwaddu_vxMicro<uint16_t>;
template class Vwaddu_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwaddu_vx<ElemType>::Vwaddu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwaddu_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwaddu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwaddu_vx<uint8_t>;
template class Vwaddu_vx<uint16_t>;
template class Vwaddu_vx<uint32_t>;
;


// VectorIntWideningFormat::vwadd_vx(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset]) + vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vwadd_vxMicro<ElemType>::Vwadd_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwadd_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwadd_vxMicro<uint8_t>;
template class Vwadd_vxMicro<uint16_t>;
template class Vwadd_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwadd_vx<ElemType>::Vwadd_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwadd_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwadd_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwadd_vx<uint8_t>;
template class Vwadd_vx<uint16_t>;
template class Vwadd_vx<uint32_t>;
;


// VectorIntWideningFormat::vwsubu_vx(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset]) - vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vwsubu_vxMicro<ElemType>::Vwsubu_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwsubu_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwsubu_vxMicro<uint8_t>;
template class Vwsubu_vxMicro<uint16_t>;
template class Vwsubu_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwsubu_vx<ElemType>::Vwsubu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwsubu_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwsubu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwsubu_vx<uint8_t>;
template class Vwsubu_vx<uint16_t>;
template class Vwsubu_vx<uint32_t>;
;


// VectorIntWideningFormat::vwsub_vx(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset]) - vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vwsub_vxMicro<ElemType>::Vwsub_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwsub_vx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwsub_vxMicro<uint8_t>;
template class Vwsub_vxMicro<uint16_t>;
template class Vwsub_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwsub_vx<ElemType>::Vwsub_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwsub_vx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwsub_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwsub_vx<uint8_t>;
template class Vwsub_vx<uint16_t>;
template class Vwsub_vx<uint32_t>;
;


// VectorIntWideningFormat::vwaddu_wx(['\n                        Vd_vwu[i] = Vs2_vwu[i] + vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vwaddu_wxMicro<ElemType>::Vwaddu_wxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwaddu_wx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwaddu_wxMicro<uint8_t>;
template class Vwaddu_wxMicro<uint16_t>;
template class Vwaddu_wxMicro<uint32_t>;
;



template<typename ElemType>
Vwaddu_wx<ElemType>::Vwaddu_wx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwaddu_wx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwaddu_wxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwaddu_wx<uint8_t>;
template class Vwaddu_wx<uint16_t>;
template class Vwaddu_wx<uint32_t>;
;


// VectorIntWideningFormat::vwadd_wx(['\n                        Vd_vwi[i] = Vs2_vwi[i] + vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vwadd_wxMicro<ElemType>::Vwadd_wxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwadd_wx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwadd_wxMicro<uint8_t>;
template class Vwadd_wxMicro<uint16_t>;
template class Vwadd_wxMicro<uint32_t>;
;



template<typename ElemType>
Vwadd_wx<ElemType>::Vwadd_wx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwadd_wx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwadd_wxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwadd_wx<uint8_t>;
template class Vwadd_wx<uint16_t>;
template class Vwadd_wx<uint32_t>;
;


// VectorIntWideningFormat::vwsubu_wx(['\n                        Vd_vwu[i] = Vs2_vwu[i] - vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vwsubu_wxMicro<ElemType>::Vwsubu_wxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwsubu_wx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwsubu_wxMicro<uint8_t>;
template class Vwsubu_wxMicro<uint16_t>;
template class Vwsubu_wxMicro<uint32_t>;
;



template<typename ElemType>
Vwsubu_wx<ElemType>::Vwsubu_wx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwsubu_wx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwsubu_wxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwsubu_wx<uint8_t>;
template class Vwsubu_wx<uint16_t>;
template class Vwsubu_wx<uint32_t>;
;


// VectorIntWideningFormat::vwsub_wx(['\n                        Vd_vwi[i] = Vs2_vwi[i] - vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdAddOp'],{})


template<typename ElemType>
Vwsub_wxMicro<ElemType>::Vwsub_wxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwsub_wx_micro", _machInst,
                     SimdAddOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwsub_wxMicro<uint8_t>;
template class Vwsub_wxMicro<uint16_t>;
template class Vwsub_wxMicro<uint32_t>;
;



template<typename ElemType>
Vwsub_wx<ElemType>::Vwsub_wx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwsub_wx", _machInst, SimdAddOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwsub_wxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwsub_wx<uint8_t>;
template class Vwsub_wx<uint16_t>;
template class Vwsub_wx<uint32_t>;
;


// VectorIntWideningFormat::vwmulu_vx(['\n                        Vd_vwu[i] = vwu(Vs2_vu[i + offset]) * vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template<typename ElemType>
Vwmulu_vxMicro<ElemType>::Vwmulu_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmulu_vx_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmulu_vxMicro<uint8_t>;
template class Vwmulu_vxMicro<uint16_t>;
template class Vwmulu_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwmulu_vx<ElemType>::Vwmulu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmulu_vx", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmulu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmulu_vx<uint8_t>;
template class Vwmulu_vx<uint16_t>;
template class Vwmulu_vx<uint32_t>;
;


// VectorIntWideningFormat::vwmulsu_vx(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset]) * vwu(Rs1_vu);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template<typename ElemType>
Vwmulsu_vxMicro<ElemType>::Vwmulsu_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmulsu_vx_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmulsu_vxMicro<uint8_t>;
template class Vwmulsu_vxMicro<uint16_t>;
template class Vwmulsu_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwmulsu_vx<ElemType>::Vwmulsu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmulsu_vx", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmulsu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmulsu_vx<uint8_t>;
template class Vwmulsu_vx<uint16_t>;
template class Vwmulsu_vx<uint32_t>;
;


// VectorIntWideningFormat::vwmul_vx(['\n                        Vd_vwi[i] = vwi(Vs2_vi[i + offset]) * vwi(Rs1_vi);\n                    ', 'OPMVX', 'SimdMultOp'],{})


template<typename ElemType>
Vwmul_vxMicro<ElemType>::Vwmul_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmul_vx_micro", _machInst,
                     SimdMultOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);

        if (!_machInst.vtype8.vta || (!_machInst.vm && !_machInst.vtype8.vma))
            setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);

        if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmul_vxMicro<uint8_t>;
template class Vwmul_vxMicro<uint16_t>;
template class Vwmul_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwmul_vx<ElemType>::Vwmul_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmul_vx", _machInst, SimdMultOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmul_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmul_vx<uint8_t>;
template class Vwmul_vx<uint16_t>;
template class Vwmul_vx<uint32_t>;
;


// VectorIntWideningFormat::vwmaccu_vx(['\n                        Vd_vwu[i] = vwu(Rs1_vu) * vwu(Vs2_vu[i + offset])\n                                + Vs3_vwu[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template<typename ElemType>
Vwmaccu_vxMicro<ElemType>::Vwmaccu_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmaccu_vx_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmaccu_vxMicro<uint8_t>;
template class Vwmaccu_vxMicro<uint16_t>;
template class Vwmaccu_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwmaccu_vx<ElemType>::Vwmaccu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmaccu_vx", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmaccu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmaccu_vx<uint8_t>;
template class Vwmaccu_vx<uint16_t>;
template class Vwmaccu_vx<uint32_t>;
;


// VectorIntWideningFormat::vwmacc_vx(['\n                        Vd_vwi[i] = vwi(Rs1_vi) * vwi(Vs2_vi[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template<typename ElemType>
Vwmacc_vxMicro<ElemType>::Vwmacc_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmacc_vx_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmacc_vxMicro<uint8_t>;
template class Vwmacc_vxMicro<uint16_t>;
template class Vwmacc_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwmacc_vx<ElemType>::Vwmacc_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmacc_vx", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmacc_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmacc_vx<uint8_t>;
template class Vwmacc_vx<uint16_t>;
template class Vwmacc_vx<uint32_t>;
;


// VectorIntWideningFormat::vwmaccus_vx(['\n                        Vd_vwi[i] = vwu(Rs1_vu) * vwi(Vs2_vi[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template<typename ElemType>
Vwmaccus_vxMicro<ElemType>::Vwmaccus_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmaccus_vx_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmaccus_vxMicro<uint8_t>;
template class Vwmaccus_vxMicro<uint16_t>;
template class Vwmaccus_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwmaccus_vx<ElemType>::Vwmaccus_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmaccus_vx", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmaccus_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmaccus_vx<uint8_t>;
template class Vwmaccus_vx<uint16_t>;
template class Vwmaccus_vx<uint32_t>;
;


// VectorIntWideningFormat::vwmaccsu_vx(['\n                        Vd_vwi[i] = vwi(Rs1_vi) * vwu(Vs2_vu[i + offset])\n                                + Vs3_vwi[i];\n                    ', 'OPMVX', 'SimdMultAccOp'],{})


template<typename ElemType>
Vwmaccsu_vxMicro<ElemType>::Vwmaccsu_vxMicro(ExtMachInst _machInst,
        uint32_t _microVl, uint32_t _microIdx)
    : VectorArithMicroInst("vwmaccsu_vx_micro", _machInst,
                     SimdMultAccOp, _microVl, _microIdx)
{
    this->vm = _machInst.vm;
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    _numSrcRegs = 0;
    _numDestRegs = 0;
    setDestRegIdx(_numDestRegs++, vecRegClass[_machInst.vd + _microIdx]);
_numTypedDestRegs[VecRegClass]++;
;
    setSrcRegIdx(_numSrcRegs++, intRegClass[_machInst.rs1]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vs2 + _microIdx / 2]);
setSrcRegIdx(_numSrcRegs++, vecRegClass[_machInst.vd + _microIdx]);
if (!this->vm)
    setSrcRegIdx(_numSrcRegs++, vecRegClass[0]);;
}

template class Vwmaccsu_vxMicro<uint8_t>;
template class Vwmaccsu_vxMicro<uint16_t>;
template class Vwmaccsu_vxMicro<uint32_t>;
;



template<typename ElemType>
Vwmaccsu_vx<ElemType>::Vwmaccsu_vx(ExtMachInst _machInst, uint32_t _vlen)
    : VectorArithMacroInst("vwmaccsu_vx", _machInst, SimdMultAccOp, _vlen)
{
    
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
    
	setDestRegIdx(_numDestRegs++, vecRegClass[VD]);
	_numTypedDestRegs[vecRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS2]);
	setSrcRegIdx(_numSrcRegs++, vecRegClass[VS3]);
	flags[IsInteger] = true;
	flags[IsVector] = true;;
    const int64_t vlmul = vtype_vlmul(_machInst.vtype8);
    // Todo: move to Decode template
    panic_if(vlmul == 3, "LMUL=8 is illegal for widening inst");
    // when LMUL setted as m1, need to split to 2 micro insts
    const uint32_t num_microops = 1 << std::max<int64_t>(0, vlmul + 1);

    int32_t tmp_vl = this->vl;
    const int32_t t_micro_vlmax = vtype_VLMAX(_machInst.vtype8, vlen, true);
    const int32_t micro_vlmax = vlmul < 0 ? t_micro_vlmax : t_micro_vlmax / 2;
    int32_t micro_vl = std::min(tmp_vl, micro_vlmax);
    StaticInstPtr microop;

    if (micro_vl == 0) {
        microop = new VectorNopMicroInst(_machInst);
        this->microops.push_back(microop);
    }
    for (int i = 0; i < num_microops && micro_vl > 0; ++i) {
        microop = new Vwmaccsu_vxMicro<ElemType>(_machInst, micro_vl, i);
        microop->setDelayedCommit();
        this->microops.push_back(microop);
        micro_vl = std::min(tmp_vl -= micro_vlmax, micro_vlmax);
    }

    this->microops.front()->setFirstMicroop();
    this->microops.back()->setLastMicroop();
}

template class Vwmaccsu_vx<uint8_t>;
template class Vwmaccsu_vx<uint16_t>;
template class Vwmaccsu_vx<uint32_t>;
;


// Unknown::unknown(([], {}))

// VConfOp::vsetvli(['\n                        uint64_t rd_bits = RD;\n                        uint64_t rs1_bits = RS1;\n                        uint64_t requested_vl = Rs1_ud;\n                        uint64_t requested_vtype = zimm11;\n                        uint32_t vlen = VlenbBits * 8;\n                        uint32_t vlmax = getVlmax(Vtype, vlen);\n                        uint32_t current_vl = VL;\n                    ', '\n                        Rd_ud = new_vl;\n                        VL = new_vl;\n                        Vtype = new_vtype;\n                    ', 'VSetVlDeclare', 'VSetVliBranchTarget', 'SimdConfigOp', 'IsUncondControl', 'IsIndirectControl'],{})

Vsetvli::Vsetvli(ExtMachInst _machInst, uint32_t _elen)
    : VConfOp("vsetvli", _machInst, _elen, SimdConfigOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

// VConfOp::vsetvl(['\n                            uint64_t rd_bits = RD;\n                            uint64_t rs1_bits = RS1;\n                            uint64_t requested_vl = Rs1_ud;\n                            uint64_t requested_vtype = Rs2_ud;\n                            uint32_t vlen = VlenbBits * 8;\n                            uint32_t vlmax = getVlmax(Vtype, vlen);\n                            uint32_t current_vl = VL;\n                        ', '\n                            Rd_ud = new_vl;\n                            VL = new_vl;\n                            Vtype = new_vtype;\n                        ', 'VSetVlDeclare', 'VSetVlBranchTarget', 'SimdConfigOp', 'IsUncondControl', 'IsIndirectControl'],{})

Vsetvl::Vsetvl(ExtMachInst _machInst, uint32_t _elen)
    : VConfOp("vsetvl", _machInst, _elen, SimdConfigOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

// VConfOp::vsetivli(['\n                            uint64_t rd_bits = RD;\n                            uint64_t rs1_bits = -1;\n                            uint64_t requested_vl = uimm;\n                            uint64_t requested_vtype = zimm10;\n                            uint32_t vlen = VlenbBits * 8;\n                            uint32_t vlmax = getVlmax(Vtype, vlen);\n                            uint32_t current_vl = VL;\n                        ', '\n                            Rd_ud = new_vl;\n                            VL = new_vl;\n                            Vtype = new_vtype;\n                        ', 'VSetiVliDeclare', 'VSetiVliBranchTarget', 'SimdConfigOp', 'IsUncondControl', 'IsDirectControl'],{})

Vsetivli::Vsetivli(ExtMachInst _machInst, uint32_t _elen)
    : VConfOp("vsetivli", _machInst, _elen, SimdConfigOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// BOp::beq(['\n                    if (rvSext(Rs1) == rvSext(Rs2)) {\n                        NPC = rvZext(PC + imm);\n                    } else {\n                        NPC = rvZext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Beq::Beq(ExtMachInst machInst)
        : ImmOp<int64_t>("beq", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        
                imm = BIMM12BITS4TO1 << 1  |
                      BIMM12BITS10TO5 << 5 |
                      BIMM12BIT11 << 11    |
                      IMMSIGN << 12;
                imm = sext<13>(imm);
               ;
    }

// BOp::bne(['\n                    if (rvSext(Rs1) != rvSext(Rs2)) {\n                        NPC = rvZext(PC + imm);\n                    } else {\n                        NPC = rvZext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Bne::Bne(ExtMachInst machInst)
        : ImmOp<int64_t>("bne", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        
                imm = BIMM12BITS4TO1 << 1  |
                      BIMM12BITS10TO5 << 5 |
                      BIMM12BIT11 << 11    |
                      IMMSIGN << 12;
                imm = sext<13>(imm);
               ;
    }

// BOp::blt(['\n                    if (rvSext(Rs1_sd) < rvSext(Rs2_sd)) {\n                        NPC = rvZext(PC + imm);\n                    } else {\n                        NPC = rvZext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Blt::Blt(ExtMachInst machInst)
        : ImmOp<int64_t>("blt", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        
                imm = BIMM12BITS4TO1 << 1  |
                      BIMM12BITS10TO5 << 5 |
                      BIMM12BIT11 << 11    |
                      IMMSIGN << 12;
                imm = sext<13>(imm);
               ;
    }

// BOp::bge(['\n                    if (rvSext(Rs1_sd) >= rvSext(Rs2_sd)) {\n                        NPC = rvZext(PC + imm);\n                    } else {\n                        NPC = rvZext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Bge::Bge(ExtMachInst machInst)
        : ImmOp<int64_t>("bge", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        
                imm = BIMM12BITS4TO1 << 1  |
                      BIMM12BITS10TO5 << 5 |
                      BIMM12BIT11 << 11    |
                      IMMSIGN << 12;
                imm = sext<13>(imm);
               ;
    }

// BOp::bltu(['\n                    if (rvZext(Rs1) < rvZext(Rs2)) {\n                        NPC = rvZext(PC + imm);\n                    } else {\n                        NPC = rvZext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Bltu::Bltu(ExtMachInst machInst)
        : ImmOp<int64_t>("bltu", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        
                imm = BIMM12BITS4TO1 << 1  |
                      BIMM12BITS10TO5 << 5 |
                      BIMM12BIT11 << 11    |
                      IMMSIGN << 12;
                imm = sext<13>(imm);
               ;
    }

// BOp::bgeu(['\n                    if (rvZext(Rs1) >= rvZext(Rs2)) {\n                        NPC = rvZext(PC + imm);\n                    } else {\n                        NPC = rvZext(NPC);\n                    }\n                ', 'IsDirectControl', 'IsCondControl'],{})

    Bgeu::Bgeu(ExtMachInst machInst)
        : ImmOp<int64_t>("bgeu", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        
                imm = BIMM12BITS4TO1 << 1  |
                      BIMM12BITS10TO5 << 5 |
                      BIMM12BIT11 << 11    |
                      IMMSIGN << 12;
                imm = sext<13>(imm);
               ;
    }

// Unknown::unknown(([], {}))

// Jump::jalr((['\n                Rd = rvSext(NPC);\n                NPC = rvZext((imm + Rs1) & (~0x1));\n            ', 'IsIndirectControl', 'IsUncondControl'], {}))

    Jalr::Jalr(ExtMachInst machInst)
        : ImmOp<int64_t>("jalr", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
        imm = sext<12>(IMM12);;
        if (QUADRANT != 0x3) {
            if (COPCODE == 4) {
                // Handle "c_jr" instruction, set "IsReturn" flag if RC1 is 1 or 5
                if (CFUNCT1 == 0 && (RC1 == 1 || RC1 == 5))
                    flags[IsReturn] = true;
                // Handle "c_jalr" instruction, set IsReturn if RC1 != ra
                if (CFUNCT1 == 1 && RC1 == 5)
                    flags[IsReturn] = true;
            }
        } else {
            bool rd_link = (RD == 1 || RD == 5);
            bool rs1_link = (RS1 == 1 || RS1 == 5);
            // Handle "jalr" and "jal" instruction,
            // set "IsCall" if RD is link register
            if (rd_link)
                flags[IsCall] = true;

            // Handle "Jalr" instruction
            if (FUNCT3 == 0x0 && OPCODE5 == 0x19) {
                // If RD is not link and RS1 is link, then pop RAS
                if (!rd_link && rs1_link) flags[IsReturn] = true;
                else if (rd_link) {
                    // If RD is link and RS1 is not link, push RAS
                    if (!rs1_link) flags[IsCall] = true;
                    // If RD is link and RS1 is link and rd != rs1
                    else if (rs1_link) {
                        if (RS1 != RD) {
                            // Both are link and RS1 == RD, pop then push
                            flags[IsReturn] = true;
                            flags[IsCall] = true;
                        } else {
                            // Both are link and RS1 != RD, push RAS
                            flags[IsCall] = true;
                        }
                    }
                }
            }
        }
    }

// Unknown::unknown(([], {}))

// JOp::jal((['\n            Rd = rvSext(NPC);\n            NPC = rvZext(PC + imm);\n        ', 'IsDirectControl', 'IsUncondControl'], {}))

    Jal::Jal(ExtMachInst machInst)
        : ImmOp<int64_t>("jal", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
        
                imm = UJIMMBITS10TO1 << 1   |
                      UJIMMBIT11 << 11      |
                      UJIMMBITS19TO12 << 12 |
                      IMMSIGN << 20;
                imm = sext<21>(imm);
               ;
        if (QUADRANT != 0x3) {
            if (COPCODE == 4) {
                // Handle "c_jr" instruction, set "IsReturn" flag if RC1 is 1 or 5
                if (CFUNCT1 == 0 && (RC1 == 1 || RC1 == 5))
                    flags[IsReturn] = true;
                // Handle "c_jalr" instruction, set IsReturn if RC1 != ra
                if (CFUNCT1 == 1 && RC1 == 5)
                    flags[IsReturn] = true;
            }
        } else {
            bool rd_link = (RD == 1 || RD == 5);
            bool rs1_link = (RS1 == 1 || RS1 == 5);
            // Handle "jalr" and "jal" instruction,
            // set "IsCall" if RD is link register
            if (rd_link)
                flags[IsCall] = true;

            // Handle "Jalr" instruction
            if (FUNCT3 == 0x0 && OPCODE5 == 0x19) {
                // If RD is not link and RS1 is link, then pop RAS
                if (!rd_link && rs1_link) flags[IsReturn] = true;
                else if (rd_link) {
                    // If RD is link and RS1 is not link, push RAS
                    if (!rs1_link) flags[IsCall] = true;
                    // If RD is link and RS1 is link and rd != rs1
                    else if (rs1_link) {
                        if (RS1 != RD) {
                            // Both are link and RS1 == RD, pop then push
                            flags[IsReturn] = true;
                            flags[IsCall] = true;
                        } else {
                            // Both are link and RS1 != RD, push RAS
                            flags[IsCall] = true;
                        }
                    }
                }
            }
        }
    }

// SystemOp::ecall(['\n                            return std::make_shared<SyscallFault>(\n                                (PrivilegeMode)xc->readMiscReg(MISCREG_PRV));\n                        ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsSyscall', 'No_OpClass'],{})

    Ecall::Ecall(ExtMachInst machInst)
        : SystemOp("ecall", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
    }

// SystemOp::ebreak(['\n                            return executeEBreakOrSemihosting(xc);\n                        ', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Ebreak::Ebreak(ExtMachInst machInst)
        : SystemOp("ebreak", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// SystemOp::uret(['\n                           MISA misa = xc->readMiscReg(MISCREG_ISA);\n                            if (!misa.rvn) {\n                                return std::make_shared<IllegalInstFault>(\n                                    "sret can\'t execute without N systems",\n                                    machInst);\n                            }\n                            STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                            status.uie = status.upie;\n                            status.upie = 1;\n                            xc->setMiscReg(MISCREG_STATUS, status);\n                            NPC = xc->readMiscReg(MISCREG_UEPC);\n                        ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsReturn'],{})

    Uret::Uret(ExtMachInst machInst)
        : SystemOp("uret", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsControl] = true;
	flags[IsNonSpeculative] = true;
	flags[IsReturn] = true;
	flags[IsSerializeAfter] = true;;
    }

// Unknown::unknown(([], {}))

// SystemOp::sret(['\n                            MISA misa = xc->readMiscReg(MISCREG_ISA);\n                            if (!misa.rvs) {\n                                return std::make_shared<IllegalInstFault>(\n                                            "sret can\'t execute without RVS",\n                                            machInst);\n                            }\n                            STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                            auto pm = (PrivilegeMode)xc->readMiscReg(\n                                MISCREG_PRV);\n                            if (pm == PRV_U ||\n                                (pm == PRV_S && status.tsr == 1)) {\n                                return std::make_shared<IllegalInstFault>(\n                                            "sret in user mode or TSR enabled",\n                                            machInst);\n                                NPC = NPC;\n                            } else {\n                                xc->setMiscReg(MISCREG_PRV, status.spp);\n                                status.sie = status.spie;\n                                status.spie = 1;\n                                status.spp = PRV_U;\n                                xc->setMiscReg(MISCREG_STATUS, status);\n                                NPC = xc->readMiscReg(MISCREG_SEPC);\n                            }\n                        ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsReturn'],{})

    Sret::Sret(ExtMachInst machInst)
        : SystemOp("sret", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsControl] = true;
	flags[IsNonSpeculative] = true;
	flags[IsReturn] = true;
	flags[IsSerializeAfter] = true;;
    }

// SystemOp::wfi(['\n                            MISA misa = xc->readMiscReg(MISCREG_ISA);\n                            STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                            auto pm = (PrivilegeMode)xc->readMiscReg(\n                                MISCREG_PRV);\n                            if (misa.rvs && (pm == PRV_U ||\n                                (pm == PRV_S && status.tw == 1))) {\n                                return std::make_shared<IllegalInstFault>(\n                                            "wfi in user mode or TW enabled",\n                                            machInst);\n                            }\n                            // Go to sleep only if there\'s no pending interrupt\n                            // at all, including masked interrupts.\n                            auto tc = xc->tcBase();\n                            auto cpu = tc->getCpuPtr();\n                            auto ic = dynamic_cast<RiscvISA::Interrupts*>(\n                                cpu->getInterruptController(tc->threadId()));\n                            panic_if(!ic, "Invalid Interrupt Controller.");\n                            if (ic->readIP() == 0\n                                && xc->readMiscReg(MISCREG_NMIP) == 0) {\n                                tc->quiesce();\n                            }\n                        ', 'IsNonSpeculative', 'IsQuiesce', 'IsSerializeAfter', 'No_OpClass', 'IsSquashAfter'],{})

    Wfi::Wfi(ExtMachInst machInst)
        : SystemOp("wfi", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
    }

// Unknown::unknown(([], {}))

// SystemOp::sfence_vma(['\n                        MISA misa = xc->readMiscReg(MISCREG_ISA);\n                        if (!misa.rvs) {\n                            return std::make_shared<IllegalInstFault>(\n                                "sfence_vma can\'t execute without RVS",\n                                machInst);\n                        }\n                        STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                        auto pm = (PrivilegeMode)xc->readMiscReg(MISCREG_PRV);\n                        if (pm == PRV_U || (pm == PRV_S && status.tvm == 1)) {\n                            return std::make_shared<IllegalInstFault>(\n                                        "sfence in user mode or TVM enabled",\n                                        machInst);\n                        }\n                        xc->tcBase()->getMMUPtr()->demapPage(Rs1, Rs2);\n                    ', 'IsNonSpeculative', 'IsSerializeAfter', 'No_OpClass'],{})

    Sfence_vma::Sfence_vma(ExtMachInst machInst)
        : SystemOp("sfence_vma", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	setSrcRegIdx(_numSrcRegs++, ((RS2) == 0) ? RegId() : intRegClass[RS2]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// SystemOp::mret(['\n                        if (xc->readMiscReg(MISCREG_PRV) != PRV_M) {\n                            return std::make_shared<IllegalInstFault>(\n                                        "mret at lower privilege", machInst);\n                            NPC = NPC;\n                        } else {\n                            STATUS status = xc->readMiscReg(MISCREG_STATUS);\n                            xc->setMiscReg(MISCREG_PRV, status.mpp);\n                            xc->setMiscReg(MISCREG_NMIE, 1);\n                            status.mie = status.mpie;\n                            status.mpie = 1;\n                            status.mpp = PRV_U;\n                            xc->setMiscReg(MISCREG_STATUS, status);\n                            NPC = xc->readMiscReg(MISCREG_MEPC);\n                        }\n                    ', 'IsSerializeAfter', 'IsNonSpeculative', 'IsReturn'],{})

    Mret::Mret(ExtMachInst machInst)
        : SystemOp("mret", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	flags[IsControl] = true;
	flags[IsNonSpeculative] = true;
	flags[IsReturn] = true;
	flags[IsSerializeAfter] = true;;
    }

// Unknown::unknown(([], {}))

// CSROp::csrrw(['\n                    Rd = rvSext(data);\n                    data = rvZext(Rs1);\n                ', 'RD != 0', 'true', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Csrrw::Csrrw(ExtMachInst machInst)
        : CSROp("csrrw", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// CSROp::csrrs(['\n                    Rd = rvSext(data);\n                    data = rvZext(data | Rs1);\n                ', 'true', 'RS1 != 0', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Csrrs::Csrrs(ExtMachInst machInst)
        : CSROp("csrrs", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// CSROp::csrrc(['\n                    Rd = rvSext(data);\n                    data = rvZext(data & ~Rs1);\n                ', 'true', 'RS1 != 0', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Csrrc::Csrrc(ExtMachInst machInst)
        : CSROp("csrrc", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((RS1) == 0) ? RegId() : intRegClass[RS1]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// CSROp::csrrwi(['\n                    Rd = rvSext(data);\n                    data = rvZext(uimm);\n                ', 'RD != 0', 'true', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Csrrwi::Csrrwi(ExtMachInst machInst)
        : CSROp("csrrwi", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// CSROp::csrrsi(['\n                    Rd = rvSext(data);\n                    data = rvZext(data | uimm);\n                ', 'true', 'uimm != 0', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Csrrsi::Csrrsi(ExtMachInst machInst)
        : CSROp("csrrsi", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// CSROp::csrrci(['\n                    Rd = rvSext(data);\n                    data = rvZext(data & ~uimm);\n                ', 'true', 'uimm != 0', 'IsSerializeAfter', 'IsNonSpeculative', 'No_OpClass'],{})

    Csrrci::Csrrci(ExtMachInst machInst)
        : CSROp("csrrci", machInst, No_OpClass)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((RD) == 0) ? RegId() : intRegClass[RD]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// Unknown::unknown(([], {}))

// M5Op::M5Op(([], {}))

    M5Op::M5Op(ExtMachInst machInst)
        : PseudoOp("M5Op", machInst, IntAluOp)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((10) == 0) ? RegId() : intRegClass[10]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((11) == 0) ? RegId() : intRegClass[11]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

#endif
